<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.1">

  <title>What a Life!</title>

  <meta name="description" content="Software Engineer" />

  
  <meta itemprop="name" content="What a Life!">
  <meta itemprop="description" content="Software Engineer">
  <meta itemprop="datePublished" content="2025-08-29T02:43:31+08:00">
  <meta itemprop="dateModified" content="2028-02-17T08:13:34+08:00">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="What a Life!">
  <meta name="twitter:description" content="Software Engineer">


<meta property="og:url" content="https://www.zhangzewen.net/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="What a Life!">
  <meta property="og:description" content="Software Engineer">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="website">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/#webpage",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2025-08-29T02:43:31+08:00",
      "dateModified": "2028-02-17T08:13:34+08:00",
      "description": "Software Engineer",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  
  <link href="https://www.zhangzewen.net/index.xml" rel="alternate" type="application/rss+xml" title="What a Life!" />
  </head>

<body>
  <aside class="toc">
  
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="posts">
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/">Effective Modern C&#43;&#43; 读书笔记之第五章</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-02-18T18:34:43&#43;0800">Feb 18, 2025</time> &middot; 3 min read
        </div>

        <div>
          <h2 id="item-23-stdmove-和-stdforward语义">Item 23: std::move 和 std::forward语义</h2>
<p><code>Item23</code>开篇就直接说明了<code>std::move</code>不移动任何变量，<code>std::forward</code>不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c++的类型转换)，<code>std::move</code>无条件的把它的参数转换为一个右值，但是<code>std::forward</code>只有在满足一定条件下才会做转换工作。
书中为<code>std::move</code>的实现，写了一个伪码：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>                              <span style="color:#928374;font-style:italic">// in namespace std
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fe8019">typename</span> remove_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>move(T<span style="color:#fe8019">&amp;&amp;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">using</span> ReturnType <span style="color:#fe8019">=</span>                            <span style="color:#928374;font-style:italic">// alias declaration;
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>        <span style="color:#fe8019">typename</span> remove_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&amp;&amp;</span>;     <span style="color:#928374;font-style:italic">// see Item 9
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>    <span style="color:#fe8019">return</span> <span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>ReturnType<span style="color:#fe8019">&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这段代码中，返回值类型为<code>typename remove_reference&lt;T&gt;::type&amp;&amp;</code>说明 <code>std::move</code>返回的是一个右值引用。函数<code>move</code>的参数类型为<code>T&amp;&amp;</code>，具体来说这个一个<code>universal reference</code>(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用<a href="http://en.cppreference.com/w/cpp/types/remove_reference">std::remove_reference</a>剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是&rsquo;公理&rsquo;<code>右值引用坐作函数的返回值返回后是右值</code>。
需要注意的是如果<code>std::move</code>的参数如果是<code>a reference-to-const</code>的话，虽然通过移动语义的作用，使其转换成了右值，但是<code>const</code>语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-four/">Effective Modern C&#43;&#43; 读书笔记之第四章</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-02-17T18:34:42&#43;0800">Feb 17, 2025</time> &middot; 3 min read
        </div>

        <div>
          <h2 id="item-18-stdunique_ptr管理独占资源">Item 18: std::unique_ptr管理独占资源</h2>
<p><code>std::unique_ptr</code>有着几乎和指针几乎相同的性能，大小几乎差不多，且<code>std::unique_ptr</code>不能被赋值，它只有移动语义。对于管理独占资源，<code>std::unique_ptr</code>是一个不错的选择，在工厂模式下，它可以管理生成的对象。
当<code>std::unique_ptr</code>对象是释放的时候，它会释放它所管理的资源，这是它的默认行为。可以为其制定释放它所管理资源的方法，需要实现一个<code>deleter</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">class</span> A
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">public</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>   A() {std<span style="color:#fe8019">::</span>cout <span style="color:#fe8019">&lt;&lt;</span> <span style="color:#b8bb26">&#34;Call A::A()&#34;</span> <span style="color:#fe8019">&lt;&lt;</span> std<span style="color:#fe8019">::</span>endl;}
</span></span><span style="display:flex;"><span>   <span style="color:#fe8019">~</span>() {std<span style="color:#fe8019">::</span>cout <span style="color:#fe8019">&lt;&lt;</span> <span style="color:#b8bb26">&#34;Call A::~A()&#34;</span> <span style="color:#fe8019">&lt;&lt;</span> std<span style="color:#fe8019">::</span>endl;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">auto</span> DeleterOfA <span style="color:#fe8019">=</span> [](A<span style="color:#fe8019">*</span> a) {<span style="color:#fe8019">if</span> (a <span style="color:#fe8019">!=</span> <span style="color:#fe8019">nullptr</span>){<span style="color:#fe8019">delete</span> a;}};
</span></span><span style="display:flex;"><span>std<span style="color:#fe8019">::</span>unique_ptr<span style="color:#fe8019">&lt;</span>A, DeleterOfA<span style="color:#fe8019">&gt;</span> ptrA(<span style="color:#fe8019">new</span> a());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，在使用自定义的<code>deleter</code>的时候，如果<code>deleter</code>是普通的函数的话，那么<code>std::unique_ptr&lt;T, deleter&gt;</code>的大小就是双倍的原始指针的大小(raw pointer，一个指针的大小通常是一个word的大小)。如果是函数对象，没有状态的函数对象，如不捕获任何变量的<code>lambda</code>表达式，<code>std::unique_ptr</code>的大小不变的。但是如果<code>delete</code>是函数的时候，<code>std::unique_ptr</code>增加的一个函数指针的大小，所以在<code>delete</code>的使用上，更推荐使用<code>lambda</code>表达式。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-four/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kubelet/resource-qos/">kubernetes 源码分析之 Kubernetes Resource QoS Classes </a>
        </h1>

        <div class="post-date">
          <time datetime="2025-02-10T09:43:31&#43;0800">Feb 10, 2025</time> &middot; 3 min read
        </div>

        <div>
          <blockquote>
<p>本篇文章基于 Kubernetes v1.25.1</p></blockquote>
<p>Kubernetes 根据 Pod 中 Containers Resource 的 <code>request</code> 和 <code>limit</code> 的值来定义 Pod 的 QoS Class。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kubelet/resource-qos/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-three/">Effective Modern C&#43;&#43; 读书笔记之第三章</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-02-07T18:34:41&#43;0800">Feb 7, 2025</time> &middot; 5 min read
        </div>

        <div>
          <h2 id="item-7-区别和在声明和初始化变量时的不同">Item 7: 区别()和{}在声明和初始化变量时的不同</h2>
<p>在<a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/">Effective Modern C++ 读书笔记之第一章</a>关于<code>auto</code>的参数类型推导中，里面说到<code>auto</code>的类型推导中与模版参数类型推导唯一的不同之处：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">auto</span> a <span style="color:#fe8019">=</span> {<span style="color:#d3869b">1</span>}; <span style="color:#928374;font-style:italic">// a 的类型为 std::initializer_list&lt;int&gt;
</span></span></span></code></pre></div><p>在<code>C++11</code>中有四种声明变量的方式：</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-three/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kubelet/pause/">kubernetes 源码分析之 Pause 容器</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-01-27T23:16:45&#43;0800">Jan 27, 2025</time> &middot; 1 min read
        </div>

        <div>
          <blockquote>
<p>本篇文章基于 Kubernetes v1.25.1</p></blockquote>
<p>Pod 是 kubernetes 里最小调度单元，一个 Pod 里面可以包含由多个容器。 这些容器之间通过 linux namespace 来共享资源以及和宿主节点环境隔离。Pod 里面最基础的容器是 pause 容器，它是 Pod 启动的时候，首先创建的容器，其他的业务容器都依赖该 pause 容器，毕竟它提供了可共享的 linux namspace。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kubelet/pause/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kubelet/garbage_collection/">kubernetes 源码分析之 kubelet 镜像回收和容器回收</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-01-27T22:44:45&#43;0800">Jan 27, 2025</time> &middot; 8 min read
        </div>

        <div>
          <blockquote>
<p>本篇文章基于 Kubernetes v1.25.1</p></blockquote>
<p>kubelet 提供了驱逐和垃圾回收机制来保证节点健康，即节点资源不会被消耗殆尽。本片文章从源码角度来分析 kubelet 的垃圾回收功能，即清理不需要的容器和镜像。</p>
<h2 id="启动切入点">启动切入点</h2>
<p>垃圾回收是在 kubelet 对象初始化完成后启动的，在 createAndInitKubelet 方法中首先调用 NewMainKubelet 初始化 Kubelet 实例，随后调用 <code>Kubelet.StartGarbageCollection</code> 启动了 GarbageCollect。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kubelet/garbage_collection/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kube-proxy/ipvs/">kubernetes 源码分析之 kube-proxy ipvs 模式</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-01-21T21:39:37&#43;0800">Jan 21, 2025</time> &middot; 10 min read
        </div>

        <div>
          <blockquote>
<p>本篇文章基于 Kubernetes v1.25.1</p></blockquote>
<p><a href="https://www.zhangzewen.net/posts/kubernetes/kube-proxy/kube-proxy/">上一篇文章</a> 分析了 kube-proxy 的主流程逻辑实现，本篇文章通过分析核心方法 syncProxyRules 来分析 kube-proxy 的 ipvs 模式的实现。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kube-proxy/ipvs/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-two/">Effective Modern C&#43;&#43; 读书笔记之第二章</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-01-10T18:34:40&#43;0800">Jan 10, 2025</time> &middot; 1 min read
        </div>

        <div>
          <h2 id="item-5-auto优先于显示类型声明">Item 5: auto优先于显示类型声明</h2>
<p>首先，在<code>C/C++</code>中声明一个变量，如果不进行初始化，其默认值可能会因为其所在的作用域的不同而不同，在使用的时候可能会出现意想不到的错误。而<code>auto</code>类型的变量类型是从初始化进行推导的，所以需要在定义<code>auto</code>变量的时候进行初始化。使用<code>auto</code>变量可以强制对其进行初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fabd2f">int</span> a; <span style="color:#928374;font-style:italic">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fe8019">auto</span> x <span style="color:#fe8019">=</span> <span style="color:#d3869b">10</span>; <span style="color:#928374;font-style:italic">//ok
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fe8019">auto</span> a; <span style="color:#928374;font-style:italic">//error: declaration of ‘auto a’ has no initializer
</span></span></span></code></pre></div><p>其次，使用<code>auto</code>可以避免冗长的显示类型声明，特别是在操作<code>STL</code>的各种容器及迭代器等, <code>auto</code>可以节省很多时间，如：</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-two/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/">Effective Modern C&#43;&#43; 读书笔记之第一章</a>
        </h1>

        <div class="post-date">
          <time datetime="2025-01-07T18:34:39&#43;0800">Jan 7, 2025</time> &middot; 5 min read
        </div>

        <div>
          <h2 id="item-1-模板类型推导">Item 1: 模板类型推导</h2>
<p><code>C++98</code>只有一种模板参数类型推导即函数模板参数类型推导，但是在<code>C++11</code>之后，修改了原有的类型推导规则，并加入了<code>auto</code>和<code>decltype</code>的推导规则。
函数模板形如：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> f(ParamType param);<span style="color:#928374;font-style:italic">// ParamType可以是T加上各种修饰，如const， reference，指针等
</span></span></span></code></pre></div><p>然后在程序逻辑中调用该函数：</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/">Read More</a>
        </div>
      </article>
      <article class="post">
        <h1 class="post-title">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kube-proxy/iptables/">kubernetes 源码分析之 kube-proxy iptables 模式</a>
        </h1>

        <div class="post-date">
          <time datetime="2024-11-23T16:31:39&#43;0800">Nov 23, 2024</time> &middot; 7 min read
        </div>

        <div>
          <blockquote>
<p>本篇文章基于 Kubernetes v1.25.1</p></blockquote>
<p><a href="https://www.zhangzewen.net/posts/kubernetes/kube-proxy/kube-proxy/">上一篇文章</a> 分析了 kube-proxy 的主流程逻辑实现，本片文章来分析 kube-proxy 的 iptables 模式实现。</p>
        </div>

        <div class="read-more-link">
          <a href="https://www.zhangzewen.net/posts/kubernetes/kube-proxy/iptables/">Read More</a>
        </div>
      </article>
  </div>

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/page/3/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/page/2/" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/page/6/" aria-label="Page 6" class="page-link" role="button">6</a>
      </li>
      <li class="page-item">
        <a href="/page/5/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/page/7/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
