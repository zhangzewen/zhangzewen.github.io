<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on What a Life!</title>
    <link>https://www.zhangzewen.net/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on What a Life!</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 15 Mar 2025 09:43:31 +0800</lastBuildDate>
    <atom:link href="https://www.zhangzewen.net/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; Type Traits 和 SFINAE</title>
      <link>https://www.zhangzewen.net/posts/cpp/deep_dive_into_type_traits_and_sfinae/</link>
      <pubDate>Sat, 15 Mar 2025 09:43:31 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/deep_dive_into_type_traits_and_sfinae/</guid>
      <description>&lt;h2 id=&#34;type-traits&#34;&gt;Type Traits&lt;/h2&gt;&#xA;&lt;p&gt;c++ type traits 特性一句话总结：“&lt;strong&gt;在编译期利用模板的(偏)特化功能提取目标的相关信息，用于确定策略或者实现细节&lt;/strong&gt;”。&lt;/p&gt;&#xA;&lt;p&gt;这在模板编程中很有用， 因为模板参数&lt;code&gt;T&lt;/code&gt;的存在，实现模板的人很难预测使用模板的人会输入什么类型的参数，一般的 c++ type traits 的编程套路就是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; STL 迭代器</title>
      <link>https://www.zhangzewen.net/posts/cpp/deep_dive_into_cpp_iterators/</link>
      <pubDate>Sun, 02 Mar 2025 09:43:31 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/deep_dive_into_cpp_iterators/</guid>
      <description>&lt;h2 id=&#34;c-迭代器的种类&#34;&gt;c++ 迭代器的种类&lt;/h2&gt;&#xA;&lt;p&gt;在STL中，迭代器的种类可以分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;input_iterator_tag&lt;/span&gt; {};  &lt;span style=&#34;color:#6272a4&#34;&gt;// 输入迭代器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;output_iterator_tag&lt;/span&gt; {}; &lt;span style=&#34;color:#6272a4&#34;&gt;// 输出迭代器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;forward_iterator_tag&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt; input_iterator_tag {};  &lt;span style=&#34;color:#6272a4&#34;&gt;// 向前迭代器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;bidirectional_iterator_tag&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt; forward_iterator_tag {}; &lt;span style=&#34;color:#6272a4&#34;&gt;// 双向迭代器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ff79c6&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;random_access_iterator_tag&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt; bidirectional_iterator_tag {}; &lt;span style=&#34;color:#6272a4&#34;&gt;// 随机访问迭代器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输入迭代器指向的位置只能被顺序读取：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective Modern C&#43;&#43; 读书笔记之第六章</title>
      <link>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/</link>
      <pubDate>Thu, 27 Feb 2025 18:34:44 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/</guid>
      <description>&lt;h2 id=&#34;item-31-避免使用默认的变量捕获方式&#34;&gt;Item 31 避免使用默认的变量捕获方式&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;c++11&lt;/code&gt;的&lt;code&gt;lambda&lt;/code&gt;表达式有两种变量的捕获方式：按值(复制)捕获和引用捕获(默认模式)。在采用引用模式(默认&lt;code&gt;[&amp;amp;]&lt;/code&gt;会捕获定义&lt;code&gt;lambda&lt;/code&gt;表达式作用域下的所有变量, &lt;code&gt;[&amp;amp;params]&lt;/code&gt;为显示捕获定义&lt;code&gt;lambda&lt;/code&gt;表达式作用域下特定的变量)下，如果不加注意的话,&lt;code&gt;lambda&lt;/code&gt;表达式很容易走出引用变量的作用域范围，造成悬空引用，会产生未定义的错误。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;A&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    A() &lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt; name_(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;){}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Print&lt;/span&gt;() &lt;span style=&#34;color:#ff79c6&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;A::Print: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name_ &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;string name_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;typedef&lt;/span&gt; std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;void&lt;/span&gt;()&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; func;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#8be9fd&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;**&lt;/span&gt; argv)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    func target;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        A a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;auto&lt;/span&gt; f &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;](){ a.Print();};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#6272a4&#34;&gt;//auto f = [&amp;amp;a](){ a.Print();};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        target &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; f;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    target();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我自己机器下的测试结果为&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective Modern C&#43;&#43; 读书笔记之第五章</title>
      <link>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/</link>
      <pubDate>Tue, 18 Feb 2025 18:34:43 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/</guid>
      <description>&lt;h2 id=&#34;item-23-stdmove-和-stdforward语义&#34;&gt;Item 23: std::move 和 std::forward语义&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Item23&lt;/code&gt;开篇就直接说明了&lt;code&gt;std::move&lt;/code&gt;不移动任何变量，&lt;code&gt;std::forward&lt;/code&gt;不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c++的类型转换)，&lt;code&gt;std::move&lt;/code&gt;无条件的把它的参数转换为一个右值，但是&lt;code&gt;std::forward&lt;/code&gt;只有在满足一定条件下才会做转换工作。&#xA;书中为&lt;code&gt;std::move&lt;/code&gt;的实现，写了一个伪码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;                              &lt;span style=&#34;color:#6272a4&#34;&gt;// in namespace std&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;typename&lt;/span&gt; remove_reference&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;move(T&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; param)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;using&lt;/span&gt; ReturnType &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt;                            &lt;span style=&#34;color:#6272a4&#34;&gt;// alias declaration;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;typename&lt;/span&gt; remove_reference&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;;     &lt;span style=&#34;color:#6272a4&#34;&gt;// see Item 9&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;ReturnType&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;(param);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这段代码中，返回值类型为&lt;code&gt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&lt;/code&gt;说明 &lt;code&gt;std::move&lt;/code&gt;返回的是一个右值引用。函数&lt;code&gt;move&lt;/code&gt;的参数类型为&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;，具体来说这个一个&lt;code&gt;universal reference&lt;/code&gt;(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用&lt;a href=&#34;http://en.cppreference.com/w/cpp/types/remove_reference&#34;&gt;std::remove_reference&lt;/a&gt;剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是&amp;rsquo;公理&amp;rsquo;&lt;code&gt;右值引用坐作函数的返回值返回后是右值&lt;/code&gt;。&#xA;需要注意的是如果&lt;code&gt;std::move&lt;/code&gt;的参数如果是&lt;code&gt;a reference-to-const&lt;/code&gt;的话，虽然通过移动语义的作用，使其转换成了右值，但是&lt;code&gt;const&lt;/code&gt;语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective Modern C&#43;&#43; 读书笔记之第四章</title>
      <link>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-four/</link>
      <pubDate>Mon, 17 Feb 2025 18:34:42 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-four/</guid>
      <description>&lt;h2 id=&#34;item-18-stdunique_ptr管理独占资源&#34;&gt;Item 18: std::unique_ptr管理独占资源&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;有着几乎和指针几乎相同的性能，大小几乎差不多，且&lt;code&gt;std::unique_ptr&lt;/code&gt;不能被赋值，它只有移动语义。对于管理独占资源，&lt;code&gt;std::unique_ptr&lt;/code&gt;是一个不错的选择，在工厂模式下，它可以管理生成的对象。&#xA;当&lt;code&gt;std::unique_ptr&lt;/code&gt;对象是释放的时候，它会释放它所管理的资源，这是它的默认行为。可以为其制定释放它所管理资源的方法，需要实现一个&lt;code&gt;deleter&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;A&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   A() {std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Call A::A()&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;endl;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#ff79c6&#34;&gt;~&lt;/span&gt;() {std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Call A::~A()&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;endl;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;auto&lt;/span&gt; DeleterOfA &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; [](A&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; a) {&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (a &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nullptr&lt;/span&gt;){&lt;span style=&#34;color:#ff79c6&#34;&gt;delete&lt;/span&gt; a;}};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#ff79c6&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;A, DeleterOfA&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt; ptrA(&lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; a());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的是，在使用自定义的&lt;code&gt;deleter&lt;/code&gt;的时候，如果&lt;code&gt;deleter&lt;/code&gt;是普通的函数的话，那么&lt;code&gt;std::unique_ptr&amp;lt;T, deleter&amp;gt;&lt;/code&gt;的大小就是双倍的原始指针的大小(raw pointer，一个指针的大小通常是一个word的大小)。如果是函数对象，没有状态的函数对象，如不捕获任何变量的&lt;code&gt;lambda&lt;/code&gt;表达式，&lt;code&gt;std::unique_ptr&lt;/code&gt;的大小不变的。但是如果&lt;code&gt;delete&lt;/code&gt;是函数的时候，&lt;code&gt;std::unique_ptr&lt;/code&gt;增加的一个函数指针的大小，所以在&lt;code&gt;delete&lt;/code&gt;的使用上，更推荐使用&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective Modern C&#43;&#43; 读书笔记之第三章</title>
      <link>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-three/</link>
      <pubDate>Fri, 07 Feb 2025 18:34:41 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-three/</guid>
      <description>&lt;h2 id=&#34;item-7-区别和在声明和初始化变量时的不同&#34;&gt;Item 7: 区别()和{}在声明和初始化变量时的不同&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/&#34;&gt;Effective Modern C++ 读书笔记之第一章&lt;/a&gt;关于&lt;code&gt;auto&lt;/code&gt;的参数类型推导中，里面说到&lt;code&gt;auto&lt;/code&gt;的类型推导中与模版参数类型推导唯一的不同之处：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;auto&lt;/span&gt; a &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;}; &lt;span style=&#34;color:#6272a4&#34;&gt;// a 的类型为 std::initializer_list&amp;lt;int&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;C++11&lt;/code&gt;中有四种声明变量的方式：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective Modern C&#43;&#43; 读书笔记之第二章</title>
      <link>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-two/</link>
      <pubDate>Fri, 10 Jan 2025 18:34:40 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-two/</guid>
      <description>&lt;h2 id=&#34;item-5-auto优先于显示类型声明&#34;&gt;Item 5: auto优先于显示类型声明&lt;/h2&gt;&#xA;&lt;p&gt;首先，在&lt;code&gt;C/C++&lt;/code&gt;中声明一个变量，如果不进行初始化，其默认值可能会因为其所在的作用域的不同而不同，在使用的时候可能会出现意想不到的错误。而&lt;code&gt;auto&lt;/code&gt;类型的变量类型是从初始化进行推导的，所以需要在定义&lt;code&gt;auto&lt;/code&gt;变量的时候进行初始化。使用&lt;code&gt;auto&lt;/code&gt;变量可以强制对其进行初始化。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; a; &lt;span style=&#34;color:#6272a4&#34;&gt;//ok&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;auto&lt;/span&gt; x &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#6272a4&#34;&gt;//ok&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;auto&lt;/span&gt; a; &lt;span style=&#34;color:#6272a4&#34;&gt;//error: declaration of ‘auto a’ has no initializer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其次，使用&lt;code&gt;auto&lt;/code&gt;可以避免冗长的显示类型声明，特别是在操作&lt;code&gt;STL&lt;/code&gt;的各种容器及迭代器等, &lt;code&gt;auto&lt;/code&gt;可以节省很多时间，如：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Effective Modern C&#43;&#43; 读书笔记之第一章</title>
      <link>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/</link>
      <pubDate>Tue, 07 Jan 2025 18:34:39 +0800</pubDate>
      <guid>https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/</guid>
      <description>&lt;h2 id=&#34;item-1-模板类型推导&#34;&gt;Item 1: 模板类型推导&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;C++98&lt;/code&gt;只有一种模板参数类型推导即函数模板参数类型推导，但是在&lt;code&gt;C++11&lt;/code&gt;之后，修改了原有的类型推导规则，并加入了&lt;code&gt;auto&lt;/code&gt;和&lt;code&gt;decltype&lt;/code&gt;的推导规则。&#xA;函数模板形如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;void&lt;/span&gt; f(ParamType param);&lt;span style=&#34;color:#6272a4&#34;&gt;// ParamType可以是T加上各种修饰，如const， reference，指针等&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在程序逻辑中调用该函数：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
