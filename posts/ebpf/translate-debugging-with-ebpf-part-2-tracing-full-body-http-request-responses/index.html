<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.0">

  <title>[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses">
  <meta itemprop="description" content="介于能力有限，翻译有不当之处，不吝赐教
这是一个系列文章：
[译]Debugging with eBPF Part 1: Tracing Go function arguments in prod [译]Debugging with eBPF Part 3: Tracing SSL/TLS connections 原文：Debugging with eBPF Part 2: Tracing full body HTTP request/responses">
  <meta itemprop="datePublished" content="2024-03-13T21:03:01+08:00">
  <meta itemprop="dateModified" content="2024-03-13T21:03:01+08:00">
  <meta itemprop="wordCount" content="459">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="EBPF,Linux,Kernel,Tracing,Debug,Go,翻译">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses">
  <meta name="twitter:description" content="介于能力有限，翻译有不当之处，不吝赐教
这是一个系列文章：
[译]Debugging with eBPF Part 1: Tracing Go function arguments in prod [译]Debugging with eBPF Part 3: Tracing SSL/TLS connections 原文：Debugging with eBPF Part 2: Tracing full body HTTP request/responses">


<meta property="og:url" content="https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses">
  <meta property="og:description" content="介于能力有限，翻译有不当之处，不吝赐教
这是一个系列文章：
[译]Debugging with eBPF Part 1: Tracing Go function arguments in prod [译]Debugging with eBPF Part 3: Tracing SSL/TLS connections 原文：Debugging with eBPF Part 2: Tracing full body HTTP request/responses">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-13T21:03:01+08:00">
    <meta property="article:modified_time" content="2024-03-13T21:03:01+08:00">
    <meta property="article:tag" content="EBPF">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Kernel">
    <meta property="article:tag" content="Tracing">
    <meta property="article:tag" content="Debug">
    <meta property="article:tag" content="Go">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/#webpage",
      "url": "https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/",
      "name": "[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2024-03-13T21:03:01+08:00",
      "dateModified": "2024-03-13T21:03:01+08:00",
      "description": "\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e介于能力有限，翻译有不当之处，不吝赐教\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e这是一个系列文章：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-1-tracing-go-function-arguments-in-prod/\"\u003e[译]Debugging with eBPF Part 1: Tracing Go function arguments in prod\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-3-tracing-ssl-tls-connections/\"\u003e[译]Debugging with eBPF Part 3: Tracing SSL/TLS connections\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e原文：\u003ca href=\"https://blog.px.dev/ebpf-http-tracing/\"\u003eDebugging with eBPF Part 2: Tracing full body HTTP request/responses\u003c/a\u003e\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/#webpage"
      },
      "headline": "[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses",
      "datePublished": "2024-03-13T21:03:01+08:00",
      "dateModified": "2024-03-13T21:03:01+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "EBPF",
        "Linux",
        "Kernel",
        "Tracing",
        "Debug",
        "Go",
        "翻译"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-2-tracing-full-body-http-request-responses/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一个http请求期间发生了什么">一个HTTP请求期间发生了什么?</a></li>
        <li><a href="#使用kprobes进行跟踪">使用Kprobes进行跟踪</a></li>
        <li><a href="#使用uprobes进行跟踪">使用Uprobes进行跟踪</a></li>
        <li><a href="#uprobes-和-kprobes--性能压测">uprobes 和 kprobes  性能压测</a></li>
        <li><a href="#结论">结论</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">[译]Debugging with eBPF Part 2: Tracing full body HTTP request/responses</h1>
  
  

  <div class="post-date">
    <time datetime=" 2024-03-13T21:03:01&#43;0800">Created: Mar 13, 2024</time>
    <span class="readtime">&middot; 3 min read</span>
  </div>

  <div>
    <blockquote>
<p><em><strong>介于能力有限，翻译有不当之处，不吝赐教</strong></em></p>
<p>这是一个系列文章：</p>
<ul>
<li><a href="https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-1-tracing-go-function-arguments-in-prod/">[译]Debugging with eBPF Part 1: Tracing Go function arguments in prod</a></li>
<li><a href="https://www.zhangzewen.net/posts/ebpf/translate-debugging-with-ebpf-part-3-tracing-ssl-tls-connections/">[译]Debugging with eBPF Part 3: Tracing SSL/TLS connections</a></li>
</ul>
<p>原文：<a href="https://blog.px.dev/ebpf-http-tracing/">Debugging with eBPF Part 2: Tracing full body HTTP request/responses</a></p></blockquote>
<p>这是本系列帖子中的第二篇，我们将分享在不重新编译/部署应用程序的情况下使用eBPF进行调试。<a href="https://blog.px.dev/ebpf-function-tracing/">第一部分</a>简要介绍了eBPF，并演示了如何使用它来编写一个简单的函数参数跟踪器。在这篇第二篇文章中，我们将看看如何使用eBPF捕获HTTP 1.X流量。</p>
<p>当处理分布式应用程序时，获得HTTP流量的观测性数据非常有价值。这些数据可以用于性能、功能和安全监控。许多应用程序通过利用中间件向应用程序的HTTP请求添加跟踪或日志记录来实现此目的。人们还可以利用流行的开源框架（如<a href="https://opentelemetry.io/">Open Telemetry</a>）来监控请求和相关上下文。在本文中，我们将介绍一种替代方法，利用eBPF捕获HTTP数据而无需手动添加监控工具。这种方法的一个优点是它始终有效，即使应用程序没有被专门监控也是如此。</p>
<p>在本系列的<a href="https://blog.px.dev/ebpf-function-tracing/">第一部分</a>提供了更详细的eBPF概述，它允许您在某些触发事件上运行受限制的C代码。Kprobes 提供了一种跟踪内核API或内部机制的机制，而 uprobes则提供了拦截用户程序中特定指令的机制。由于应用程序通常位于Kernel系统API之上，如果我们捕获Kernel接口，则应该能够捕获所有入站和出站数据并重构HTTP请求。</p>
<p>或者，我们可以使用 uprobes 来仔细地检测底层的 HTTP 库（例如 Go 中的 net/http）以直接捕获HTTP请求。由于 uprobes 在应用程序级别上工作，因此它们的实现将取决于所使用的基础语言。</p>
<p>这篇文章将探讨使用 kprobes 和 uprobes 来跟踪 HTTP 请求，并权衡它们的利弊。</p>
<h2 id="一个http请求期间发生了什么">一个HTTP请求期间发生了什么?</h2>
<p>在我们开始编写任何BPF代码之前，让我们尝试了解系统如何处理 HTTP 请求。 我们将利用<a href="https://blog.px.dev/ebpf-function-tracing/">第一部分</a>中使用的相同测试应用程序，一个简单的Golang HTTP服务器（simpleHTTP），但结果适用于其他HTTP应用程序。 第一步是了解发送和接收简单HTTP请求的Linux内核API是什么。</p>
<p>我们可以使用Linux perf命令来了解哪些系统调用被调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo perf trace -p &lt;PID&gt;
</span></span></code></pre></div><p>我们将在另一个终端窗口中使用 curl 命令发出一个简单的 HTTP 请求：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl http://localhost:9090/e<span style="color:#f1fa8c">\?</span>iters<span style="color:#f1fa8c">\=</span><span style="color:#bd93f9">10</span>
</span></span></code></pre></div><p>在 <code>pref</code> 命令运行的终端下，你会看到如下输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">[</span>0<span style="color:#ff79c6">]</span> % sudo perf trace -p <span style="color:#bd93f9">1011089</span>
</span></span><span style="display:flex;"><span>        ? <span style="color:#ff79c6">(</span>         <span style="color:#ff79c6">)</span>: app/1011089  ... <span style="color:#ff79c6">[</span>continued<span style="color:#ff79c6">]</span>: epoll_pwait<span style="color:#ff79c6">())</span>                                      <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    0.087 <span style="color:#ff79c6">(</span> 0.004 ms<span style="color:#ff79c6">)</span>: app/1011089 accept4<span style="color:#ff79c6">(</span>fd: 3&lt;socket:<span style="color:#ff79c6">[</span>7062148<span style="color:#ff79c6">]</span>&gt;, upeer_sockaddr: 0xc0000799c8, upeer_addrlen: 0xc0000799ac, flags: 526336<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">=</span> -1 EAGAIN <span style="color:#ff79c6">(</span>Resource temporarily unavailable<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>    0.196 <span style="color:#ff79c6">(</span> 0.005 ms<span style="color:#ff79c6">)</span>: app/1011089 read<span style="color:#ff79c6">(</span>fd: 4, buf: 0xc00010e000, count: 4096<span style="color:#ff79c6">)</span>                           <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">88</span>
</span></span><span style="display:flex;"><span>    0.238 <span style="color:#ff79c6">(</span> 0.005 ms<span style="color:#ff79c6">)</span>: app/1011089 futex<span style="color:#ff79c6">(</span>uaddr: 0xc000098148, op: WAKE|PRIVATE_FLAG, val: 1<span style="color:#ff79c6">)</span>             <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    0.278 <span style="color:#ff79c6">(</span> 0.023 ms<span style="color:#ff79c6">)</span>: app/1011089 write<span style="color:#ff79c6">(</span>fd: 4, buf: 0xc00010f000, count: 128<span style="color:#ff79c6">)</span>                           <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">128</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    0.422 <span style="color:#ff79c6">(</span> 0.002 ms<span style="color:#ff79c6">)</span>: app/1011091 close<span style="color:#ff79c6">(</span>fd: 4<span style="color:#ff79c6">)</span>                                                          <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>需要注意的是不要在这个简单的 Golang HTTP 服务器实现 <a href="https://github.com/pixie-io/pixie-demos/blob/main/simple-gotracing/app/app.go">app.go</a> 中有任何额外的打印语句，以避免创建额外的系统调用。</p>
<p>检查 <code>perf</code> 调用的输出，我们发现有 3 个相关的系统调用：<code>accept4</code>、<code>write</code>、<code>close</code>。 跟踪这些系统调用应该允许我们捕获服务器为响应请求而发送的所有数据。</p>
<p>从服务器的角度来看，一个典型的请求流程如下所示，其中每个框代表一个系统调用。 Linux 系统调用 API 通常比这复杂得多，并且可以使用其他变体。 出于本文的目的，我们假设这是一个简化版本，它适用于我们正在跟踪的应用程序。</p>
<p><img src="https://blog.px.dev/static/e9171b519eb9bd5e8cb37a3750e16f2d/http-request-flow-syscalls.png" alt="img"></p>
<p>图1: 一个HTTP请求的系统调用流程</p>
<p>虽然此示例的重点是跟踪 HTTP 响应，但也可以通过向  <code>read</code>  系统调用添加探针来跟踪 HTTP 请求中发送的数据。</p>
<h2 id="使用kprobes进行跟踪">使用Kprobes进行跟踪</h2>
<p>现在我们知道跟踪 <code>accept4</code>、<code>write</code> 和 <code>close</code> 对这个二进制文件已经足够了，我们可以开始构建 BPF 源代码了。 我们的程序大致如下所示：</p>
<p><img src="https://blog.px.dev/static/351711bdbe0647329de98bc9574ed4bc/kprobe-tracing.png" alt="img"></p>
<p>图2: 基于eBPF kprobes 跟踪HTTP图示</p>
<p>为了避免 eBPF 的限制（堆栈大小等），实现的时候需要增加一些额外复杂性，我们需要使用 4 个单独的探针捕获以下内容：</p>
<ul>
<li><strong>调用<code>accept4</code></strong>：该调用包含有关套接字的信息。 存储这个socket信息</li>
<li><strong>从<code>accept4</code>返回</strong>：accept4 的返回值是文件描述符。 将此文件描述符存储在 BPF_MAP 中。</li>
<li><strong>调用 <code>write</code></strong>：write 函数为我们提供了有关文件描述符和写入该文件描述符的数据的信息。 将这些数据写入 perf 缓冲区，以便用户空间跟踪程序可以读取它。</li>
<li><strong>调用<code>close</code></strong>：使用文件描述符信息来清除我们上面分配的BPF_MAP并停止跟踪这个fd。</li>
</ul>
<p>请注意，kprobes 在整个系统中工作，因此我们需要按 PID 进行过滤，以捕获感兴趣的进程中的数据。 这适用于上面列出的所有探针。</p>
<p>捕获数据后，我们可以将其读取到 Go 用户空间程序并使用 <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> 库解析 HTTP 响应。</p>
<p>Kprobe 方法在概念上很简单，但实现相当长。 你可以查看详细的代码 <a href="https://github.com/pixie-io/pixie-demos/blob/main/simple-gotracing/http_trace_kprobe/http_trace_kprobe.go">这里</a>。 为简洁起见，我们省略了一些细节，例如从 write 读取返回值以了解实际写入了多少字节。</p>
<p>使用 kprobes 捕获数据的一个缺点是我们要重新解析所有响应，因为我们会在它们被转换为写入格式后拦截它们。 另一种方法是在数据被发送到内核之前使用 uprobes 捕获数据，在内核中我们可以在数据被序列化之前读取数据。</p>
<h2 id="使用uprobes进行跟踪">使用Uprobes进行跟踪</h2>
<p>Uprobes可以用于在特定地址中断程序的执行，并允许BPF程序收集底层数据。这种能力可用于捕获客户端库中的数据，但底层BPF代码和感兴趣的地址/偏移量将取决于库的实现。因此，如果客户端库发生变化，则uprobes也需要更新。因此，最好为不太可能大改的客户端库添加uprobes，以尽量减少我们对uprobes程序的更新工作量。</p>
<p>对于 Go，我们将尝试在底层的 <a href="https://golang.org/pkg/net/http/"><code>net/http</code></a> 库上找到一个跟踪点。 一种方法是直接检查代码以确定探测的位置。 我们将展示另一种方法，可用于确定哪些部分是相关的。 为此，让我们在 <a href="https://github.com/go-delve/delve">delve</a> 下运行我们的应用程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">[</span>0<span style="color:#ff79c6">]</span> % dlv <span style="color:#8be9fd;font-style:italic">exec</span> ./app
</span></span><span style="display:flex;"><span>Type <span style="color:#f1fa8c">&#39;help&#39;</span> <span style="color:#ff79c6">for</span> list of commands.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>dlv<span style="color:#ff79c6">)</span> c
</span></span><span style="display:flex;"><span>Starting server on: :9090
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>dlv<span style="color:#ff79c6">)</span> <span style="color:#8be9fd;font-style:italic">break</span> syscall.write
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#bd93f9">1</span> <span style="color:#8be9fd;font-style:italic">set</span> at 0x497083 <span style="color:#ff79c6">for</span> syscall.write<span style="color:#ff79c6">()</span> /opt/golang/src/syscall/zsyscall_linux_amd64.go:998
</span></span></code></pre></div><p>如前所述，操作系统使用 <code>write</code> 系统调用来发送 HTTP 响应。 因此，我们在那里设置了一个断点，以便我们可以识别触发系统调用 <code>write</code> 的底层客户端代码。 当我们再次运行 <code>curl</code> 命令时，程序应该会中断。 我们使用 <code>bt</code> 获得回溯：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>1<span style="color:#ff79c6">(</span>dlv<span style="color:#ff79c6">)</span> bt
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">2</span>  0x0000000000497083 in syscall.write at /opt/golang/src/syscall/zsyscall_linux_amd64.go:998
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">3</span>  0x00000000004aa481 in syscall.Write at /opt/golang/src/syscall/syscall_unix.go:202
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">4</span>  0x00000000004aa481 in internal/poll.<span style="color:#ff79c6">(</span>*FD<span style="color:#ff79c6">)</span>.Write at /opt/golang/src/internal/poll/fd_unix.go:268
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">5</span>  0x0000000000545c4f in net.<span style="color:#ff79c6">(</span>*netFD<span style="color:#ff79c6">)</span>.Write at /opt/golang/src/net/fd_unix.go:220
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">6</span>  0x0000000000551ef8 in net.<span style="color:#ff79c6">(</span>*conn<span style="color:#ff79c6">)</span>.Write at /opt/golang/src/net/net.go:196
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">7</span>  0x0000000000638e36 in net/http.checkConnErrorWriter.Write at /opt/golang/src/net/http/server.go:3419
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">8</span>  0x00000000005116c5 in bufio.<span style="color:#ff79c6">(</span>*Writer<span style="color:#ff79c6">)</span>.Flush at /opt/golang/src/bufio/bufio.go:593
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">9</span>  0x0000000000632c61 in net/http.<span style="color:#ff79c6">(</span>*response<span style="color:#ff79c6">)</span>.finishRequest at /opt/golang/src/net/http/server.go:1588
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">10</span>  0x0000000000633bd3 in net/http.<span style="color:#ff79c6">(</span>*conn<span style="color:#ff79c6">)</span>.serve at /opt/golang/src/net/http/server.go:1895
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">11</span>  0x000000000045afe1 in runtime.goexit at /opt/golang/src/runtime/asm_amd64.s:1357
</span></span></code></pre></div><p>检查堆栈，我们发现第 9 行的 <code>net/http.(*response).finishRequest</code> 函数看起来很有希望。 Go 源代码告诉我们，每次 HTTP 请求完成时都会调用该函数。 此功能是获取特定请求的 uprobes 数据的好地方。</p>
<p>数据的捕获是我们在[第1部分](Debugging with eBPF Part 1: Tracing Go function arguments in prod.md) 中的方法的直接扩展。我们采用相同的策略来读取结构中的变量，只是这次我们需要追踪一些指针。 用于此的 BPF 代码位于 <a href="https://github.com/pixie-io/pixie-demos/tree/main/simple-gotracing/http_trace_uprobe">此处</a>。</p>
<p>为了比较上面两种不同的方法，我们必须考虑:</p>
<ol>
<li>哪种探针更容易设计和实现？</li>
<li>哪种探针的性能更强</li>
<li>哪种探针更容易维护</li>
</ol>
<p>为了回答第一个问题，让我们看看每种方法的优缺点。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left">优点</th>
          <th style="text-align: left">缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">kprobe</td>
          <td style="text-align: left">- 目标语言无关<br/> - 实现更简单，可维护性更强。它不依赖于其他库的实现细节。</td>
          <td style="text-align: left">- 用户程序可能会将一个请求分给多个系统调用。<br />- 重新组合这些请求有一定的复杂性。<br />- 不支持TLS</td>
      </tr>
      <tr>
          <td style="text-align: left">uprobe</td>
          <td style="text-align: left">- 除了请求本身之外，我们还可以访问和捕获应用程序的上下文，如堆栈跟踪。<br/>- 我们可以在解析完成后构建 uprobes 来捕获数据，避免在跟踪器中重复工作。<br/>- 支持 TLS</td>
          <td style="text-align: left">- 对正在使用的底层库的版本很敏感。<br/>- 不适用于去除符号的二进制文件。<br/>- 需要为每个库实现不同的探针（而且每种编程语言都可能有自己的一套库）<br/>- 对于像Python这样的动态语言，可能很难（不可能），因为很难在它们的底层运行环境中找到合适的位置来探测。<br/>- 产生额外的系统调用</td>
      </tr>
  </tbody>
</table>
<p>从概念上讲，Kprobes是明显的赢家，因为我们可以避免任何语言依赖来执行HTTP捕获。然而，这种方法有一个额外的注意事项，即我们需要重新解析每个响应，因此我们应该调查是否引入了重大性能开销。值得注意的是kprobes不适用于TLS。但是，在后续的文章中，我们将分享使用eBPF跟踪TLS请求的方法。</p>
<h2 id="uprobes-和-kprobes--性能压测">uprobes 和 kprobes  性能压测</h2>
<p>由于这些探针将用于监视生产中的应用程序，因此我们希望它们具有最小的开销。在完全加载的系统上，我们想了解部署跟踪器的影响。我们可以使用一种指标来了解性能影响，即观察延迟和处理高请求吞吐量的能力受到的影响。这不是一个全面的测试，我们将利用简单应用二进制文件进行测试。由于探针仅在实际发出HTTP请求时添加开销，而不是在处理请求时添加开销，因此我们简单的二进制文件几乎模拟了最坏情况下的情形。</p>
<p>我们的实验设置看起来像：</p>
<p><img src="https://blog.px.dev/static/2ec33f85c5aef2844279c8a10d25b3f6/benchmark.png" alt="img"></p>
<p>图3: kprobes和uprobes的基准设置</p>
<p>我们使用具有 14 个物理内核的现代 Intel core-i9 机器来作为负载生成器和运行应用程序和跟踪器运行时的测试主机。当发出请求时，确保该机器处于足够的负载下以使CPU跑满。</p>
<p>我们通过修改  <a href="https://github.com/pixie-io/pixie-demos/blob/main/simple-gotracing/app/app.go">app.go</a>  中的 <code>computeE</code> 函数的 <code>iterations</code> 参数来捕获不同持续时间的HTTP请求。 这是一个相对CPU密集型的工作负载，因为每次调用 HTTP 都会导致循环运行一定次数的迭代。 将请求吞吐量和延迟上产生的开销与基准请求的中位数延迟进行归一化，并绘制出结果。</p>
<p><img src="https://blog.px.dev/static/51a7ce1c48fc2d77409d32b85f40c81c/latency-benchmark.png" alt="img">
<img src="https://blog.px.dev/static/a7302008b2192d333a4110de4b50a2e3/throughput-benchmark.png" alt="img"></p>
<p>从结果可以看出，如果HTTP延迟&gt; 1ms，则引入的开销可以忽略不计，在大多数情况下可以认为是噪音。这对于Kprobes和Uprobes也是类似的，其中Kprobes表现略好（即使我们重新解析所有数据）。请注意，开销偶尔为负&ndash;这很可能只是测量中的噪声。关键要点在于，如果您的HTTP处理程序正在执行任何实际工作（约1ms计算），则引入的开销基本上可以忽略不计。</p>
<h2 id="结论">结论</h2>
<p><img src="https://blog.px.dev/static/be0084b520de650961ef1256df049cb0/ebpf-http-tracing.gif" alt="img"></p>
<p>图4: 运行演示</p>
<p>使用eBPF跟踪HTTP请求可以使用kprobes和uprobes两种方法；但是，kprobe方法更具可扩展性，因为它与目标语言无关。本篇文章中使用的代码可在 <a href="https://github.com/pixie-io/pixie-demos/tree/main/simple-gotracing">此处</a> 获得，其可以正常跟踪Go/Python应用程序。应用程序适配整个内核API做到健壮而功能齐全可能需要大量工作，一些编程语言使用不同的底层系统调用，例如 writev，或者请求被过度拆分而调用了多个系统调用</p>

  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/ebpf/" class="tag-link">EBPF</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/linux/" class="tag-link">Linux</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/kernel/" class="tag-link">Kernel</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/tracing/" class="tag-link">Tracing</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/debug/" class="tag-link">Debug</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/go/" class="tag-link">Go</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E7%BF%BB%E8%AF%91/" class="tag-link">翻译</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
