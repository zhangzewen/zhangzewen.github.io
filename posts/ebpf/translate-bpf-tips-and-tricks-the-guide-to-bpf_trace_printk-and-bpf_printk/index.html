<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.0">

  <title>[译]BPF tips &amp; tricks: the guide to bpf_trace_printk() and bpf_printk() &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="[译]BPF tips & tricks: the guide to bpf_trace_printk() and bpf_printk()">
  <meta itemprop="description" content="介于能力有限，翻译有不当之处，不吝赐教 原文: BPF tips &amp; tricks: the guide to bpf_trace_printk() and bpf_printk()">
  <meta itemprop="datePublished" content="2024-05-17T08:13:34+08:00">
  <meta itemprop="dateModified" content="2024-05-17T08:13:34+08:00">
  <meta itemprop="wordCount" content="923">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="EBPF,Linux,Kernel,翻译">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="[译]BPF tips & tricks: the guide to bpf_trace_printk() and bpf_printk()">
  <meta name="twitter:description" content="介于能力有限，翻译有不当之处，不吝赐教 原文: BPF tips &amp; tricks: the guide to bpf_trace_printk() and bpf_printk()">


<meta property="og:url" content="https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="[译]BPF tips & tricks: the guide to bpf_trace_printk() and bpf_printk()">
  <meta property="og:description" content="介于能力有限，翻译有不当之处，不吝赐教 原文: BPF tips &amp; tricks: the guide to bpf_trace_printk() and bpf_printk()">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-17T08:13:34+08:00">
    <meta property="article:modified_time" content="2024-05-17T08:13:34+08:00">
    <meta property="article:tag" content="EBPF">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Kernel">
    <meta property="article:tag" content="翻译">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/#webpage",
      "url": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/",
      "name": "[译]BPF tips \u0026 tricks: the guide to bpf_trace_printk() and bpf_printk()",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2024-05-17T08:13:34+08:00",
      "dateModified": "2024-05-17T08:13:34+08:00",
      "description": "\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e介于能力有限，翻译有不当之处，不吝赐教\u003c/strong\u003e\u003c/em\u003e\n原文: \u003cstrong\u003e\u003ca href=\"https://nakryiko.com/posts/bpf-tips-printk/\"\u003eBPF tips \u0026amp; tricks: the guide to bpf_trace_printk() and bpf_printk()\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/#webpage"
      },
      "headline": "[译]BPF tips \u0026 tricks: the guide to bpf_trace_printk() and bpf_printk()",
      "datePublished": "2024-05-17T08:13:34+08:00",
      "dateModified": "2024-05-17T08:13:34+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "EBPF",
        "Linux",
        "Kernel",
        "翻译"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/ebpf/translate-bpf-tips-and-tricks-the-guide-to-bpf_trace_printk-and-bpf_printk/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#bpf_trace_printk介绍"><code>bpf_trace_printk()</code>介绍</a></li>
    <li><a href="#调优bpf_printk">调优<code>bpf_printk()</code></a>
      <ul>
        <li><a href="#避免在栈上使用格式化字符串数组">避免在栈上使用格式化字符串数组</a></li>
        <li><a href="#换行行为的变化">换行行为的变化</a></li>
        <li><a href="#检测功能完善的-bpf_trace_printk">检测功能完善的 <code>bpf_trace_printk()</code></a></li>
      </ul>
    </li>
    <li><a href="#结论">结论</a></li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">[译]BPF tips &amp; tricks: the guide to bpf_trace_printk() and bpf_printk()</h1>
  
  

  <div class="post-date">
    <time datetime=" 2024-05-17T08:13:34&#43;0800">Created: May 17, 2024</time>
    <span class="readtime">&middot; 5 min read</span>
  </div>

  <div>
    <blockquote>
<p><em><strong>介于能力有限，翻译有不当之处，不吝赐教</strong></em>
原文: <strong><a href="https://nakryiko.com/posts/bpf-tips-printk/">BPF tips &amp; tricks: the guide to bpf_trace_printk() and bpf_printk()</a></strong></p></blockquote>
<p>任何BPF 程序总是需要一定量的调试才能正常工作。不幸的是，现在还没有 BPF 调试器，所以最好的方法是在程序代码中敲入类似于 <code>printf()</code> 的语句，以查看 BPF 程序的运行状况。BPF 中的<code>printf()</code> 是 <code>bpf_trace_printk()</code> 帮助程序。在这篇博客文章中，我们将研究如何使用它，它的局限性是什么，以及如何绕过这些局限性。我还会描述在最近几个内核版本中<code>bpf_trace_printk()</code>  发生的一些重要变化，以及如何使用 <a href="https://nakryiko.com/posts/bpf-portability-and-co-re/">BPF CO-RE</a>  来检测和处理这些变化。</p>
<h1 id="前言">前言</h1>
<p>我将使用 <a href="https://github.com/libbpf/libbpf-bootstrap">libbpf-bootstrap</a> 中的简单示例作为所有示例的基础。它已经全部配置好，并运行一个简单的 BPF 程序，我们将用它来测试<code>bpf_trace_printk()</code>  的输出。如果你想跟着示例动手操作，请确保克隆  <a href="https://github.com/libbpf/libbpf-bootstrap">libbpf-bootstrap</a>  并在你的编辑器中打开 <a href="https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/minimal.bpf.c">minimap.bpf.c</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> $ <span style="color:#928374;font-style:italic"># note --recursive to checkout libbpf submodule</span>
</span></span><span style="display:flex;"><span> $ git clone --recursive https://github.com/libbpf/libbpf-bootstrap
</span></span><span style="display:flex;"><span> $ <span style="color:#fabd2f">cd</span> libbpf-bootstrap/examples/c
</span></span><span style="display:flex;"><span> $ vim minimal.bpf.c
</span></span><span style="display:flex;"><span> $ make minimal
</span></span><span style="display:flex;"><span> $ sudo ./minimal
</span></span></code></pre></div><h1 id="bpf_trace_printk介绍"><code>bpf_trace_printk()</code>介绍</h1>
<p>Linux 内核提供了 BPF 帮助函数 <code>bpf_trace_printk()</code>，其定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#fabd2f">long</span> <span style="color:#fabd2f">bpf_trace_printk</span>(<span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>fmt, __u32 fmt_size, ...);
</span></span></code></pre></div><p>它的第一个参数 <code>fmt</code> 是指向与 <code>printf</code> 兼容的格式化字符串的指针（带有一些内核特定的扩展和限制）。<code>fmt_size</code> 是该字符串的大小，包括终止符 <code>\0</code>。varargs 是格式化字符串中引用的参数。</p>
<p><code>bpf_trace_printk()</code> 支持 libc 实现的<code>printf()</code> 的有限子集。基本的如 <code>%s</code>、<code>%d</code> 和 <code>%c</code> 是可以的，但是，位置参数（<code>%1$s</code>）是不支持的。参数宽度说明符（<code>%10d</code>、<code>%-20s</code> 等）只在非常新的内核上工作，在早期的内核上不工作。此外，还支持一系列内核特定的修饰符（如 <code>%pi6</code> 用于打印 IPv6 地址或 <code>%pks</code> 用于内核字符串）。</p>
<p>如果格式字符串无效或使用了不受支持的功能，<code>bpf_trace_printk()</code> 将返回负错误码。</p>
<p>不幸的是， <code>bpf_trace_printk()</code>的使用还有一些更重要的限制。</p>
<p>首先，使用<code>bpf_trace_printk()</code>  的 BPF 程序必须具有与 GPL 兼容的许可证。对于基于  <a href="https://github.com/libbpf/libbpf">libbpf</a> 的 BPF 应用程序，这意味着要使用一个特殊变量来指定许可证：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fabd2f">char</span> LICENSE[] <span style="color:#fabd2f">SEC</span>(<span style="color:#b8bb26">&#34;license&#34;</span>) <span style="color:#fe8019">=</span> <span style="color:#b8bb26">&#34;GPL&#34;</span>;
</span></span></code></pre></div><p>为了完整性，请提供内核认可的所有与 <a href="https://github.com/torvalds/linux/blob/master/include/linux/license.h">GPL 兼容的许可证</a>:</p>
<ul>
<li>&ldquo;GPL&rdquo;;</li>
<li>&ldquo;GPL v2&rdquo;;</li>
<li>&ldquo;GPL and additional rights&rdquo;;</li>
<li>&ldquo;Dual BSD/GPL&rdquo;;</li>
<li>&ldquo;Dual MIT/GPL&rdquo;;</li>
<li>&ldquo;Dual MPL/GPL&rdquo;.</li>
</ul>
<p>另一个严格的限制是 <code>bpf_trace_printk()</code> 最多只能接受3个输入参数（除了 <code>fmt</code> 和 <code>fmt_size</code>）。这通常是非常有限的，你可能需要多次使用 <code>bpf_trace_printk()</code> 调用来记录所有数据。这种限制源于 BPF 帮助函数最多只能接受5个输入参数的能力。</p>
<p>然而，一旦你克服了这些限制，你会发现 <code>bpf_trace_printk()</code> 根据你的格式化字符串忠实地将数据发送到 <code>/sys/kernel/debug/tracing/trace_pipe</code> 的特殊文件。你需要以 root 身份读取它，所以使用 sudo cat 来查看你的调试日志：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sudo cat  /sys/kernel/debug/tracing/trace_pipe
</span></span><span style="display:flex;"><span> &lt;...&gt;-2328034 <span style="color:#fe8019">[</span>007<span style="color:#fe8019">]</span> d... 5344927.816042: bpf_trace_printk: Hello, world, from BPF! My PID is <span style="color:#d3869b">2328034</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> &lt;...&gt;-2328034 <span style="color:#fe8019">[</span>007<span style="color:#fe8019">]</span> d... 5344928.816147: bpf_trace_printk: Hello, world, from BPF! My PID is <span style="color:#d3869b">2328034</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>^C
</span></span></code></pre></div><p>让我们解剖一下这个：<code>&lt;...&gt;-2328034 [007] d... 5344927.816042: bpf_trace_printk:</code> 该部分由内核每次进行 <code>bpf_trace_printk()</code> 调用自动发出。它包含了像进程名称（有时缩写为 <code>&lt;...&gt;</code>）、PID（2328034）、系统启动后的时间戳（<code>5344927.816042</code>）等信息。但是 <code>Hello, world, from BPF! My PID is 2328034</code> 是由 BPF 程序控制并通过如下简单的代码发出：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fabd2f">int</span> pid <span style="color:#fe8019">=</span> <span style="color:#fabd2f">bpf_get_current_pid_tgid</span>() <span style="color:#fe8019">&gt;&gt;</span> <span style="color:#d3869b">32</span>;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> fmt_str[] <span style="color:#fe8019">=</span> <span style="color:#b8bb26">&#34;Hello, world, from BPF! My PID is %d</span><span style="color:#b8bb26">\n</span><span style="color:#b8bb26">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">bpf_trace_printk</span>(fmt_str, <span style="color:#fe8019">sizeof</span>(fmt_str), pid);
</span></span></code></pre></div><p>注意 <code>fmt_str</code> 是如何定义为栈上的变量。不幸的是，由于 libbpf 的限制，你目前不能直接执行类似 <code>bpf_trace_printk(&quot;Hello, world!&quot;, ...);</code> 的操作。但即使这是可能的，需要显示地指定 <code>fmt_size</code> 也相当不便。但是，Libbpf 提供了一个简单的包装宏，<code>bpf_printk(fmt, ...)</code>，它负责处理这些细节。它目前在  <a href="https://github.com/libbpf/libbpf/blob/master/src/bpf_helpers.h">&lt;bpf/bpf_helpers.h&gt;</a> 中的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* Helper macro to print out debug messages */</span>
</span></span><span style="display:flex;"><span><span style="color:#8ec07c">#define bpf_printk(fmt, ...)                            \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">({                                                      \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">      char ____fmt[] = fmt;                           \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">      bpf_trace_printk(____fmt, sizeof(____fmt),      \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">                       ##__VA_ARGS__);                \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">})
</span></span></span></code></pre></div><p>有了它，上面的 &ldquo;Hello, world!&rdquo; 示例变得更为简洁和方便：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fabd2f">int</span> pid <span style="color:#fe8019">=</span> <span style="color:#fabd2f">bpf_get_current_pid_tgid</span>() <span style="color:#fe8019">&gt;&gt;</span> <span style="color:#d3869b">32</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">bpf_printk</span>(<span style="color:#b8bb26">&#34;Hello, world, from BPF! My PID is %d</span><span style="color:#b8bb26">\n</span><span style="color:#b8bb26">&#34;</span>, pid);
</span></span></code></pre></div><p>好多了！不幸的是，虽然方便，但这种实现并不理想，因为它必须在每次调用<code>bpf_printk()</code>  时都要使用格式化字符串来在栈上初始化一个 char 数组。由于对向后兼容性的考虑，libbpf 被困在这样一个次优的实现中，因为这是唯一一个可以在旧的内核上可靠工作的实现，因此不会破坏任何 BPF 应用程序，这对于 libbpf 这样的通用库来说是非常重要的。</p>
<p>另一方面，我在这篇博客文章中并不受向后兼容性的限制。所以我可以而且将在这篇文章的其余部分展示如何显著改进这种实现。</p>
<h1 id="调优bpf_printk">调优<code>bpf_printk()</code></h1>
<h2 id="避免在栈上使用格式化字符串数组">避免在栈上使用格式化字符串数组</h2>
<p>首先，我们要解决的是在栈上为格式化字符串初始化数组的需求。从 Linux 5.2 开始， <a href="https://github.com/torvalds/linux/commit/d8eca5bbb2be9">d8eca5bbb2be (&ldquo;bpf: implement lookup-free direct value access for maps&rdquo;)</a> 添加了对 BPF 全局（和静态）变量的支持，我们将在这里使用它来摆脱栈上的数组。对 <code>bpf_printk()</code> 实现的更改是欺骗性的最小化：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8ec07c">#undef bpf_printk
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">#define bpf_printk(fmt, ...)                            \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">({                                                      \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">      static const char ____fmt[] = fmt;              \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">      bpf_trace_printk(____fmt, sizeof(____fmt),      \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">                       ##__VA_ARGS__);                \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">})
</span></span></span></code></pre></div><p><code>char[]</code> 变为 <code>static const char[]</code>。<code>static const</code> 修饰符确保 Clang 将<code>____fmt</code>  变量放入只读的 <code>.rodata ELF</code> 部分，libbpf 将在 BPF 应用程序加载时负责链接所有内容。当 <code>bpf_printk()</code> 需要打印某些内容时，底层的 BPF 代码只需获取 <code>.rodata</code> 中BPF 映射中的<code>____fmt</code>  地址。与每次填充一个可能很大的 char 数组相比，这是快速和高效的。</p>
<p>简而言之，如果你的 BPF 应用程序在 Linux 5.2（或更新版本）上运行，你应该始终优先选择这种实现而不是 libbpf 中的实现。</p>
<h2 id="换行行为的变化">换行行为的变化</h2>
<p>在 Linux 5.9 之前，<code>bpf_trace_printk()</code> 会使用格式化字符串并原样使用他们。所以，如果你忘记（或选择不）在格式字符串中添加 <code>\n</code>，你会在 <code>trace_pipe</code> 中得到混乱的输出。多次执行 <code>bpf_printk(&quot;Hello, world!&quot;)</code> 会导致：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&lt;...&gt;-179528 <span style="color:#fe8019">[</span>065<span style="color:#fe8019">]</span> .... 1863682.484368: 0: Hello, world!           &lt;...&gt;-179528 <span style="color:#fe8019">[</span>065<span style="color:#fe8019">]</span> .... 1863682.484381: 0: Hello, world!           &lt;...&gt;-179528 <span style="color:#fe8019">[</span>065<span style="color:#fe8019">]</span> .... 1863683.484447: 0: Hello, world!
</span></span></code></pre></div><p>从 <a href="https://github.com/torvalds/linux/commit/ac5a72ea5c898">ac5a72ea5c89 (&ldquo;bpf: Use dedicated bpf_trace_printk event instead of trace_printk()&rdquo;)</a> 开始（并入上游 Linux 5.9），<code>bpf_trace_printk()</code> 现在总是在末尾添加换行符，所以对于<code>bpf_printk(&quot;Hello, world!&quot;)，</code> 你会看到一个整洁的输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&lt;...&gt;-200501 <span style="color:#fe8019">[</span>001<span style="color:#fe8019">]</span> .... 1863840.478848: 0: Hello, world!
</span></span><span style="display:flex;"><span> &lt;...&gt;-200501 <span style="color:#fe8019">[</span>002<span style="color:#fe8019">]</span> .... 1863841.478916: 0: Hello, world!
</span></span><span style="display:flex;"><span> &lt;...&gt;-200501 <span style="color:#fe8019">[</span>002<span style="color:#fe8019">]</span> .... 1863842.478991: 0: Hello, world!
</span></span></code></pre></div><p>这很好，但是如果你之前很小心（你应该小心）并在格式化字符串的末尾添加了<code>\n</code> ，那么在 Linux 5.9 之前的内核上，<code>bpf_printk(&quot;Hello, world!\n&quot;)</code> 会产生一个像上面那样漂亮的输出。但从 Linux 5.9 开始，你会得到一个令人烦恼的输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&lt;...&gt;-3658431 <span style="color:#fe8019">[</span>048<span style="color:#fe8019">]</span> d... 5362570.510814: bpf_trace_printk: Hello, world!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> &lt;...&gt;-3658431 <span style="color:#fe8019">[</span>048<span style="color:#fe8019">]</span> d... 5362571.510933: bpf_trace_printk: Hello, world!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> &lt;...&gt;-3658431 <span style="color:#fe8019">[</span>048<span style="color:#fe8019">]</span> d... 5362572.511048: bpf_trace_printk: Hello, world!
</span></span></code></pre></div><p>虽然这不是世界末日，但是如果在处理那个麻烦的 \n 时保持一致的行为并且不用关心内核版本差异，那不是很好吗？</p>
<p>好消息是，借助 BPF CO-RE，我们可以透明地检测并适应这种内核差异。如果你查看上面提到的  <a href="https://github.com/torvalds/linux/commit/ac5a72ea5c898">ac5a72ea5c89</a> 提交，你会看到它添加了一个新的内核 tracepoint <code>bpf_trace_printk</code>，并巧妙地使用它将数据发射到 <code>/sys/kernel/debug/tracing/trace_pipe</code>。还要注意，内核中的每个 tracepoint 都有一个对应的 <code>struct trace_event_raw_&lt;tracepointname&gt;</code> 类型。我们将使用 <code>struct trace_event_raw_bpf_trace_printk</code> 的存在来检测<code>bpf_trace_printk()</code>  是否添加了换行符。如果没有，我们将确保在我们自己的 <code>bpf_printk()</code> 宏中默默地并透明地添加一个换行符。让我们看看这是如何组合在一起的：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#d3869b">1</span>] #include <span style="color:#fe8019">&lt;</span>bpf<span style="color:#fe8019">/</span>bpf_core_read.h<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#928374;font-style:italic">/* define our own struct definition if our vmlinux.h is outdated */</span>
</span></span><span style="display:flex;"><span>[<span style="color:#d3869b">2</span>] <span style="color:#fe8019">struct</span> trace_event_raw_bpf_trace_printk___x {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8ec07c">#undef bpf_printk
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c"></span>  <span style="color:#8ec07c">#define bpf_printk(fmt, ...)                                                    \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">  ({                                                                              \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">[3]         static char ____fmt[] = fmt &#34;\0&#34;;                                       \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">[4]         if (bpf_core_type_exists(struct trace_event_raw_bpf_trace_printk___x)) {\
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">[5]                 bpf_trace_printk(____fmt, sizeof(____fmt) - 1, ##__VA_ARGS__);  \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">          } else {                                                                \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">[6]                 ____fmt[sizeof(____fmt) - 2] = &#39;\n&#39;;                            \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">[7]                 bpf_trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__);      \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">          }                                                                       \
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">   })
</span></span></span></code></pre></div><p>让我们稍微拆解一下代码。</p>
<ul>
<li>[1] 包括 libbpf 的 <a href="https://github.com/libbpf/libbpf/blob/master/src/bpf_core_read.h">bpf_core_read.h</a>头文件，其中定义了所有 BPF CO-RE 宏。</li>
<li>[2] 定义了我们自己的本地最小（空）定义的 <code>bpf_trace_printk</code> tracepoint 结构，以避免依赖于最新的 <code>vmlinux.h</code>。这对于Linux 5.9 之前的内核 BTF 生成的<code>vmlinux.h</code>可能稍微过时的场景下很重要。添加 <code>___x</code> 后缀确保它不会与最新的 vmlinux.h 中的定义冲突。Libbpf 和 BPF CO-RE 会忽略 ___ 和其后的所有内容，所以这仍然会匹配内核中的实际的 <code>struct trace_event_raw_bpf_trace_printk</code>。如果您确定您的 <code>vmlinux.h</code> 足够新，您可以跳过此步骤。</li>
<li>[3] 有两个更改。我们删除了 const 修饰符，因为我们打算在运行时修改此字符串（在旧内核上），所以它必须在可写的<code>.data</code>  ELF 部分和相应的 BPF 映射中分配。我们还在末尾追加了额外的 <code>\0</code>，以预留空间供<code>\n</code>  字符使用，如果我们恰好需要它。在运行时替换现有字符比追加一个更简单，所以这就是我们在这里要做的。</li>
<li>[4] 是基于 BPF CO-RE 的 tracepoint 存在检测。如果指定的结构<code>bpf_core_type_exists() </code>在内核中存在，评估为 1，否则替换为 0。</li>
<li>[5] 是 Linux 5.9+ 的情况，所以我们不需要添加换行符。我们应该小心的唯一一件事是不要在格式字符串中传递两个<code>\0</code> ，因为某些内核会在运行时拒绝这个（你在 trace_pipe 文件中看不到任何输出）。这就是为什么指定格式字符串的大小为<code>sizeof(____fmt) - 1</code> ，跳过编译器在分配字符串时添加的隐式<code>\0</code> 。</li>
<li>[6]-[7] 是较旧 Linux 的情况，所以我们必须将显示保留的<code>\0</code>  替换为<code>\n</code> ，以确保我们将获得适当的包装输出。我们传递完整的<code>____fmt</code>  大小传递给 <code>bpf_trace_printk()</code>，包括隐式的 <code>\0</code>。</li>
</ul>
<p>有了这个，<code>bpf_printk(&quot;Hello, world!&quot;)</code> 始终会在末尾发出一个换行符，而调用者不必关心内核版本。你只需要确保格式化字符串不以<code>\n</code>结束。</p>
<h2 id="检测功能完善的-bpf_trace_printk">检测功能完善的 <code>bpf_trace_printk()</code></h2>
<p>在即将到来的 Linux 5.13 版本中，由于 <a href="http://florentrevest.github.io/">Florent Revest</a>在 <a href="https://github.com/torvalds/linux/commit/d9c9e4db186ab">d9c9e4db186a (&ldquo;bpf: Factorize bpf_trace_printk and bpf_seq_printf&rdquo;)</a> 中的工作，<code>bpf_trace_printk()</code> 的实现得到了非常好的能力提升。</p>
<p>以前，<code>bpf_trace_printk()</code> 只允许使用一个字符串 (<code>%s</code>) 参数，这是相当受限的。Linux 5.13 版本取消了此限制，并允许多个字符串参数，只要总格式化输出不超过512字节。另一个烦人的限制是不支持宽度说明符，如<code>%10d</code>  或<code>%-20s</code> 。这个限制现在也消失了。以下是其他一些出色的改进（摘自上述提交的描述）：</p>
<ul>
<li>bpf_trace_printk 总是预期 fmt[fmt_size] 是终止 NULL 字符，这已不再成立，第一个 0 是终止的。</li>
<li>bpf_trace_printk 现在支持 %%（产生百分比字符）。</li>
<li>bpf_trace_printk 现在跳过宽度格式化字段。</li>
<li>bpf_trace_printk 现在支持 X 修饰符（大写十六进制）。</li>
<li>bpf_trace_printk 现在支持 %pK, %px, %pB, %pi4, %pI4, %pi6 和 %pI6</li>
<li>bpf_trace_printk 现在支持 %ps 和 %pS 说明符来打印符号。</li>
</ul>
<p>这意味着在足够新的内核上，你可以用 <code>bpf_trace_printk()</code> 做更多的事情。但是，如果您想支持较旧的内核，您将需要回退到更简单的逻辑。问题是是否可以可靠地检测是否可以期望更强大的 <code>bpf_trace_printk()</code> 行为。</p>
<p>BPF CO-RE 和 libbpf 实际上可以很好地帮助这一点。一种方法是通过使用 <code>extern int LINUX_KERNEL_VERSION __kconfig</code>; 变量显式地检查上游 Linux 版本，但这在 Linux 内核存在向后移植的情况下并不非常可靠。对于这样的向后移植功能，Linux 内核版本和内核中包含的功能不对应。因此，最好直接检测所需功能的支持。</p>
<p>碰巧的是，<code>bpf_trace_printk()</code> 重构与添加新的 BPF 帮助程序 <code>bpf_snprintf()</code> 重合，这些重构和改进是首先完成的。所以，我们将检测 <code>bpf_snprintf()</code> 帮助程序的支持，而不是依赖内核版本检查。</p>
<p>每个 BPF 帮助程序都有一个相应的 <code>BPF_FUNC_&lt;helpername&gt;</code> 枚举值存放在 <a href="https://github.com/torvalds/linux/blob/ad9f25d338605d26acedcaf3ba5fab5ca26f1c10/include/uapi/linux/bpf.h#L4911-L4916">enum bpf_func_id</a> 中。因此，通过检查给定的枚举值是否存在于 vmlinux BTF 中，可以确定相应的 BPF 帮助程序是否存在。让我们看看如何在代码中做到这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* don&#39;t rely on up-to-date vmlinux.h */</span>
</span></span><span style="display:flex;"><span>[<span style="color:#d3869b">1</span>] <span style="color:#fe8019">enum</span> bpf_func_id___x { BPF_FUNC_snprintf___x <span style="color:#fe8019">=</span> <span style="color:#d3869b">42</span> <span style="color:#928374;font-style:italic">/* avoid zero */</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#d3869b">2</span>] #define printk_is_powerful  \
</span></span><span style="display:flex;"><span>          (<span style="color:#fabd2f">bpf_core_enum_value_exists</span>(<span style="color:#fe8019">enum</span> bpf_func_id___x, BPF_FUNC_snprintf___x))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> power[] <span style="color:#fe8019">=</span> <span style="color:#b8bb26">&#34;POWER&#34;</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#fabd2f">int</span> pid <span style="color:#fe8019">=</span> <span style="color:#fabd2f">bpf_get_current_pid_tgid</span>() <span style="color:#fe8019">&gt;&gt;</span> <span style="color:#d3869b">32</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#fe8019">if</span> (printk_is_powerful)
</span></span><span style="display:flex;"><span>[<span style="color:#d3869b">4</span>]                 <span style="color:#fabd2f">bpf_printk</span>(<span style="color:#b8bb26">&#34;I&#39;ve got the =%%= %7s, %s, %-7s =%%=!&#34;</span>, power, power, power);
</span></span><span style="display:flex;"><span>          <span style="color:#fe8019">else</span>
</span></span><span style="display:flex;"><span>[<span style="color:#d3869b">5</span>]                 <span style="color:#fabd2f">bpf_printk</span>(<span style="color:#b8bb26">&#34;Sorry, NO %s! :( But my PID is %d&#34;</span>, power, pid);
</span></span></code></pre></div><p>[1] 定义了我们自己的枚举<code>bpf_func_id</code> 和 <code>BPF_FUNC_snprintf</code> 枚举值的最小定义。这同样是为了避免依赖于拥有最新版本的 <code>vmlinux.h</code>，所以你不关心这些，请随意跳过。注意 枚举 和 枚举值都使用了<code>___x</code>  后缀，在两种情况下，libbpf 都会忽略 <code>___x</code> 后缀。实际的值42也无关紧要，但最好避免使用零（默认值，除非明确指定），因为某些旧版本的Clang存在问题。</p>
<p>[2] 使用 <code>bpf_core_enum_value_exists()</code> 来检测正在运行的内核中 <code>BPF_FUNC_snprintf</code> 枚举值的存在。它类似于之前使用的 <code>bpf_core_type_exists()</code>，但适用于枚举。如果枚举值存在，它将评估为 1，否则将返回 0。</p>
<p>[4] 处理拥有更多功能丰富的 <code>bpf_trace_printk()</code> 实现的情况，并展示使用3个字符串参数和一些更花哨的格式化。另外，为了好玩，它使用了 <code>%%</code> 转义。</p>
<p>[5] 是使用更原始和受限的格式化的回退情况。</p>
<p>就是这样了。如果您正在 Linux 5.13+ 上运行，您应该会看到：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>minimal-2167    <span style="color:#fe8019">[</span>002<span style="color:#fe8019">]</span> d..5 20804.858999: bpf_trace_printk: I<span style="color:#b8bb26">&#39;ve got the =%=   POWER, POWER, POWER   =%=!
</span></span></span><span style="display:flex;"><span><span style="color:#b8bb26"> minimal-2167    [002] d..5 20805.859180: bpf_trace_printk: I&#39;</span>ve got the <span style="color:#fe8019">=</span>%<span style="color:#fe8019">=</span>   POWER, POWER, POWER   <span style="color:#fe8019">=</span>%<span style="color:#fe8019">=</span>!
</span></span></code></pre></div><p>在 Linux 5.13 之前的版本运行，您应该会看到：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&lt;...&gt;-3998551 <span style="color:#fe8019">[</span>008<span style="color:#fe8019">]</span> d... 5367146.858854: bpf_trace_printk: Sorry, NO POWER! :<span style="color:#fe8019">(</span> But my PID is <span style="color:#d3869b">3998551</span>
</span></span><span style="display:flex;"><span> &lt;...&gt;-3998551 <span style="color:#fe8019">[</span>008<span style="color:#fe8019">]</span> d... 5367147.858990: bpf_trace_printk: Sorry, NO POWER! :<span style="color:#fe8019">(</span> But my PID is <span style="color:#d3869b">3998551</span>
</span></span></code></pre></div><h1 id="结论">结论</h1>
<p><code>bpf_trace_printk()</code>（或者更实际地说，<code>bpf_printk()</code> 包装器）是一种非常有用的工具，极大地简化了调试 BPF 应用程序的工作。它允许您从 BPF 应用程序的 BPF 端导出大量有用的信息，并通过 <code>trace_pipe</code> 文件观察它。不幸的是，<code>bpf_trace_printk()</code> 的行为和功能的逐渐变化会带来不便，但希望这篇博客文章展示了如何通过仔细使用 BPF CO-RE 和其他 libbpf 功能（例如，BPF 静态变量）以合理的方式和足够的透明度将其抽象化。希望这些信息将为您节省未来的时间，并让您从 BPF 应用程序中获得更多的收益。</p>
<p><code>bpf_trace_printk()</code> 演化的逻辑是支持传入超过 3 个输入参数，类似于现代的 <code>printf()</code>之类的 BPF帮助函数，例如<code>bpf_seq_printf()</code> 和 <code>bpf_snprintf()</code> 。这无疑很快就会被添加，所以请关注 <a href="mailto:bpf@vger.kernel.org">bpf@vger.kernel.org</a> 邮件列表。</p>

  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/ebpf/" class="tag-link">EBPF</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/linux/" class="tag-link">Linux</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/kernel/" class="tag-link">Kernel</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E7%BF%BB%E8%AF%91/" class="tag-link">翻译</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
