<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.1">

  <title>[译]BPF CO-RE reference guide &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="[译]BPF CO-RE reference guide">
  <meta itemprop="description" content="介于能力有限，翻译有不当之处，不吝赐教
原文：BPF CO-RE reference guide
缺失的手册 BPF CO-RE（编译一次-到处运行）是编写可移植BPF应用程序的现代方法，应用程序可以在不同的内核版本和配置上运行，而无需在目标机器上修改和编译运行时源代码。这与BCC框架提供的更传统的方法有很大的区别，在BCC框架中，BPF应用程序源代码编译被延迟到目标主机上，其携带了一个重量级的编译器工具链来实现这一点。请阅读[译]BPF CO-RE (Compile Once – Run Everywhere)这篇文章，该文章介绍了 BPF CO-RE 的概念，并解释了为什么 BPF CO-RE对这些现实世界的 BPF 应用程序来说都是重要且必要的，以及在没有内核BTF的情况下变得困难的原因。">
  <meta itemprop="datePublished" content="2024-08-17T08:13:34+08:00">
  <meta itemprop="dateModified" content="2024-08-17T08:13:34+08:00">
  <meta itemprop="wordCount" content="1287">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="EBPF,Linux,翻译,Kernel">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="[译]BPF CO-RE reference guide">
  <meta name="twitter:description" content="介于能力有限，翻译有不当之处，不吝赐教
原文：BPF CO-RE reference guide
缺失的手册 BPF CO-RE（编译一次-到处运行）是编写可移植BPF应用程序的现代方法，应用程序可以在不同的内核版本和配置上运行，而无需在目标机器上修改和编译运行时源代码。这与BCC框架提供的更传统的方法有很大的区别，在BCC框架中，BPF应用程序源代码编译被延迟到目标主机上，其携带了一个重量级的编译器工具链来实现这一点。请阅读[译]BPF CO-RE (Compile Once – Run Everywhere)这篇文章，该文章介绍了 BPF CO-RE 的概念，并解释了为什么 BPF CO-RE对这些现实世界的 BPF 应用程序来说都是重要且必要的，以及在没有内核BTF的情况下变得困难的原因。">


<meta property="og:url" content="https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="[译]BPF CO-RE reference guide">
  <meta property="og:description" content="介于能力有限，翻译有不当之处，不吝赐教
原文：BPF CO-RE reference guide
缺失的手册 BPF CO-RE（编译一次-到处运行）是编写可移植BPF应用程序的现代方法，应用程序可以在不同的内核版本和配置上运行，而无需在目标机器上修改和编译运行时源代码。这与BCC框架提供的更传统的方法有很大的区别，在BCC框架中，BPF应用程序源代码编译被延迟到目标主机上，其携带了一个重量级的编译器工具链来实现这一点。请阅读[译]BPF CO-RE (Compile Once – Run Everywhere)这篇文章，该文章介绍了 BPF CO-RE 的概念，并解释了为什么 BPF CO-RE对这些现实世界的 BPF 应用程序来说都是重要且必要的，以及在没有内核BTF的情况下变得困难的原因。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-17T08:13:34+08:00">
    <meta property="article:modified_time" content="2024-08-17T08:13:34+08:00">
    <meta property="article:tag" content="EBPF">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="翻译">
    <meta property="article:tag" content="Kernel">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/#webpage",
      "url": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/",
      "name": "[译]BPF CO-RE reference guide",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2024-08-17T08:13:34+08:00",
      "dateModified": "2024-08-17T08:13:34+08:00",
      "description": "\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e介于能力有限，翻译有不当之处，不吝赐教\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e原文：\u003ca href=\"https://nakryiko.com/posts/bpf-core-reference-guide/\"\u003eBPF CO-RE reference guide\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"缺失的手册\"\u003e缺失的手册\u003c/h2\u003e\n\u003cp\u003eBPF CO-RE（编译一次-到处运行）是编写可移植BPF应用程序的现代方法，应用程序可以在不同的内核版本和配置上运行，而无需在目标机器上修改和编译运行时源代码。这与\u003ca href=\"https://github.com/iovisor/bcc\"\u003eBCC\u003c/a\u003e框架提供的更传统的方法有很大的区别，在BCC框架中，BPF应用程序源代码编译被延迟到目标主机上，其携带了一个重量级的编译器工具链来实现这一点。请阅读\u003ca href=\"https://www.zhangzewen.net/posts/ebpf/translate-bpf-portability-and-co-re/\"\u003e[译]BPF CO-RE (Compile Once – Run Everywhere)\u003c/a\u003e这篇文章，该文章介绍了 BPF CO-RE 的概念，并解释了为什么 BPF CO-RE对这些现实世界的 BPF 应用程序来说都是重要且必要的，以及在没有\u003ca href=\"https://nakryiko.com/posts/btf-dedup/\"\u003e内核BTF\u003c/a\u003e的情况下变得困难的原因。\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/#webpage"
      },
      "headline": "[译]BPF CO-RE reference guide",
      "datePublished": "2024-08-17T08:13:34+08:00",
      "dateModified": "2024-08-17T08:13:34+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "EBPF",
        "Linux",
        "翻译",
        "Kernel"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/ebpf/translate-bpf-co-re-reference-guide/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#缺失的手册">缺失的手册</a>
          <ul>
            <li><a href="#读取内核数据">读取内核数据</a></li>
            <li><a href="#bpf_core_read">bpf_core_read()</a></li>
            <li><a href="#bpf_core_read_str">bpf_core_read_str()</a></li>
            <li><a href="#bpf_core_read-1">BPF_CORE_READ()</a></li>
            <li><a href="#bpf_core_read_into">BPF_CORE_READ_INTO()</a></li>
            <li><a href="#bpf_core_read_str_into">BPF_CORE_READ_STR_INTO()</a></li>
            <li><a href="#btf-enabled-bpf-program-types-with-direct-memory-reads">BTF-enabled BPF program types with direct memory reads</a></li>
            <li><a href="#读取位域和不同字节长度的整数">读取位域和不同字节长度的整数</a></li>
            <li><a href="#sizing-kernel-types-and-fields">Sizing kernel types and fields</a></li>
          </ul>
        </li>
        <li><a href="#处理内核变更和特性检测">处理内核变更和特性检测</a>
          <ul>
            <li><a href="#bpf_core_field_exists">bpf_core_field_exists()</a></li>
            <li><a href="#bpf_core_type_exists">bpf_core_type_exists()</a></li>
            <li><a href="#bpf_core_enum_value_exists">bpf_core_enum_value_exists()</a></li>
            <li><a href="#linux_kernel_version">LINUX_KERNEL_VERSION</a></li>
            <li><a href="#kconfig-extern-variables">Kconfig extern variables</a></li>
            <li><a href="#可重定位枚举">可重定位枚举</a></li>
            <li><a href="#guarding-potentially-failing-relocations">Guarding potentially failing relocations</a></li>
          </ul>
        </li>
        <li><a href="#advanced-topics">Advanced topics</a>
          <ul>
            <li><a href="#自定义-co-re-可重定位数据类型">自定义 CO-RE 可重定位数据类型</a></li>
            <li><a href="#处理不兼容的字段和数据类型更改">处理不兼容的字段和数据类型更改</a></li>
            <li><a href="#从用户态内存中读取内核数据结构">从用户态内存中读取内核数据结构</a></li>
            <li><a href="#capturing-btf-type-ids">Capturing BTF type IDs</a></li>
          </ul>
        </li>
        <li><a href="#结束语">结束语</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">[译]BPF CO-RE reference guide</h1>
  
  

  <div class="post-date">
    <time datetime=" 2024-08-17T08:13:34&#43;0800">Created: Aug 17, 2024</time>
    <span class="readtime">&middot; 7 min read</span>
  </div>

  <div>
    <blockquote>
<p><em><strong>介于能力有限，翻译有不当之处，不吝赐教</strong></em></p>
<p>原文：<a href="https://nakryiko.com/posts/bpf-core-reference-guide/">BPF CO-RE reference guide</a></p></blockquote>
<h2 id="缺失的手册">缺失的手册</h2>
<p>BPF CO-RE（编译一次-到处运行）是编写可移植BPF应用程序的现代方法，应用程序可以在不同的内核版本和配置上运行，而无需在目标机器上修改和编译运行时源代码。这与<a href="https://github.com/iovisor/bcc">BCC</a>框架提供的更传统的方法有很大的区别，在BCC框架中，BPF应用程序源代码编译被延迟到目标主机上，其携带了一个重量级的编译器工具链来实现这一点。请阅读<a href="https://www.zhangzewen.net/posts/ebpf/translate-bpf-portability-and-co-re/">[译]BPF CO-RE (Compile Once – Run Everywhere)</a>这篇文章，该文章介绍了 BPF CO-RE 的概念，并解释了为什么 BPF CO-RE对这些现实世界的 BPF 应用程序来说都是重要且必要的，以及在没有<a href="https://nakryiko.com/posts/btf-dedup/">内核BTF</a>的情况下变得困难的原因。</p>
<p>随着BPF CO-RE作为一种方法越来越成熟，关于其所有功能以及如何在实践中使用它们的一些实用指南严重缺失。在这篇博文中，我将尝试填补这一空白，并将介绍 BPF CO-RE（以及作为它的规范实现 <a href="https://github.com/libbpf/libbpf">libbpf</a> ）提供的所有不同功能。如果您以前编写过 BPF CO-RE 应用程序，那么您很可能至少使用过一些描述的功能。但不幸的是，其中一些仍然鲜为人知。然而，这些鲜为人知的 BPF CO-RE 秘密恰恰是有时使现实世界的 BPF 应用程序变得可行、简单、易于实现和支持的原因，避免了在主机上编译或预编译同一 BPF 应用程序的多个变体（风格）的复杂性应用程序，且每个变体针对不同的内核。</p>
<p>这篇文章很长，但它也旨在成为一种参考指南，因此与将其拆解成多篇文章并在几周内逐渐发布相比，将其作为一个整体发布感觉更好。它分为三个部分，从最常用的功能开始，然后是更高级且不太经常需要的功能，希望这个过程满足你编写BPF CO-RE应用程序循序渐进的需求。</p>
<p>在本文中，我将假定您正在使用<code>vmlinux.h</code>，它为内核提供了CO-RE可重定位的类型定义，并且可以通过<code>bpftool</code>工具生成。如果您不熟悉<code>vmlinux.h</code>，请参阅<a href="https://www.zhangzewen.net/posts/ebpf/translate-building-bpf-applications-with-libbpf-bootstrap/#引入 vmlinux.h，libbpf和应用头文件">[译]Building BPF applications with libbpf-bootstrap</a> 。在接近文章末尾时，对于更有经验的开发者，我还将介绍如何在没有<code>vmlinux.h</code>的情况下使用BPF CO-RE。</p>
<p>在我们进行的过程中，除非绝对必要，否则我将尽量保持更高层次的抽象描述，而不涉及具体的实现细节。如果你想了解更多，我建议你看看 <a href="https://github.com/libbpf/libbpf/tree/master/src/bpf_core_read.h">bpf_core_read.h</a> 头文件，并在<a href="http://vger.kernel.org/vger-lists.html#bpf">BPF 邮件列表</a> 上提问。</p>
<h3 id="读取内核数据">读取内核数据</h3>
<p>到目前为止，最常见的BPF CO-RE操作是从某个内核结构中读取字段的值。libbpf提供了一整套辅助函数，使读取字段变得简单且CO-RE可重定位。<strong>CO-RE可重定位</strong>意味着，无论结构体的实际内存布局如何（这可能会根据实际使用的内核版本和内核配置而改变），BPF程序都将进行调整，以便在相对于结构起始位置的正确实际偏移处读取字段的值。</p>
<h3 id="bpf_core_read">bpf_core_read()</h3>
<p>最基础的以CO-RE可重定位方式读取字段的辅助函数是<code>bpf_core_read(dst, sz, src)</code>，它将从由<code>src</code>指向的字段中读取<code>sz</code>字节，并将其存储到<code>dst</code>指向的内存中：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>task <span style="color:#fe8019">=</span> (<span style="color:#fabd2f">void</span> <span style="color:#fe8019">*</span>)<span style="color:#fabd2f">bpf_get_current_task</span>();
</span></span><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>parent_task;
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>err <span style="color:#fe8019">=</span> <span style="color:#fabd2f">bpf_core_read</span>(<span style="color:#fe8019">&amp;</span>parent_task, <span style="color:#fe8019">sizeof</span>(<span style="color:#fabd2f">void</span> <span style="color:#fe8019">*</span>), <span style="color:#fe8019">&amp;</span>task<span style="color:#fe8019">-&gt;</span>parent);
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> (err) {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* handle error */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* parent_task contains the value of task-&gt;parent pointer */</span>
</span></span></code></pre></div><p><code>bpf_core_read()</code>就像BPF辅助函数<code>bpf_probe_read_kernel()</code> 一样，只是它记录了需要在目标内核上重定位的字段的信息。即，如果<code>parent</code>字段在<code>struct task_struct</code>内的偏移量发生改变，比如在它前面添加了一个新字段，libbpf将自动将实际偏移量调整为正确的值。</p>
<p>需要牢记的一件重要事情是，字段的大小不会自动重设置，只有其偏移量会重定位。因此，如果您读取的字段是一个结构体，并且其大小发生变化，您可能会遇到麻烦。请参阅“<a href="#Sizing kernel types and fields">Sizing kernel types and fields</a>”小节以了解如何处理这个问题。一般建议是，尽可能不要将整个结构体字段一次性读取。最好只读取您最终感兴趣的字段。</p>
<h3 id="bpf_core_read_str">bpf_core_read_str()</h3>
<p>就像有<code>bpf_probe_read_kernel()</code>和<code>bpf_probe_read_kernel_str()</code>这对BPF辅助函数，前者指定读取的字节数，后者读取一个可变长度的以零结尾的C字符串，<code>bpf_core_read()</code>也有一个与<code>bpf_core_read_str()</code>相对应的函数。它的工作方式就像<code>bpf_probe_read_kernel_str()</code>一样，只是它记录了源字符数组字段的CO-RE重定位信息，该字段包含一个以零结尾的C字符串。所以<code>bpf_core_read_str()</code>是<code>bpf_probe_read_kernel_str()</code>的CO-RE可重定位版本。</p>
<p>请注意<strong>字符数组</strong>和<strong>字符指针</strong>之间重要但微妙的区别。在C中，当读取字符串值时，它们可以互换使用，因为数组在编译器中自动被视为指针。然而，在CO-RE的上下文中，这种区别非常重要。</p>
<p>假设如下结构体是我们要读取的内核类型</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> my_kernel_type {
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>name;
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">char</span> type[<span style="color:#d3869b">32</span>];
</span></span><span style="display:flex;"><span>  };
</span></span></code></pre></div><p><code>name</code>字段指向内存上存储的是字符串存储的位置，<code>type</code>字段指向的内存上存储的就是字符串。如果您需要使用CO-RE读取<code>name</code>指向的字符串，正确的处理方法是先以CO-RE可重定位的方式<strong>读取指针值</strong>，然后执行普通的（非CO-RE）<code>bpf_probe_read_kernel_str()</code>读取（下面的示例忽略了错误处理以便简洁）：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">struct</span> my_kernel_type <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>p;
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">char</span> str[<span style="color:#d3869b">32</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* get string pointer, CO-RE-relocatable */</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">bpf_core_read</span>(<span style="color:#fe8019">&amp;</span>p, <span style="color:#fe8019">sizeof</span>(p), <span style="color:#fe8019">&amp;</span>t<span style="color:#fe8019">-&gt;</span>name);
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* read the string, non-CO-RE-relocatable, pointer is valid regardless */</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">bpf_probe_read_kernel_str</span>(str, <span style="color:#fe8019">sizeof</span>(str), p);
</span></span></code></pre></div><p>类似的，读取<code>type</code>字段的逻辑如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">struct</span> my_kernel_type <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">char</span> str[<span style="color:#d3869b">32</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* read string as CO-RE-relocatable */</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">bpf_core_read_str</span>(str, <span style="color:#fe8019">sizeof</span>(str), <span style="color:#fe8019">&amp;</span>t<span style="color:#fe8019">-&gt;</span>type);
</span></span></code></pre></div><p>花一点时间思考为什么第一个示例不能使用<code>bpf_core_read_str()</code>（提示：你会将指针值解释为C字符串本身），为什么第二个不能先指针读取然后再字符串读取（提示：字符串本身是结构体的一部分，所以没有专用指针，它位于相对于<code>t</code>指针指向的位置的偏移量）。这很微妙，幸运的是并不经常出现，但在实际操作中如果不能识别这种差异，会非常困惑。</p>
<h3 id="bpf_core_read-1">BPF_CORE_READ()</h3>
<p>尽管<code>bpf_core_read()</code>虽然允许大量控制和仔细的错误处理，但直接使用它是相当繁琐的，特别是在读取需要通过较长的指针解引用链进行访问的字段。</p>
<p>让我们看一个读取正在运行的进程的可执行文件名的例子。如果您要编写一个普通的C语言内核代码并执行此操作，您将需要执行以下操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>name <span style="color:#fe8019">=</span> t<span style="color:#fe8019">-&gt;</span>mm<span style="color:#fe8019">-&gt;</span>exe_file<span style="color:#fe8019">-&gt;</span>fpath.dentry<span style="color:#fe8019">-&gt;</span>d_name.name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* now read string contents with bpf_probe_read_kernel_str() */</span>
</span></span></code></pre></div><p>请注意指针解引用的顺序，混合了一些子结构访问（即，<code>fpath.dentry</code> 和 <code>d_name.name</code>）。使用<code>bpf_core_read()</code>这样做很快就会变得混乱：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> mm_struct <span style="color:#fe8019">*</span>mm;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> file <span style="color:#fe8019">*</span>exe_file;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> dentry <span style="color:#fe8019">*</span>dentry;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>name;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fabd2f">bpf_core_read</span>(<span style="color:#fe8019">&amp;</span>mm, <span style="color:#d3869b">8</span>, <span style="color:#fe8019">&amp;</span>t<span style="color:#fe8019">-&gt;</span>mm);
</span></span><span style="display:flex;"><span>  <span style="color:#fabd2f">bpf_core_read</span>(<span style="color:#fe8019">&amp;</span>exe_file, <span style="color:#d3869b">8</span>, <span style="color:#fe8019">&amp;</span>mm<span style="color:#fe8019">-&gt;</span>exe_file);
</span></span><span style="display:flex;"><span>  <span style="color:#fabd2f">bpf_core_read</span>(<span style="color:#fe8019">&amp;</span>dentry, <span style="color:#d3869b">8</span>, <span style="color:#fe8019">&amp;</span>exe_file<span style="color:#fe8019">-&gt;</span>path.dentry);
</span></span><span style="display:flex;"><span>  <span style="color:#fabd2f">bpf_core_read</span>(<span style="color:#fe8019">&amp;</span>name, <span style="color:#d3869b">8</span>, <span style="color:#fe8019">&amp;</span>dentry<span style="color:#fe8019">-&gt;</span>d_name.name);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#928374;font-style:italic">/* now read string contents with bpf_probe_read_kernel_str() */</span>
</span></span></code></pre></div><p>诚然，这是一个相当极端的例子，通常指针解引用链不会那么长，但关键在于：使用这种方法很痛苦。尽管在上面的示例中完全忽略了错误处理。</p>
<p>为了使这样的多步读取更容易编写，libbpf提供了<code>BPF_CORE_READ()</code>宏。让我们看看使用<code>BPF_CORE_READ()</code>如何简化上面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>name;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  name <span style="color:#fe8019">=</span> <span style="color:#fabd2f">BPF_CORE_READ</span>(t, mm, exe_file, fpath.dentry, d_name.name);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#928374;font-style:italic">/* now read string contents with bpf_probe_read_kernel_str() */</span>
</span></span><span style="display:flex;"><span>  
</span></span></code></pre></div><p>来对比一下使用 libbpf提供的<code>BPF_CORE_READ()</code>宏和上面的C代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#928374;font-style:italic">/* direct pointer dereference */</span>
</span></span><span style="display:flex;"><span>  name <span style="color:#fe8019">=</span> t<span style="color:#fe8019">-&gt;</span>mm<span style="color:#fe8019">-&gt;</span>exe_file<span style="color:#fe8019">-&gt;</span>fpath.dentry<span style="color:#fe8019">-&gt;</span>d_name.name;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#928374;font-style:italic">/* using BPF_CORE_READ() helper */</span>
</span></span><span style="display:flex;"><span>  name <span style="color:#fe8019">=</span> <span style="color:#fabd2f">BPF_CORE_READ</span>(t, mm, exe_file, fpath.dentry, d_name.name);
</span></span></code></pre></div><p>基本上，每个指针解引用在宏调用中变成一个逗号。每个子结构访问保持不变。相当简单明了。</p>
<p>您可能已经注意到<code>BPF_CORE_READ()</code>直接返回读取的值，而不返回错误。如果传入的任何指针为NULL或指向无效内存，您将获得<code>0</code>（或<code>NULL</code>）。但是，如果您确实需要错误传播和处理，那么您将不得不使用低级别的<code>bpf_core_read()</code>原语并显式处理错误。实际上，这通常不是问题或必要的。</p>
<h3 id="bpf_core_read_into">BPF_CORE_READ_INTO()</h3>
<p>在某些情况下，有必要或更方便地将结果读入目标内存，而不是像<code>BPF_CORE_READ()</code>那样直接返回它。例如，直接地返回值不起作用的常见情况是读取C数组（例如，从套接字结构中的IPv4地址），因为C语言不允许从表达式直接返回数组。对于这种情况，libbpf提供了<code>BPF_CORE_READ_INTO()</code>宏，它的行为类似于<code>BPF_CORE_READ()</code>，但将最终字段的值读入目标内存。将上面的示例转换为<code>BPF_CORE_READ_INTO()</code>，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>name;
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>err <span style="color:#fe8019">=</span> <span style="color:#fabd2f">BPF_CORE_READ_INTO</span>(<span style="color:#fe8019">&amp;</span>name, t, mm, binfmt, executable, fpath.dentry, d_name.name);
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> (err) { <span style="color:#928374;font-style:italic">/* handle errors */</span> }
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* now `name` contains the pointer to the string */</span>
</span></span></code></pre></div><p>注意<code>BPF_CORE_READ_INTO()</code>中额外的<code>&amp;name</code>参数，以及最后一次操作（即，读取<code>d_name.name</code>）返回错误码。总的来说，<code>BPF_CORE_READ()</code>在实践中更方便，易于阅读。</p>
<h3 id="bpf_core_read_str_into">BPF_CORE_READ_STR_INTO()</h3>
<p>对于最后一个字段是字符数组字段的情况（就像上面示例中的<code>name</code>与<code>type</code>一样），有一个<code>BPF_CORE_READ_STR_INTO()</code>宏，现在你应该对它的工作方式有一个很好的猜测。如果不是，请重新查看<a href="#bpf_core_read_str()">bpf_core_read_str()</a>部分。</p>
<h3 id="btf-enabled-bpf-program-types-with-direct-memory-reads">BTF-enabled BPF program types with direct memory reads</h3>
<p>在上面讨论了<code>BPF_CORE_READ()</code>宏系列之后，要注意，重要的是您不必总是使用它们来执行CO-RE可重定位读取。或者说，您不必总是&quot;探测读取&quot;（即，使用BPF帮助器读取）内存。有时您可以直接访问内核内存。</p>
<p>某些BPF程序类型是“BTF启用的”，这意味着内核中的BPF验证器知道与传入BPF程序的输入参数关联的类型信息。这使BPF验证器知道哪些内存可以在不调用<code>bpf_core_read()</code>或<code>bpf_probe_read_kernel()</code>的情况下直接从内核安全地读取。这些BTF启用的BPF程序类型包括：</p>
<ul>
<li>BTF-enabled raw tracepoint (<code>SEC(&quot;tp_btf/...&quot;)</code> in libbpf lingo);</li>
<li><code>fentry</code>/<code>fexit</code>/<code>fmod_ret</code> BPF programs;</li>
<li>BPF LSM programs;</li>
<li>probably some more but I&rsquo;m too lazy to go and check.</li>
</ul>
<p>在这样的程序中，如果它们获得了指向某个内核类型的指针（例如，<code>struct task_struct *</code>），BPF程序代码可以直接解引用内存，甚至跟踪指针。因此，对于我们在上面一直以演示<code>BPF_CORE_READ()</code>的使用详细示例而言，当使用例如<code>fentry</code> BPF程序时，您所要做的就是：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> ...;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> <span style="color:#fe8019">*</span>name;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  name <span style="color:#fe8019">=</span> t<span style="color:#fe8019">-&gt;</span>mm<span style="color:#fe8019">-&gt;</span>binfmt<span style="color:#fe8019">-&gt;</span>executable<span style="color:#fe8019">-&gt;</span>fpath.dentry<span style="color:#fe8019">-&gt;</span>d_name.name;
</span></span></code></pre></div><p>是的，它与最开始的示例完全相同。但请记住，要获取字符串本身的内容，您仍然需要使用<code>bpf_probe_read_kernel_str()</code>。</p>
<p>这种直接内存访问快速、方便、简单，您应该尽可能地使用它。不幸的是，现实世界中仍然有很多情况需要明确依赖“探测读取”，所以<code>BPF_CORE_READ()</code>将在可预见的将来成为您的朋友，因此一定要熟悉它。</p>
<h3 id="读取位域和不同字节长度的整数">读取位域和不同字节长度的整数</h3>
<p>从BPF读取位域一直是一个挑战。BPF应用程序开发人员必须付出巨大努力，编写相当难以维护且痛苦的代码，才能从内核类型中提取位域值。以<code>struct tcp_sock</code>为例。它有许多以位域编码的有用信息。即使在使用BCC及其源代码编译方法时，提取这些位域也是一个主要的麻烦和维护负担。</p>
<p>幸运的是，libbpf提供了两个易于使用的宏，用于以CO-RE可重定位方式读取位域：<code>BPF_CORE_READ_BITFIELD()</code>和<code>BPF_CORE_READ_BITFIELD_PROBED()</code>。_PROBED变体必须在需要“探测读取”的数据上使用，就像在<code>BPF_CORE_READ()</code>中一样。<code>BPF_CORE_READ_BITFIELD()</code>仅在直接内存访问可用时使用（例如，从<code>fentry/</code>BPF程序，参见上面的“<a href="#BTF-enabled BPF program types with direct memory reads">&ldquo;BTF-enabled BPF program types with direct memory reads&rdquo;</a>”部分）。这两个宏都以u64整数返回位域的值。下面是从struct tcp_sock读取其中一个位域的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">static</span> u64 <span style="color:#fabd2f">sk_get_syn_data</span>(<span style="color:#fe8019">const</span> <span style="color:#fe8019">struct</span> tcp_sock<span style="color:#fe8019">*</span> tp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* extract tp-&gt;syn_data bitfield value */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#fabd2f">BPF_CORE_READ_BITFIELD_PROBED</span>(tp, syn_data);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>就是这么简单。使用BCC实现相同的效果（为什么这样做有效以及何时会出错，留给读者作为练习）如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">static</span> u64 <span style="color:#fabd2f">sk_get_syn_data</span>(<span style="color:#fe8019">const</span> <span style="color:#fe8019">struct</span> tcp_sock<span style="color:#fe8019">*</span> tp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    u8 s;
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* get byte before tlp_high_seq */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">bpf_probe_read</span>(<span style="color:#fe8019">&amp;</span>s, <span style="color:#d3869b">1</span>, <span style="color:#fe8019">&amp;</span>(tp<span style="color:#fe8019">-&gt;</span>tlp_high_seq) <span style="color:#fe8019">-</span> <span style="color:#d3869b">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* syn_data is the third bit of that byte in little-endian */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> (s <span style="color:#fe8019">&gt;&gt;</span> <span style="color:#d3869b">2</span>) <span style="color:#fe8019">&amp;</span> <span style="color:#d3869b">0x1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编写、阅读和维护随着内核版本变化的<code>struct tcp_sock</code>是一种恐怖的经历。使用<code>BPF_CORE_READ_BITFIELD_PROBED()</code>让这变得非常简单。</p>
<p>值得注意的是，<code>BPF_CORE_READ_BITFIELD()</code>和<code>BPF_CORE_READ_BITFIELD_PROBED()</code>还有另一个重要功能。它们不仅可以读取位域，还可以读取<strong>任何整数</strong>字段。无论字段的实际类型（位域或最多8字节的大小的整数），宏都会返回正确的带符号扩展的8字节整数。即使字段从整数更改为位域，反之亦然，它仍然可以继续工作。如果字段从<code>int</code>更改为<code>u8</code>，它也会继续工作。因此，<code>BPF_CORE_READ_BITFIELD()</code>宏是<strong>读取任何整数字段的通用方法</strong>，无论其类型或大小如何。</p>
<h3 id="sizing-kernel-types-and-fields">Sizing kernel types and fields</h3>
<p>正如前面某个部分中提到的，<code>BPF_CORE_READ()</code>并不会自动使读取大小不一的字段（例如，整个结构或数组）具有CO-RE可重定位性，因为预分配正确的目标内存以适应内核中任何可能的大小变化通常是相当困难的。</p>
<p>尽管如此，在某些情况下，了解字段或类型的大小是很重要的。为了满足这些需求，BPF CO-RE提供了两个辅助函数：<code>bpf_core_type_size()</code>和<code>bpf_core_field_size()</code>。它们的使用类似于<code>bpf_core_type_exists()</code>和<code>bpf_core_field_exists()</code>(在下一节中描述)，但它们返回的是字段或类型的大小是多少字节，而不是0或1。</p>
<p>你如何使用这个值取决于你：你可以将它作为第二个参数传递给<code>bpf_core_read()</code>，以使读取完全具有CO-RE可重定位性。如果你正在处理一个结构体数组，并需要跳过前面的几个元素，你可以使用<code>bpf_core_type_size()</code>来计算正确的字节偏移量，以获取到第N个元素的开头。或者你可以将其仅用于调试和报告目的，这完全取决于你和BPF CO-RE如何规定你使用其功能。</p>
<h2 id="处理内核变更和特性检测">处理内核变更和特性检测</h2>
<p><code>BPF_CORE_READ()</code>宏族是BPF CO-RE的主要工具，但构建实用的BPF应用程序还需要BPF CO-RE的更多功能。</p>
<p>BPF应用程序需要解决的一个非常常见的问题是进行特性检测。即检测特定的主机内核是否支持某个新的和可选的特性，BPF应用程序可以使用这个特性来获取更多信息或提高效率。然而，如果不支持，BPF应用程序优先回退到支持旧内核的代码，而不是直接失败。</p>
<p>BPF CO-RE提供了许多不同的机制来满足这些需求。当然，没有什么可以阻止使用下面描述的机制来处理特性检测以外的用例，但我将以特性检测为主要用例来描述所有内容。</p>
<h3 id="bpf_core_field_exists">bpf_core_field_exists()</h3>
<p><code>bpf_core_field_exists()</code>允许检查给定内核类型是否包含指定的字段。在内核特性检测的上下文中，如果某个期望的内核特性是与向内核类型之一添加特定字段一起添加的，那么可以使用简单的<code>bpf_core_field_exists()</code>检查来检测这样的特性。</p>
<p>作为一个具体的例子，检测内核是否支持基于perf的BPF程序类型（tracepoints、kprobes、uprobes）的BPF cookie（在此<a href="https://github.com/torvalds/linux/commit/82e6b1eee6a8875ef4eacfd60711cce6965c6b04">提交</a>中添加）的一种方法是：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">union</span> bpf_attr <span style="color:#fe8019">*</span>attr <span style="color:#fe8019">=</span> ... <span style="color:#928374;font-style:italic">/* could be NULL */</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> (<span style="color:#fabd2f">bpf_core_field_exists</span>(attr<span style="color:#fe8019">-&gt;</span>link_create.perf_event.bpf_cookie)) {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* bpf_cookie is supported */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#fe8019">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* bpf_cookie is NOT supported */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的例子假设BPF程序有一个<code>union bpf_attr *</code>类型的变量。它可以是<code>NULL</code>，这并不重要，因为指针本身从未被读取，只是为了向编译器传递类型信息。对于没有现成可用的所需类型变量的情况，你可以编写等效的检查（使用C类型系统特性）：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">if</span> (<span style="color:#fabd2f">bpf_core_field_exists</span>(
</span></span><span style="display:flex;"><span>        ((<span style="color:#fe8019">union</span> bpf_attr <span style="color:#fe8019">*</span>)<span style="color:#d3869b">0</span>)<span style="color:#fe8019">-&gt;</span>link_create.perf_event.bpf_cookie) {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* bpf_cookie is supported */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#fe8019">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* bpf_cookie is NOT supported */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这里，如果主机内核中的<code>union bpf_attr</code>没有<code>link_create.perf_event.bpf_cookie</code>，那么<code>if</code>/<code>else</code>的第一个分支中的代码将永远不会被执行（也不会被验证）。</p>
<p>值得重申的是，这样的代码被BPF验证器正确地检测为死代码，因此从未被验证。这意味着这样的代码可以在不担心BPF验证失败的情况下使用内核和BPF功能（例如，新的BPF辅助函数集）。例如，如果上面的第一个分支使用<code>bpf_get_attach_cookie()</code>辅助函数来获取BPF cookie特性，那么在尚未具有该帮助器的旧内核上，该程序将被正确验证。</p>
<h3 id="bpf_core_type_exists">bpf_core_type_exists()</h3>
<p>对于类型存在本身很重要的情况，BPF CO-RE 提供了一种检查类型存在的方法 <code>bpf_core_type_exists()</code>辅助函数。下面是检测内核是否支持 BPF ring buffer 的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">if</span> (<span style="color:#fabd2f">bpf_core_type_exists</span>(<span style="color:#fe8019">struct</span> bpf_ringbuf)) {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* BPF ringbuf helpers (e.g., bpf_ringbuf_reserve()) exist */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>请注意确保在某处定义了<code>struct bpf_ringbuf</code>（即使为空），否则您将检查<code>bpf_ringuf</code>向前声明是否存在，这几乎可以肯定不是您想要的。对于最近的 <code>vmlinux.h</code> 来说，这应该不是问题，但还是需要注意。</p>
<h3 id="bpf_core_enum_value_exists">bpf_core_enum_value_exists()</h3>
<p>能够检测给定枚举值的存在非常有用。这种检查的一个重要实际应用是<strong>检测是否支持某个 BPF 辅助程序</strong>。</p>
<p>每个 BPF 辅助函数在<code>enum bpf_func_id</code>中都有一个对应的枚举值</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">enum</span> bpf_func_id {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    BPF_FUNC_ringbuf_output <span style="color:#fe8019">=</span> <span style="color:#d3869b">130</span>,
</span></span><span style="display:flex;"><span>    BPF_FUNC_ringbuf_reserve <span style="color:#fe8019">=</span> <span style="color:#d3869b">131</span>,
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  };
</span></span></code></pre></div><p>因此，检查 BPF 辅助函数 <code>bpf_xxx()</code>是否存在的最直接方法是检查<code>enum bpf_func_id</code> 中是否存在<code>BPF_FUNC_xxx</code>。因此，与其在前面的示例中使用 <code>bpf_core_type_exists(struct bpf_ringbuf)</code> 进行类型检查，不如更明确地说明我们的意图：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fe8019">if</span> (<span style="color:#fabd2f">bpf_core_enum_value_exists</span>(<span style="color:#fe8019">enum</span> bpf_func_id, BPF_FUNC_ringbuf_reserve)) {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* use bpf_ringbuf_reserve() safely */</span>
</span></span><span style="display:flex;"><span>} <span style="color:#fe8019">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* fall back to using bpf_perf_event_output() */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>许多其他 BPF 功能也可以以类似的方式检测到。BPF 程序类型和 BPF 映射类型支持只是另一个示例。</p>
<p>当然，此功能不仅限于与 BPF 相关的功能。通过字段、类型或枚举器值的存在可以检测的任何内核特征都可以使用 BPF CO-RE 轻松执行。</p>
<p>特征检测也不会停留在基于类型系统的检查上。在接下来的几节中，我们将介绍一些可用于执行内核特征检测的其他 BPF CO-RE 机制。不仅仅是功能检测，它们还允许在运行时提取特定内核的信息（如 Kconfig 值），这些信息通常无法提前知道。</p>
<h3 id="linux_kernel_version">LINUX_KERNEL_VERSION</h3>
<p>有时，检查 Linux 内核版本是检测必要功能存在的唯一方法。Libbpf 允许在 BPF 程序代码使用特殊的 <code>extern</code> 变量来执行此操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fabd2f">int</span> LINUX_KERNEL_VERSION __kconfig;
</span></span></code></pre></div><p>声明后，<code>LINUX_KERNEL_VERSION</code> 以与内核本身完全相同的方式对正在运行的内核版本进行编码。这样的变量可以像任何其他变量一样使用：您可以与它进行比较、打印、记录并发送到用户态等。在所有这些情况下，BPF 验证器都知道其确切值，因此它可以检测死代码，就像上面描述的基于类型系统的检查一样。</p>
<p>Libbpf 还提供了一个方便的 <code>KERNEL_VERSION(major, minor, patch)</code>宏，用于与<code>LINUX_KERNEL_VERSION</code>进行比较：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;bpf/bpf_helpers.h&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c"></span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">extern</span> <span style="color:#fabd2f">int</span> LINUX_KERNEL_VERSION __kconfig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> (LINUX_KERNEL_VERSION <span style="color:#fe8019">&gt;</span> <span style="color:#fabd2f">KERNEL_VERSION</span>(<span style="color:#d3869b">5</span>, <span style="color:#d3869b">15</span>, <span style="color:#d3869b">0</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* we are on v5.15+ */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="kconfig-extern-variables">Kconfig extern variables</h3>
<p>事实上，libbpf 允许为任何内核配置 （Kconfig） 值声明成特殊的 <code>extern</code> 变量。请记住，只有当内核通过<code>/proc/config.gz</code>  <em>公开其内核配置</em>时，才支持此功能，幸运的是，这在现代 Linux 发行版中非常常见。目前支持几种不同类型的变量。它们的使用取决于实际的 Kconfig 值类型：</p>
<ul>
<li>对于<code>y</code> /<code>n</code>/<code>m</code> 三态 Kconfig 值，可以使用<code>extern enum libbpf_tristate</code>变量，这些变量分别定义了三个可能的值：<code>TRI_YES</code>，<code>TRI_NO</code>，<code>TRI_MODULE</code>。或者，声明一个 <code>extern char</code> 变量将按原样捕获字符值（即，您实际上将拥有一个具有<code>'y'</code> 、<code>'n'</code>、<code>'m'</code> 字符值之一的变量）。</li>
<li>对于 <code>y</code>/<code>n</code> 双态（布尔值）Kconfig 值，您还可以使用 <code>bool</code> 类型（除了已经描述的 <code>char</code> 和 <code>enum libbpf_tristate</code> 类型）。在这种情况下，<code>y</code> 映射到 <code>true</code>，<code>n</code> 将变为 <code>false</code>。</li>
<li>对于整数 Kconfig 值，请使用 C 整数类型之一：支持所有 1 字节、2 字节、4 字节和 8 字节有符号和无符号整数。如果实际的 Kconfig 值不适合声明的整数类型，libbpf 将发出错误，而不是截断该值。</li>
<li>对于字符串 Kconfig 值，请使用 <code>const char[N]</code> 数组变量。如果实际值不合适，它将被截断并以零结尾，但 libbpf 将发出警告。</li>
</ul>
<p>请记住，如果<code>/proc/config.gz</code>  中缺少请求的 Kconfig 值，libbpf 将中止程序加载并显示错误。为了优雅地处理这个问题，将这样的 Kconfig extern 变量声明为具有 <code>__weak</code> 属性的弱变量。在这种情况下，如果缺少该值，则根据使用的类型，将假定该值为 <code>false</code>、<code>TRI_NO</code>、<code>'0'</code>（零字符）、<code>0</code> 或<code>“”</code> （空字符串）。</p>
<p>下面是声明和使用不同类型的 Kconfig extern 变量的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fabd2f">int</span> LINUX_KERNEL_VERSION __kconfig;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fe8019">enum</span> libbpf_tristate CONFIG_BPF_PRELOAD __kconfig __weak;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fabd2f">bool</span> CONFIG_BPF_JIT_ALWAYS_ON __kconfig __weak;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fabd2f">char</span> CONFIG_BPF_JIT_DEFAULT_ON __kconfig __weak;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fabd2f">int</span> CONFIG_HZ __kconfig;
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">extern</span> <span style="color:#fe8019">const</span> <span style="color:#fabd2f">char</span> CONFIG_MODPROBE_PATH[<span style="color:#d3869b">256</span>] __kconfig __weak;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">if</span> (LINUX_KERNEL_VERSION <span style="color:#fe8019">&gt;</span> <span style="color:#fabd2f">KERNEL_VERSION</span>(<span style="color:#d3869b">5</span>, <span style="color:#d3869b">15</span>, <span style="color:#d3869b">0</span>)) { ... }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">switch</span> (CONFIG_BPF_PRELOAD) {
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">case</span> <span style="color:#fb4934">TRI_NO</span>: ...; <span style="color:#fe8019">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">case</span> <span style="color:#fb4934">TRI_YES</span>: ...; <span style="color:#fe8019">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">case</span> <span style="color:#fb4934">TRI_MODULE</span>: ...; <span style="color:#fe8019">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">if</span> (<span style="color:#fe8019">!</span>CONFIG_BPF_JIT_ALWAYS_ON)
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">bpf_printk</span>(<span style="color:#b8bb26">&#34;BPF_JIT_DEFAULT_ON: %c</span><span style="color:#b8bb26">\n</span><span style="color:#b8bb26">&#34;</span>, CONFIG_BPF_JIT_DEFAULT_ON <span style="color:#fe8019">?:</span> <span style="color:#b8bb26">&#39;n&#39;</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#fabd2f">bpf_printk</span>(<span style="color:#b8bb26">&#34;HZ is %d, MODPROBE_PATH: %s</span><span style="color:#b8bb26">\n</span><span style="color:#b8bb26">&#34;</span>, CONFIG_HZ, CONFIG_MODPROBE_PATH);
</span></span></code></pre></div><h3 id="可重定位枚举">可重定位枚举</h3>
<p>一些 BPF 应用程序遇到的一个有趣的挑战是需要使用“不稳定”的内部内核枚举。也就是说，枚举没有分配给它们的一组固定常量和/或整数值。一个很好的例子是<code>enum cgroup_subsys_id</code>，它在  <a href="https://github.com/torvalds/linux/blob/87066fdd2e30fe9dd531125d95257c118a74617e/include/linux/cgroup-defs.h#L43-L47">include/linux/cgroup-defs.h</a> 中定义，其定义可能因内核编译期间启用的 cgroup 功能而异（有关详细信息，请参见 <a href="https://github.com/torvalds/linux/blob/87066fdd2e30fe9dd531125d95257c118a74617e/include/linux/cgroup_subsys.h">include/linux/cgroup_subsys.h</a> ）。因此，如果你需要知道 <code>cgroup_subsys_id::cpu_cgrp_id</code> 的实际整数值，这可能是一个大问题，因为这个枚举是内核内部的，并且是动态生成的。</p>
<p>再一次，BPF CO-RE来救援。它允许在 <code>bpf_core_enum_value()</code>宏的帮助下捕获实际值：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fabd2f">int</span> id <span style="color:#fe8019">=</span> <span style="color:#fabd2f">bpf_core_enum_value</span>(<span style="color:#fe8019">enum</span> cgroup_subsys_id, cpu_cgrp_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* id will contain the actual integer value in the host kernel */</span>
</span></span></code></pre></div><h3 id="guarding-potentially-failing-relocations">Guarding potentially failing relocations</h3>
<p>某些内核上缺少某些字段的情况并不少见。如果 BPF 程序使用 <code>BPF_CORE_READ()</code>尝试读取带有的缺失字段，则在 BPF 验证期间将导致错误。同样，当获取主机内核中不存在的枚举（或类型）的枚举值（或类型大小）时，CO-RE 重定位将失败。</p>
<p>不幸的是，目前这个错误非常隐晦（<a href="https://github.com/libbpf/libbpf/issues/371">但很快就会被 libbpf 改进</a>），所以最好注意它，以防万一你不小心遇到它。如果遇到类似于以下错误的错误，请知道这是因为 CO-RE 重定位无法找到相应的字段/类型/枚举：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#d3869b">1</span><span style="color:#fe8019">:</span> (<span style="color:#d3869b">85</span>) call unknown#<span style="color:#d3869b">195896080</span>
</span></span><span style="display:flex;"><span>  invalid func unknown#<span style="color:#d3869b">195896080</span>
</span></span></code></pre></div><p>该<code>195896080</code>用十六进制表示为<code>0xbad2310</code>（表示“bad relo”），并且是 libbpf 用来标记 CO-RE 重定位失败的指令的常量。libbpf 不立即报告此类错误的原因是，如果需要，BPF 应用程序可以正常处理缺少字段/类型/枚举和相应的失败 CO-RE 重定位。这样一来，只需一个 BPF 应用程序就可以适应内核类型中非常剧烈的变化（这是“一次编译 - 随处运行”理念的关键目标）。</p>
<p>当某些字段/类型/枚举可能丢失时，您可以使用处理内核更改一节中描述的检查之一来保护此类代码路径。如果保护得当，BPF 验证器将知道这样的代码路径不可能在该特定内核上命中，因此会将其作为死代码消除。</p>
<p>这种方法允许选择性地捕获内核信息片段，如果实际运行的内核确实有这些片段。否则，BPF 应用程序可以干净地回退到替代逻辑，并优雅地处理缺少的功能或数据。只要对可能失败的 CO-RE 搬迁得到妥善保护，所有这些都会很好用。此处的 CO-RE 重定位是指对 <code>BPF_CORE_READ()</code>系列宏、类型/字段大小重定位或枚举器值捕获的任何使用。如果目标字段/类型/枚举不存在或具有某些不兼容的定义，则任何没有意义的内容。</p>
<p>继续前面<code>cpu_cgrp_id</code>枚举值的例子，为了处理可能没有定义此类枚举器的内核（例如，由于Kconfig 开关<code>CONFIG_CGROUP_PIDS</code>未设置），可以使用 <code>bpf_core_enum_value_exists()</code> 检查（<strong>存在检查永远不会失败！</strong>），它返回 <code>true</code>/<code>false</code>（严格来说，它在 C 中是 <code>0</code> 或 <code>1</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fabd2f">int</span> id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> (<span style="color:#fabd2f">bpf_core_enum_value_exists</span>(<span style="color:#fe8019">enum</span> cgroup_subsys_id, cpu_cgrp_id))
</span></span><span style="display:flex;"><span>    id <span style="color:#fe8019">=</span> <span style="color:#fabd2f">bpf_core_enum_value</span>(<span style="color:#fe8019">enum</span> cgroup_subsys_id, cpu_cgrp_id);
</span></span><span style="display:flex;"><span><span style="color:#fe8019">else</span>
</span></span><span style="display:flex;"><span>    id <span style="color:#fe8019">=</span> <span style="color:#fe8019">-</span><span style="color:#d3869b">1</span>; <span style="color:#928374;font-style:italic">/* fallback value */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* use id even if cpu_cgrp_id isn&#39;t defined */</span>
</span></span></code></pre></div><p>上面的例子在任何内核上都可以正常工作，无论<code>cpu_cgrp_id</code>枚举是否存在，即使 <code>bpf_core_enum_value()</code>在没有枚举<code>cpu_cgrp_id</code>的内核上失败。这一切都是因为有适当保护的代码路径。</p>
<h2 id="advanced-topics">Advanced topics</h2>
<p>前面的部分介绍了最常见的 CO-RE 功能。本节将介绍您可能需要处理的一些更高级的主题，具体取决于 BPF 应用程序必须处理的内部内核状态的复杂程度及其在不同内核版本中的变体。</p>
<h3 id="自定义-co-re-可重定位数据类型">自定义 CO-RE 可重定位数据类型</h3>
<p>到目前为止，我们一直假设上述所有示例中使用的内核类型都来自 <code>vmlinux.h</code> 头文件，该头文件是从最近且足够完整的内核 BTF 生成的。但是使用<code>vmlinux.h</code>  并不是 BPF CO-RE 的要求。这主要只是为了 BPF 应用程序开发人员的便利。</p>
<p>此外，有时在更复杂的情况下，<code>vmlinux.h</code> 可能还不够。要么是因为所需的类型还没有在内核 BTF 中，要么是因为内核中的某些内容以不兼容的方式发生了变化（例如，字段被重命名），现在您需要处理同一内核类型的两个不兼容的定义（我们将在下面处理这种不幸的情况）。</p>
<p>不管是什么原因，定义你自己对内核类型的期望并使其可重新定位是很容易的。让我们以 <code>struct task_struct</code> 为例。这是一个庞大而复杂的结构，但通常你只需要它的整个定义中的几个简单字段。使用 BPF CO-RE，只需声明您将需要的字段就足够了，跳过所有其他字段，保持类型定义简单明了。</p>
<p>假设您只关心 <code>pid</code>、<code>group_leader</code> 和 <code>comm</code> 字段。声明<code>struct task_struct</code> 如下足以使一切正常：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#fe8019">struct</span> task_struct {
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">int</span> pid;
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">char</span> comm[<span style="color:#d3869b">16</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>group_leader;
</span></span><span style="display:flex;"><span>  } <span style="color:#fabd2f">__attribute__</span>((preserve_access_index));
</span></span></code></pre></div><p>首先，字段的顺序完全无关紧要。</p>
<p>其次，<code>__attribute__((preserve_access_index))</code> 对于允许直接内存读取的 BPF 程序是必需的。例如，BTF支持的raw tracepoints (<code>SEC(tp_btf)</code>)和 <code>fentry</code>/<code>fexit</code> BPF 程序。有了这个属性，使用此结构定义的任何直接内存读取都将自动可进行 CO-RE 重定位。</p>
<p>使用显式 <code>BPF_CORE_READ()</code> 族宏时，不需要  <code>__attribute__((preserve_access_index))</code>，因为这些宏会自动强制执行它。但是，如果您直接使用普通的旧 <code>bpf_probe_read_kernel()</code>辅助函数时，如果结构体具有 <code>preserve_access_index</code> 属性，则此类探测读取也会被重新定位为 CO-RE。因此，简而言之，指定此属性始终是一个好主意。</p>
<p>差不多就是这样。您可以将此类类型用于任何 CO-RE 读取或检查。如您所见，它不必与实际<code>struct task_struct</code>定义完全匹配。只需要存在必要的字段子集并兼容。您的 BPF 程序不需要 <code>struct task_struct</code> 的所有其他内容都与 BPF CO-RE 无关。</p>
<h3 id="处理不兼容的字段和数据类型更改">处理不兼容的字段和数据类型更改</h3>
<p>如前几节所述，在某些情况下，内核类型和字段的更改方式使来自两个不同内核的类型定义不兼容。例如，考虑在结构体中重命名字段。作为一个非常真实和具体的例子，让我们在这个<a href="https://github.com/torvalds/linux/commit/2f064a59a11ff9bc22e52e9678bc601404c7cb34">提交</a>中将 <code>task_struct</code> 的 <code>state</code> 字段最近重命名为 <code>__state</code>。如果您要编写需要读取任务状态的 BPF 应用程序，那么，根据内核版本，您需要用<strong>两个不同</strong>的名称获取<strong>相同的字段</strong>。让我们看看 BPF CO-RE 如何处理这个问题。</p>
<p>BPF CO-RE 有一个重要的命名约定（我称之为“<strong>忽略的后缀规则</strong>”）。这是一个鲜为人知的功能，但它是处理上述情况的关键机制。对于任何类型、字段、枚举或枚举器，如果实例名称包含 <code>___something</code> 形式的后缀（三个下划线加上后面的一些文本），则出于 CO-RE 重定位的目的，将忽略此类名称后缀，就好像它从未存在过一样。</p>
<p>这意味着，如果您要定义一个<code>struct task_struct___my_own_copy</code>并在 BPF 应用程序中使用它，就 BPF CO-RE 而言，该结构等同于内核<code>struct task_struct</code>，并且将相应地进行匹配和重新定位。这同样适用于字段名称（因此 <code>state</code> 或 <code>state___custom</code> 实际上相同）和枚举（枚举类型名称本身以及该枚举中的枚举器名称）。它实际上是双向的，因此，如果内核具有<code>struct task_struct</code>和 <code>struct task_struct___2</code>，例如（有时由于 C 类型系统和头文件在内核源代码中包含交互），则这两个结构都将是匹配 BPF 程序源代码中定义的<code>struct task_struct___my</code>的候选者。</p>
<p>这在实践中意味着，您现在可以对同一内核类型/字段/枚举拥有多个独立且相互冲突的定义，但既可以将代码编译为有效的 C，也可以根据您使用的任何功能检测方法在运行时选择正确的定义。</p>
<p>让我们看一个示例，说明如何处理提到的 <code>task_struct-&gt;state</code> 重命名为 <code>task_struct-&gt;__state</code>的情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#928374;font-style:italic">/* latest kernel task_struct definition, which can also come from vmlinux.h */</span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct {
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">int</span> __state;
</span></span><span style="display:flex;"><span>} <span style="color:#fabd2f">__attribute__</span>((preserve_access_index));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct___old {
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">long</span> state;
</span></span><span style="display:flex;"><span>} <span style="color:#fabd2f">__attribute__</span>((preserve_access_index));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">struct</span> task_struct <span style="color:#fe8019">*</span>t <span style="color:#fe8019">=</span> (<span style="color:#fabd2f">void</span> <span style="color:#fe8019">*</span>)<span style="color:#fabd2f">bpf_get_current_task</span>();
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">int</span> state;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">if</span> (<span style="color:#fabd2f">bpf_core_field_exists</span>(t<span style="color:#fe8019">-&gt;</span>__state)) {
</span></span><span style="display:flex;"><span>    state <span style="color:#fe8019">=</span> <span style="color:#fabd2f">BPF_CORE_READ</span>(t, __state);
</span></span><span style="display:flex;"><span>} <span style="color:#fe8019">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* recast pointer to capture task_struct___old type for compiler */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">struct</span> task_struct___old <span style="color:#fe8019">*</span>t_old <span style="color:#fe8019">=</span> (<span style="color:#fabd2f">void</span> <span style="color:#fe8019">*</span>)t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">/* now use old &#34;state&#34; name of the field */</span>
</span></span><span style="display:flex;"><span>    state <span style="color:#fe8019">=</span> <span style="color:#fabd2f">BPF_CORE_READ</span>(t_old, state);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>在上面的例子中，有两个最关键的部分。</p>
<p>首先，根据最新的<code>struct task_struct</code>定义进行字段存在性检查。如果正在运行的内核较旧并且还没有 <code>__state</code> 字段，则 <code>bpf_core_field_exists(t-&gt;__state)</code> 将返回 0，<a href="#Guarding potentially failing relocations">BPF 验证器将跳过并消除 if 语句的第一个分支作为死代码</a> ，因此永远不会尝试读取 <code>t-&gt;__state</code>。</p>
<p>其次，将 <code>struct task_struct *</code> 指针重新转换为 <code>struct task_struct___old *</code> 指针。这是允许 C 编译器跟踪 <code>struct task_struct</code>的“替代定义”（即本例中的 <code>struct  task_struct___old</code>）的类型信息所必需的。编译器将识别并编译 <code>t_old-&gt;state</code>字段引用（隐藏在 <code>BPF_CORE_READ()</code> 实现中）作为有效的 C 表达式，并将记录相应的 CO-RE 重定位信息，让 libbpf 知道 BPF 程序应该读取哪种类型和字段。</p>
<p>使用 <code>___suffix</code> 规则，这一切都可以正常工作。当 libbpf 准备将 BPF 程序发送到内核进行验证时，libbpf 将执行 CO-RE 重定位并适当调整偏移量。其中一个 CO-RE 重定位不会被解析（因为<code>__state</code>或<code>state</code>不能同时存在于内核中），并将导致相应的 BPF 指令“中毒”（召回<code>0xbad2310</code>前面描述的），但该指令将由字段存在逻辑保护，并在程序加载期间由验证器消除。</p>
<p>随着 BPF CO-RE 应用程序数量和复杂性的增长，以及 Linux 内核的发展并不可避免地经历内部更改和重构，处理不兼容的内核更改的能力只会变得越来越重要，因此请注意此技术。上面描述了一堆实现细节，但希望它有助于理解如何在实践中使用该功能。</p>
<h3 id="从用户态内存中读取内核数据结构">从用户态内存中读取内核数据结构</h3>
<p>在某些应用程序中可能会出现的一个（诚然不寻常的）需求是需要从用户态内存中读取内核类型。它很可能是内核 UAPI 类型之一，作为系统调用输入参数传入。为了适应这种情况（以及完整性），libbpf 提供了其 <code>BPF_CORE_READ()</code>系列宏的用户态等价物：</p>
<ul>
<li><code>bpf_core_read_user()</code>;</li>
<li><code>bpf_core_read_user_str()</code>;</li>
<li><code>BPF_CORE_READ_USER_STR_INTO()</code>;</li>
<li><code>BPF_CORE_READ_USER_INTO()</code>;</li>
<li><code>BPF_CORE_READ_USER()</code>.</li>
</ul>
<p>它们的功能和行为与它们内核态变体完全相同，唯一的区别是所有内存读取都是使用 <code>bpf_probe_read_user()</code> 和 <code>bpf_probe_read_user_str()</code>BPF 帮助程序完成的，因此应该传递一个用户态指针。</p>
<h3 id="capturing-btf-type-ids">Capturing BTF type IDs</h3>
<p>如果您熟悉 <a href="https://nakryiko.com/posts/btf-dedup">BTF</a>，您就会知道 BTF 中的任何类型定义都有相应的 BTF 类型 ID。无论是出于调试和日志记录目的，还是作为某些 BPF API 的一部分，了解 BPF 程序正在使用的类型/字段/枚举的 BTF 类型 IDs 都可能很重要。BPF CO-RE 提供了一种从 BPF 程序代码内部将这些 BTF 类型 ID 捕获为整数值的方法。实际上，它提供了一种捕获两个不同BTF类型ID的方法。一个用于目标内核 BTF（内核类型 ID），另一个用于 BPF 程序自己的 BTF（本地类型 ID）：</p>
<ul>
<li><code>bpf_core_type_id_kernel()</code>返回内核中运行的 BTF类型的 ID;</li>
<li><code>bpf_core_type_id_local()</code>返回编译器在 BPF 程序编译期间捕获的类型 ID。</li>
</ul>
<p>请注意，在 BPF CO-RE 重定位中总是涉及两种 BTF 类型。其中一个是 BPF 程序的<strong>本地类型定义期望</strong>（例如，<code>vmlinux.h</code> 类型或者带有 <code>preserve_access_index</code> 属性的<a href="https://nakryiko.com/posts/bpf-core-reference-guide/#defining-own-co-re-relocatable-type-definitions">手动定义的类型</a>）。这种本地 BTF 类型为 libbpf 提供了在内核 BTF 中搜索的手段。因此，它可以是类型/字段/枚举的最小定义，只包含必要的字段和枚举子集。</p>
<p>然后，Libbpf 可以使用本地 BTF 类型定义来查找匹配的实际完整内核 BTF 类型。上述辅助程序允许捕获 CO-RE 重新定位中涉及的两种类型的 BTF 类型 ID。它们可用于在运行时区分不同的内核或本地类型，用于调试和日志记录目的，或者可能用于将来接受 BTF 类型 ID 作为输入参数的 BPF API。这样的 API 还不存在，但它们肯定会在不久的将来出现。</p>
<h2 id="结束语">结束语</h2>
<p>我希望这篇博客能提供足够的信息以及实用指导能让你更有效的使用BPF CO-RE技术。请随意地创造性地使用它来满足您的 BPF 需求。如果有什么地方看起来不对劲或不起作用，请向 <a href="http://vger.kernel.org/vger-lists.html#bpf">BPF 邮件列表</a>报告问题。</p>

  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/ebpf/" class="tag-link">EBPF</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/linux/" class="tag-link">Linux</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E7%BF%BB%E8%AF%91/" class="tag-link">翻译</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/kernel/" class="tag-link">Kernel</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
