<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.0">

  <title>Effective Modern C&#43;&#43; 读书笔记之第一章 &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="Effective Modern C&#43;&#43; 读书笔记之第一章">
  <meta itemprop="description" content="Item 1: 模板类型推导 C&#43;&#43;98只有一种模板参数类型推导即函数模板参数类型推导，但是在C&#43;&#43;11之后，修改了原有的类型推导规则，并加入了auto和decltype的推导规则。 函数模板形如：
template&lt;typename T&gt; void f(ParamType param);// ParamType可以是T加上各种修饰，如const， reference，指针等 然后在程序逻辑中调用该函数：">
  <meta itemprop="datePublished" content="2025-01-07T18:34:39+08:00">
  <meta itemprop="dateModified" content="2025-01-07T18:34:39+08:00">
  <meta itemprop="wordCount" content="927">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="C&#43;&#43;,读书笔记">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="Effective Modern C&#43;&#43; 读书笔记之第一章">
  <meta name="twitter:description" content="Item 1: 模板类型推导 C&#43;&#43;98只有一种模板参数类型推导即函数模板参数类型推导，但是在C&#43;&#43;11之后，修改了原有的类型推导规则，并加入了auto和decltype的推导规则。 函数模板形如：
template&lt;typename T&gt; void f(ParamType param);// ParamType可以是T加上各种修饰，如const， reference，指针等 然后在程序逻辑中调用该函数：">


<meta property="og:url" content="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="Effective Modern C&#43;&#43; 读书笔记之第一章">
  <meta property="og:description" content="Item 1: 模板类型推导 C&#43;&#43;98只有一种模板参数类型推导即函数模板参数类型推导，但是在C&#43;&#43;11之后，修改了原有的类型推导规则，并加入了auto和decltype的推导规则。 函数模板形如：
template&lt;typename T&gt; void f(ParamType param);// ParamType可以是T加上各种修饰，如const， reference，指针等 然后在程序逻辑中调用该函数：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-07T18:34:39+08:00">
    <meta property="article:modified_time" content="2025-01-07T18:34:39+08:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="读书笔记">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/#webpage",
      "url": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/",
      "name": "Effective Modern C++ 读书笔记之第一章",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2025-01-07T18:34:39+08:00",
      "dateModified": "2025-01-07T18:34:39+08:00",
      "description": "\u003ch2 id=\"item-1-模板类型推导\"\u003eItem 1: 模板类型推导\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eC++98\u003c/code\u003e只有一种模板参数类型推导即函数模板参数类型推导，但是在\u003ccode\u003eC++11\u003c/code\u003e之后，修改了原有的类型推导规则，并加入了\u003ccode\u003eauto\u003c/code\u003e和\u003ccode\u003edecltype\u003c/code\u003e的推导规则。\n函数模板形如：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#ff79c6\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#ff79c6\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003evoid\u003c/span\u003e f(ParamType param);\u003cspan style=\"color:#6272a4\"\u003e// ParamType可以是T加上各种修饰，如const， reference，指针等\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后在程序逻辑中调用该函数：\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/#webpage"
      },
      "headline": "Effective Modern C++ 读书笔记之第一章",
      "datePublished": "2025-01-07T18:34:39+08:00",
      "dateModified": "2025-01-07T18:34:39+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "C++",
        "读书笔记"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#item-1-模板类型推导">Item 1: 模板类型推导</a>
          <ul>
            <li><a href="#case-1-paramtype是指针或者引用类型-但不是universal-reference">Case 1: <code>ParamType</code>是指针或者引用类型, 但不是<code>universal reference</code></a></li>
            <li><a href="#case-2-paramtype-是-universal-reference类型">Case 2: <code>ParamType</code> 是 <code>universal reference</code>类型</a></li>
            <li><a href="#case-3-paramtype-既不是指针又不是引用">Case 3: <code>ParamType</code> 既不是指针又不是引用</a></li>
          </ul>
        </li>
        <li><a href="#item-2-auto类型推导">Item 2: auto类型推导</a></li>
        <li><a href="#item-3-理解decltype">Item 3: 理解decltype</a></li>
        <li><a href="#item-4-如何查看推导后的类型">Item 4: 如何查看推导后的类型</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">Effective Modern C&#43;&#43; 读书笔记之第一章</h1>
  
  

  <div class="post-date">
    <time datetime=" 2025-01-07T18:34:39&#43;0800">Created: Jan 7, 2025</time>
    <span class="readtime">&middot; 5 min read</span>
  </div>

  <div>
    <h2 id="item-1-模板类型推导">Item 1: 模板类型推导</h2>
<p><code>C++98</code>只有一种模板参数类型推导即函数模板参数类型推导，但是在<code>C++11</code>之后，修改了原有的类型推导规则，并加入了<code>auto</code>和<code>decltype</code>的推导规则。
函数模板形如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(ParamType param);<span style="color:#6272a4">// ParamType可以是T加上各种修饰，如const， reference，指针等
</span></span></span></code></pre></div><p>然后在程序逻辑中调用该函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>f(expr); <span style="color:#6272a4">// expr为传入到函数f中的参数
</span></span></span></code></pre></div><p>在编译器进行编译的时候，编译器通过<code>expr</code>来进行两部分的推导：<code>ParamType</code> 和 <code>T</code>。
<code>ParamType</code>有三种不同的形式：</p>
<ol>
<li>当<code>ParamType</code>是指针或者引用的类型，但不是<code>universal reference</code>类型（这个会在<a href="wwww.zhangzewen.net">Item 24</a>讲到）。</li>
<li>当<code>ParamType</code>是<code>universal reference</code>类型</li>
<li>当<code>ParamType</code>既不是指针也不是引用类型。</li>
</ol>
<p>下面依次详解<code>ParamType</code>在不同形式下，参数推导的机制。</p>
<h3 id="case-1-paramtype是指针或者引用类型-但不是universal-reference">Case 1: <code>ParamType</code>是指针或者引用类型, 但不是<code>universal reference</code></h3>
<p>对于此种情况下，推导的机制如下：</p>
<ol>
<li>如果<code>expr</code>的类型是个引用，忽视该引用， 同样也适用于指针。</li>
<li>通过对<code>expr</code>的类型进行<code>ParamType</code>的模式匹配，来确定<code>T</code>的参数类型</li>
</ol>
<p>例如, 模板如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(T<span style="color:#ff79c6">&amp;</span> param); <span style="color:#6272a4">// ParamType 为 T&amp;
</span></span></span></code></pre></div><p>有如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">int</span> x <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">27</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">int</span> cx <span style="color:#ff79c6">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">int</span><span style="color:#ff79c6">&amp;</span> rx <span style="color:#ff79c6">=</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(x);  <span style="color:#6272a4">// T =&gt; int , ParamType =&gt; int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(cx); <span style="color:#6272a4">// T =&gt; const int, ParamType =&gt; const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(rx); <span style="color:#6272a4">// T =&gt; const int, ParamType =&gt; const int&amp;
</span></span></span></code></pre></div><p>可以看到，即使<code>rx</code>的类型是引用，T也被推断为非引用。这是因为在类型推导期间忽略了<code>rx</code>的引性。
如果把模板中的<code>T&amp;</code> 换成 <code>const T&amp;</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(<span style="color:#ff79c6">const</span> T<span style="color:#ff79c6">&amp;</span> param);
</span></span></code></pre></div><p>有如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>f(x);  <span style="color:#6272a4">// T =&gt; int, ParamType =&gt; const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(cx); <span style="color:#6272a4">// T =&gt; int, ParamType =&gt; const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(rx); <span style="color:#6272a4">// T =&gt;int,  ParamType =&gt; const int&amp;
</span></span></span></code></pre></div><p>这时候<code>const</code>将会被忽略掉。</p>
<h3 id="case-2-paramtype-是-universal-reference类型">Case 2: <code>ParamType</code> 是 <code>universal reference</code>类型</h3>
<p>对于此类型的推导规则如下：</p>
<ol>
<li>如果<code>expr</code>是左值， <code>T</code>和<code>ParamType</code>都推导为左值引用。</li>
<li>如果<code>expr</code>是右值， 推导规则参照上面的<code>Case 1</code>, 需要注意的是这里是右值引用<code>T&amp;&amp;</code>。</li>
</ol>
<p>模板形如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span> <span style="color:#8be9fd">void</span> f(T<span style="color:#ff79c6">&amp;&amp;</span> param);
</span></span></code></pre></div><p>有如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>f(x); <span style="color:#6272a4">// x 是左值, T =&gt; int&amp;, ParamType =&gt; int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(cx); <span style="color:#6272a4">// cx 是左值， T =&gt; const int&amp;, ParamType =&gt; const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(rx); <span style="color:#6272a4">// rx 是左值， T =&gt; const int&amp;, ParamType =&gt; const int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(<span style="color:#bd93f9">27</span>); <span style="color:#6272a4">// 27 是右值， T =&gt; int, ParamType =&gt; int&amp;&amp;
</span></span></span></code></pre></div><h3 id="case-3-paramtype-既不是指针又不是引用">Case 3: <code>ParamType</code> 既不是指针又不是引用</h3>
<p>模板形如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(T param);
</span></span></code></pre></div><p>对于这种类型，函数模板的类型推导规则如下：</p>
<ol>
<li>如果<code>expr</code>的引用类型，忽略引用。</li>
<li>在忽略了引用后，如果<code>expr</code>还有<code>const</code> 或者 <code>volatile</code>， 也忽略。</li>
</ol>
<p>如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>f(x);  <span style="color:#6272a4">// T =&gt; int, ParamType =&gt; int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(cx); <span style="color:#6272a4">// T =&gt; int, ParamType =&gt; int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(rx); <span style="color:#6272a4">// T =&gt; int, ParamType =&gt; int
</span></span></span></code></pre></div><p>因为模板中是按值传入参数， 即复制，进入函数的参数在复制后和原来的参数无关了，所以 附加在参数上的 <code>const</code> 和 <code>volatile</code> 已经失去作用。但是需要注意的是，对于指针<code>const</code> 和 <code>volatile</code>等修饰是会保留的，
毕竟操作的是内存，且<code>T</code>和 <code>ParamType</code>的推导结果都是一样的，如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">int</span> x <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">27</span>;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>px <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">volatile</span> <span style="color:#8be9fd">int</span><span style="color:#ff79c6">*</span> vx <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">int</span><span style="color:#ff79c6">*</span> cx <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>x;
</span></span><span style="display:flex;"><span>f(x);   <span style="color:#6272a4">// T =&gt; int, ParamType =&gt; int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(px);  <span style="color:#6272a4">// T =&gt; int*, ParamType =&gt; int*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(vx);  <span style="color:#6272a4">// T =&gt; volatile int*, ParamType =&gt; volatile int*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(cx);  <span style="color:#6272a4">// T =&gt; const int*, ParamType =&gt; const int*
</span></span></span></code></pre></div><p>数组在某种意义上是指针，但是又和指针有所不同，但是在作为参数传递到函数时，数组会退化成指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> name [] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;J. P. Briggs&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> ptrToName <span style="color:#ff79c6">=</span> names;
</span></span></code></pre></div><p>在上面的代码中，<code>name</code>的类型为<code>const char[13]</code>，而<code>ptrToName</code>的数据类型为<code>const char*</code>，二者是不相同的。但是作为参数传递到函数，下面是等价的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">f</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> buf);
</span></span><span style="display:flex;"><span>f(name);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//等价于
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(ptrToName)
</span></span></code></pre></div><p>如果有函数模版：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(T param);
</span></span><span style="display:flex;"><span>f(name);
</span></span></code></pre></div><p>数组作为参数传递，在这里模板函数的的参数推导可以参照<code>Case 3</code>，即<code>T</code>就是<code>const char*</code>, <code>ParamType</code>就是<code>const char*</code>。</p>
<p>但是如果函数模版如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(T<span style="color:#ff79c6">&amp;</span> param);
</span></span><span style="display:flex;"><span>f(name);
</span></span></code></pre></div><p>此时，在这里通过<code>const char[13]</code>来给<code>T</code>进行类型推导，所以<code>f</code>的参数的类型的推导为<code>const char (&amp;)[13]</code>(即<code>ParamType</code>)，即引用一个类型为<code>const char[13]</code>(即<code>T</code>)的数组。
可以根据这个特性，写一个通用的获取数据大小的函数模版：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T, std<span style="color:#ff79c6">::</span>size_t N<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">constexpr</span> std<span style="color:#ff79c6">::</span>size_t arraySize(T (<span style="color:#ff79c6">&amp;</span>)[N])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> N;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于函数，情况和数组类似：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">target</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> name);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(T param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(target); <span style="color:#6272a4">// ParamType 和 T 会被推导为 void(*)(const char* name);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">///////////////
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(T<span style="color:#ff79c6">&amp;</span> param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f(target); <span style="color:#6272a4">// ParamType被推导为 void (&amp;)(const char*), T 被推导为 void (const char*)
</span></span></span></code></pre></div><h2 id="item-2-auto类型推导">Item 2: auto类型推导</h2>
<p><code>c++11</code>新的<code>auto</code>关键词可以通过变量的初始化来推断参数的数据类型，具体看<a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-two/">Effective Modern C++ 读书笔记之第二章</a>。<code>auto</code>的类型推导和模版参数推导是一一对应的，在<code>Item 1</code>中，通用的模板定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> f(ParamType param);
</span></span></code></pre></div><p>通用的调用如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>f(expr)
</span></span></code></pre></div><p>模板参数类型推到是通过<code>expr</code>来推到<code>T</code>和<code>ParamType</code>。
一般通过<code>auto</code>关键字来声明变量的形式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> x <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">27</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span> cx <span style="color:#ff79c6">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;</span> rx <span style="color:#ff79c6">=</span> x;
</span></span><span style="display:flex;"><span>``` 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>和模板类型推到对比来看， `<span style="color:#ff79c6">auto</span>`就相当于是上面的`T`，变量名左边的<span style="color:#ff79c6">**</span>类型<span style="color:#ff79c6">**</span>就相当于`ParamType`。
</span></span><span style="display:flex;"><span>```cpp
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> x <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">27</span>;
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//相当于
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> func_for_x(T param)
</span></span><span style="display:flex;"><span>func_fo_x(<span style="color:#bd93f9">27</span>);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span> cx <span style="color:#ff79c6">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//相当于
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> func_fo_cx(<span style="color:#ff79c6">const</span> T param)
</span></span><span style="display:flex;"><span>func_for_cx(x);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;</span> rx <span style="color:#ff79c6">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> func_for_rx(<span style="color:#ff79c6">const</span> T<span style="color:#ff79c6">&amp;</span> param)
</span></span><span style="display:flex;"><span>func_for_rx(x);
</span></span></code></pre></div><p>所以，类似于<code>Item 1</code>所讲的三个模版参数类型推导的策略，<code>auto</code>的参数类型推导也有三个策略：</p>
<ol>
<li>类型是指针或者引用，但是不是<code>universal reference</code></li>
<li>类型是<code>universal reference</code></li>
<li>类型既不是引用也不是指针
这三种情况下的参数推导规则和<code>Item 1</code>中的三种情况下的推导规则相同，如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> x <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">27</span>;       <span style="color:#6272a4">// case 3 x的类型是 int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span> cx <span style="color:#ff79c6">=</span> x; <span style="color:#6272a4">// case 3, x的类型是 int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;</span> rx <span style="color:#ff79c6">=</span> x;<span style="color:#6272a4">// case 1, x的类型是 int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;&amp;</span> uref1 <span style="color:#ff79c6">=</span> x;  <span style="color:#6272a4">// case 2 x是左值，uref1的类型是 int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;&amp;</span> uref2 <span style="color:#ff79c6">=</span> cx; <span style="color:#6272a4">// case 2 cx是左值，uref2的类型是 int&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;&amp;</span> uref3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">27</span>; <span style="color:#6272a4">// case 3 27是右值，uref3的类型是 int&amp;&amp;
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> name[] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;R. N. Briggs&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> arr1 <span style="color:#ff79c6">=</span> name; <span style="color:#6272a4">// arr1&#39;s type is const char*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;</span> arr2 <span style="color:#ff79c6">=</span> name;<span style="color:#6272a4">// arr2&#39;s type is const char(&amp;)[13]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">someFunc</span>(<span style="color:#8be9fd">int</span>, <span style="color:#8be9fd">double</span>);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> func1 <span style="color:#ff79c6">=</span> someFunc; <span style="color:#6272a4">// func1&#39;s type is void(*)(int, double)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">auto</span><span style="color:#ff79c6">&amp;</span> func2 <span style="color:#ff79c6">=</span> someFunc; <span style="color:#6272a4">// func2&#39;s type is void(&amp;)(int, double)
</span></span></span></code></pre></div><p>虽然<code>auto</code>的类型推到和模板参数类型推导一一对应，但是 <code>auto</code>在下面的情况下使用的是<code>auto</code>自己的一套类型推到规则。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> x2{<span style="color:#bd93f9">27</span>};
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> x3 <span style="color:#ff79c6">=</span> {<span style="color:#bd93f9">27</span>};
</span></span></code></pre></div><p>如果<code>auto</code>变量是通过<a href="http://en.cppreference.com/w/cpp/language/aggregate_initialization">aggregate initialization</a>来进初始化的时候，此时<code>auto</code>变量会被推导为<code>std::initializer_list&lt;int&gt;</code>
而不是<code>int</code>。这个推导分两步进行，第一步是推导成<code>std::initializer_list&lt;T&gt;</code>, 然后根据大括号中的值推导<code>T</code>。
需要记住的是，<code>auto</code>作为函数的返回值或者<code>lambda</code>表达式的参数是使用的是模板参数推导，而不是<code>auto</code>自己的类型推导策略。</p>
<h2 id="item-3-理解decltype">Item 3: 理解decltype</h2>
<p><code>decltype</code>是由<code>C++11</code>引入， <code>decltype</code>可以推断出变量或者表达式所属的数据类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">const</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;  <span style="color:#6272a4">// decltype(i) ==&gt; const int
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">bool</span> <span style="color:#50fa7b">f</span>(<span style="color:#ff79c6">const</span> Widget<span style="color:#ff79c6">&amp;</span> w); <span style="color:#6272a4">// decltype(w) ==&gt; const Widget&amp;, decltype(f) ==&gt; bool(const Widget&amp;)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>Widget w; <span style="color:#6272a4">// decltype(w) ==&gt; Widget
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>f(w); <span style="color:#6272a4">// decltype(f(w)) ==&gt; bool
</span></span></span></code></pre></div><p>在C++11中<code>decltype</code>主要用在返回值类型依赖输入的参数类型的函数模板中，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> Container, <span style="color:#ff79c6">typename</span> Index<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> authAndAccess(Container<span style="color:#ff79c6">&amp;</span> c, Index i)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">-&gt;</span> <span style="color:#ff79c6">decltype</span>(c[i])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    authenticateUser();
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> c[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在C++11中，上面的这段代码中的<code>auto</code>并不会进行类型推导，它只是表明该处使用的是C++11的<a href="https://en.cppreference.com/w/cpp/language/function">函数返回类型后置</a>语法。
C++11允许推导只有单个返回语句的lambda表达式，而C++14将其扩展到所有lambda和所有函数，包括具有多个返回语句的函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> Container, <span style="color:#ff79c6">typename</span> Index<span style="color:#ff79c6">&gt;</span> <span style="color:#6272a4">// C++14
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">auto</span> authAndAccess(Container<span style="color:#ff79c6">&amp;</span> c, Index i)    <span style="color:#6272a4">// not quite
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>{                                            <span style="color:#6272a4">// correct
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  authenticateUser();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> c[i];                               <span style="color:#6272a4">// return type deduced from c[i]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>场景如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#ff79c6">::</span>deque<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;</span> d;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>authAndAccess(d, <span style="color:#bd93f9">5</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10</span>; <span style="color:#6272a4">// authenticate user, return d[5],
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                          <span style="color:#6272a4">// then assign 10 to it;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                          <span style="color:#6272a4">// this won&#39;t compile!
</span></span></span></code></pre></div><p>已知<code>c[5]</code>的类型是<code>int&amp;</code>, 但是根据上面的<code>auto</code>的推导逻辑，引用会被忽略掉， 所以才会导致<code>authAndAccess(d, 5) = 10</code>出错。正确的做法是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> Container, <span style="color:#ff79c6">typename</span> Index<span style="color:#ff79c6">&gt;</span>   <span style="color:#6272a4">// c++14;works
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">decltype</span>(<span style="color:#ff79c6">auto</span>)                                 <span style="color:#6272a4">// but still
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>authAndAccess(Container<span style="color:#ff79c6">&amp;</span> c, Index i)           <span style="color:#6272a4">// requires
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>{                                              <span style="color:#6272a4">// refinment
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  authenticateUser();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> c[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样，对于变量的初始化也适用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Widget w;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> Widget<span style="color:#ff79c6">&amp;</span> cw <span style="color:#ff79c6">=</span> w;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span> myWidget1 <span style="color:#ff79c6">=</span> cw; <span style="color:#6272a4">// auto type deduction:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                     <span style="color:#6272a4">// myWidget1&#39;s type is Widget
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">decltype</span>(<span style="color:#ff79c6">auto</span>) myWidget2 <span style="color:#ff79c6">=</span> cw; <span style="color:#6272a4">// decltype type deduction:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                               <span style="color:#6272a4">// myWidget2&#39;s type is
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                               <span style="color:#6272a4">// const Widget&amp;
</span></span></span></code></pre></div><p>再次优化，使用移动语义来处理传入的容器参数，毕竟拷贝还是比较耗时间的，对于<code>std::forward</code>，
可以查看<a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/">Effective Modern C++ 读书笔记之第五章</a>来辅助对下面代码进行理解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// for c++14
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> Container, <span style="color:#ff79c6">typename</span> Index<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">decltype</span>(<span style="color:#ff79c6">auto</span>)
</span></span><span style="display:flex;"><span>authAndAccess(Container<span style="color:#ff79c6">&amp;&amp;</span> c, Index i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  authenticateUser();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> std<span style="color:#ff79c6">::</span>forward<span style="color:#ff79c6">&lt;</span>Container<span style="color:#ff79c6">&gt;</span>(c)[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// for c++11
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> Container, <span style="color:#ff79c6">typename</span> Index<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">auto</span>
</span></span><span style="display:flex;"><span>authAndAccess(Container<span style="color:#ff79c6">&amp;&amp;</span> c, Index i)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">-&gt;</span> <span style="color:#ff79c6">decltype</span>(std<span style="color:#ff79c6">::</span>forward<span style="color:#ff79c6">&lt;</span>Container<span style="color:#ff79c6">&gt;</span>(c)[i])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  authenticateUser();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> std<span style="color:#ff79c6">::</span>forward<span style="color:#ff79c6">&lt;</span>Container<span style="color:#ff79c6">&gt;</span>(c)[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="item-4-如何查看推导后的类型">Item 4: 如何查看推导后的类型</h2>
<ul>
<li>
<p>通过IDE，这个没啥好说的</p>
</li>
<li>
<p>人为制造编译错误</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>       <span style="color:#6272a4">// declaration only for TD;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">TD</span>;                  <span style="color:#6272a4">// TD == &#34;Type Displayer&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>TD<span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">decltype</span>(x)<span style="color:#ff79c6">&gt;</span> xType;     <span style="color:#6272a4">// elicit errors containing
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>TD<span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">decltype</span>(y)<span style="color:#ff79c6">&gt;</span> yType;     <span style="color:#6272a4">// x&#39;s and y&#39;s types
</span></span></span></code></pre></div><p>编译时出错信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>error: aggregate <span style="color:#f1fa8c">&#39;TD&lt;int&gt; xType&#39;</span> has incomplete <span style="color:#8be9fd;font-style:italic">type</span> and cannot be defined
</span></span><span style="display:flex;"><span>error: aggregate <span style="color:#f1fa8c">&#39;TD&lt;const int *&gt; yType&#39;</span> has incomplete <span style="color:#8be9fd;font-style:italic">type</span> and cannot be defined 
</span></span></code></pre></div></li>
<li>
<p>运行时打印日志</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#ff79c6">typeid</span>(x).name() <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#39;\n&#39;</span>; <span style="color:#6272a4">// display types for
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#ff79c6">typeid</span>(y).name() <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#39;\n&#39;</span>; <span style="color:#6272a4">// x and y
</span></span></span></code></pre></div><p>除此之外，还可以借助<code>boost</code>库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;boost/type_index.hpp&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>   <span style="color:#ff79c6">template</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">typename</span> T<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#8be9fd">void</span> f(<span style="color:#ff79c6">const</span> T<span style="color:#ff79c6">&amp;</span> param)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>     <span style="color:#ff79c6">using</span> std<span style="color:#ff79c6">::</span>cout;
</span></span><span style="display:flex;"><span>     <span style="color:#ff79c6">using</span> boost<span style="color:#ff79c6">::</span>typeindex<span style="color:#ff79c6">::</span>type_id_with_cvr;
</span></span><span style="display:flex;"><span>     <span style="color:#6272a4">// show T
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>     cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;T = &#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">&lt;&lt;</span> type_id_with_cvr<span style="color:#ff79c6">&lt;</span>T<span style="color:#ff79c6">&gt;</span>().pretty_name() <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#6272a4">// show param&#39;s type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>     cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;param = &#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">&lt;&lt;</span> type_id_with_cvr<span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">decltype</span>(param)<span style="color:#ff79c6">&gt;</span>().pretty_name()
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#39;\n&#39;</span>; ...
</span></span><span style="display:flex;"><span>   }
</span></span></code></pre></div></li>
</ul>

  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/c&#43;&#43;/" class="tag-link">C&#43;&#43;</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="tag-link">读书笔记</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
