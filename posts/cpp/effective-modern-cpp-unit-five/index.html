<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.1">

  <title>Effective Modern C&#43;&#43; 读书笔记之第五章 &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="Effective Modern C&#43;&#43; 读书笔记之第五章">
  <meta itemprop="description" content="Item 23: std::move 和 std::forward语义 Item23开篇就直接说明了std::move不移动任何变量，std::forward不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c&#43;&#43;的类型转换)，std::move无条件的把它的参数转换为一个右值，但是std::forward只有在满足一定条件下才会做转换工作。 书中为std::move的实现，写了一个伪码：
template&lt;typename T&gt; // in namespace std typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) { using ReturnType = // alias declaration; typename remove_reference&lt;T&gt;::type&amp;&amp;; // see Item 9 return static_cast&lt;ReturnType&gt;(param); } 在这段代码中，返回值类型为typename remove_reference&lt;T&gt;::type&amp;&amp;说明 std::move返回的是一个右值引用。函数move的参数类型为T&amp;&amp;，具体来说这个一个universal reference(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用std::remove_reference剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是’公理’右值引用坐作函数的返回值返回后是右值。 需要注意的是如果std::move的参数如果是a reference-to-const的话，虽然通过移动语义的作用，使其转换成了右值，但是const语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。">
  <meta itemprop="datePublished" content="2025-02-18T18:34:43+08:00">
  <meta itemprop="dateModified" content="2025-02-18T18:34:43+08:00">
  <meta itemprop="wordCount" content="564">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="C&#43;&#43;,读书笔记">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="Effective Modern C&#43;&#43; 读书笔记之第五章">
  <meta name="twitter:description" content="Item 23: std::move 和 std::forward语义 Item23开篇就直接说明了std::move不移动任何变量，std::forward不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c&#43;&#43;的类型转换)，std::move无条件的把它的参数转换为一个右值，但是std::forward只有在满足一定条件下才会做转换工作。 书中为std::move的实现，写了一个伪码：
template&lt;typename T&gt; // in namespace std typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) { using ReturnType = // alias declaration; typename remove_reference&lt;T&gt;::type&amp;&amp;; // see Item 9 return static_cast&lt;ReturnType&gt;(param); } 在这段代码中，返回值类型为typename remove_reference&lt;T&gt;::type&amp;&amp;说明 std::move返回的是一个右值引用。函数move的参数类型为T&amp;&amp;，具体来说这个一个universal reference(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用std::remove_reference剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是’公理’右值引用坐作函数的返回值返回后是右值。 需要注意的是如果std::move的参数如果是a reference-to-const的话，虽然通过移动语义的作用，使其转换成了右值，但是const语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。">


<meta property="og:url" content="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="Effective Modern C&#43;&#43; 读书笔记之第五章">
  <meta property="og:description" content="Item 23: std::move 和 std::forward语义 Item23开篇就直接说明了std::move不移动任何变量，std::forward不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c&#43;&#43;的类型转换)，std::move无条件的把它的参数转换为一个右值，但是std::forward只有在满足一定条件下才会做转换工作。 书中为std::move的实现，写了一个伪码：
template&lt;typename T&gt; // in namespace std typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) { using ReturnType = // alias declaration; typename remove_reference&lt;T&gt;::type&amp;&amp;; // see Item 9 return static_cast&lt;ReturnType&gt;(param); } 在这段代码中，返回值类型为typename remove_reference&lt;T&gt;::type&amp;&amp;说明 std::move返回的是一个右值引用。函数move的参数类型为T&amp;&amp;，具体来说这个一个universal reference(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用std::remove_reference剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是’公理’右值引用坐作函数的返回值返回后是右值。 需要注意的是如果std::move的参数如果是a reference-to-const的话，虽然通过移动语义的作用，使其转换成了右值，但是const语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-18T18:34:43+08:00">
    <meta property="article:modified_time" content="2025-02-18T18:34:43+08:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="读书笔记">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/#webpage",
      "url": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/",
      "name": "Effective Modern C++ 读书笔记之第五章",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2025-02-18T18:34:43+08:00",
      "dateModified": "2025-02-18T18:34:43+08:00",
      "description": "\u003ch2 id=\"item-23-stdmove-和-stdforward语义\"\u003eItem 23: std::move 和 std::forward语义\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eItem23\u003c/code\u003e开篇就直接说明了\u003ccode\u003estd::move\u003c/code\u003e不移动任何变量，\u003ccode\u003estd::forward\u003c/code\u003e不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c++的类型转换)，\u003ccode\u003estd::move\u003c/code\u003e无条件的把它的参数转换为一个右值，但是\u003ccode\u003estd::forward\u003c/code\u003e只有在满足一定条件下才会做转换工作。\n书中为\u003ccode\u003estd::move\u003c/code\u003e的实现，写了一个伪码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fe8019\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#fe8019\"\u003e\u0026gt;\u003c/span\u003e                              \u003cspan style=\"color:#928374;font-style:italic\"\u003e// in namespace std\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#928374;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003etypename\u003c/span\u003e remove_reference\u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#fe8019\"\u003e\u0026gt;::\u003c/span\u003etype\u003cspan style=\"color:#fe8019\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emove(T\u003cspan style=\"color:#fe8019\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e param)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fe8019\"\u003eusing\u003c/span\u003e ReturnType \u003cspan style=\"color:#fe8019\"\u003e=\u003c/span\u003e                            \u003cspan style=\"color:#928374;font-style:italic\"\u003e// alias declaration;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#928374;font-style:italic\"\u003e\u003c/span\u003e        \u003cspan style=\"color:#fe8019\"\u003etypename\u003c/span\u003e remove_reference\u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#fe8019\"\u003e\u0026gt;::\u003c/span\u003etype\u003cspan style=\"color:#fe8019\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e;     \u003cspan style=\"color:#928374;font-style:italic\"\u003e// see Item 9\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#928374;font-style:italic\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#fe8019\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fe8019\"\u003estatic_cast\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u003c/span\u003eReturnType\u003cspan style=\"color:#fe8019\"\u003e\u0026gt;\u003c/span\u003e(param);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这段代码中，返回值类型为\u003ccode\u003etypename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u003c/code\u003e说明 \u003ccode\u003estd::move\u003c/code\u003e返回的是一个右值引用。函数\u003ccode\u003emove\u003c/code\u003e的参数类型为\u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e，具体来说这个一个\u003ccode\u003euniversal reference\u003c/code\u003e(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用\u003ca href=\"http://en.cppreference.com/w/cpp/types/remove_reference\"\u003estd::remove_reference\u003c/a\u003e剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是\u0026rsquo;公理\u0026rsquo;\u003ccode\u003e右值引用坐作函数的返回值返回后是右值\u003c/code\u003e。\n需要注意的是如果\u003ccode\u003estd::move\u003c/code\u003e的参数如果是\u003ccode\u003ea reference-to-const\u003c/code\u003e的话，虽然通过移动语义的作用，使其转换成了右值，但是\u003ccode\u003econst\u003c/code\u003e语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/#webpage"
      },
      "headline": "Effective Modern C++ 读书笔记之第五章",
      "datePublished": "2025-02-18T18:34:43+08:00",
      "dateModified": "2025-02-18T18:34:43+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "C++",
        "读书笔记"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-five/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#item-23-stdmove-和-stdforward语义">Item 23: std::move 和 std::forward语义</a></li>
        <li><a href="#item-24-区分universal-references和右值引用">Item 24: 区分Universal references和右值引用</a></li>
        <li><a href="#item-25-在右值引用上使用stdmove在universal-references上使用stdforward">Item 25: 在右值引用上使用std::move，在Universal references上使用std::forward</a></li>
        <li><a href="#item-26-避免重载-universal-references">Item 26: 避免重载 Universal references</a></li>
        <li><a href="#item-27-熟悉使用除了通用引用外的其他替代方案">Item 27: 熟悉使用除了通用引用外的其他替代方案</a></li>
        <li><a href="#item-28-理解引用折叠">Item 28: 理解引用折叠</a></li>
        <li><a href="#item-29-假设移动操作不可用成本高昂且未被使用">Item 29: 假设移动操作不可用、成本高昂且未被使用</a></li>
        <li><a href="#item-30-熟悉完美转发失败的情况">Item 30: 熟悉完美转发失败的情况</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">Effective Modern C&#43;&#43; 读书笔记之第五章</h1>
  
  

  <div class="post-date">
    <time datetime=" 2025-02-18T18:34:43&#43;0800">Created: Feb 18, 2025</time>
    <span class="readtime">&middot; 3 min read</span>
  </div>

  <div>
    <h2 id="item-23-stdmove-和-stdforward语义">Item 23: std::move 和 std::forward语义</h2>
<p><code>Item23</code>开篇就直接说明了<code>std::move</code>不移动任何变量，<code>std::forward</code>不转发任何变量，这两个语义仅仅做的是转换的工作(类似c/c++的类型转换)，<code>std::move</code>无条件的把它的参数转换为一个右值，但是<code>std::forward</code>只有在满足一定条件下才会做转换工作。
书中为<code>std::move</code>的实现，写了一个伪码：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>                              <span style="color:#928374;font-style:italic">// in namespace std
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fe8019">typename</span> remove_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>move(T<span style="color:#fe8019">&amp;&amp;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">using</span> ReturnType <span style="color:#fe8019">=</span>                            <span style="color:#928374;font-style:italic">// alias declaration;
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>        <span style="color:#fe8019">typename</span> remove_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&amp;&amp;</span>;     <span style="color:#928374;font-style:italic">// see Item 9
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>    <span style="color:#fe8019">return</span> <span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>ReturnType<span style="color:#fe8019">&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这段代码中，返回值类型为<code>typename remove_reference&lt;T&gt;::type&amp;&amp;</code>说明 <code>std::move</code>返回的是一个右值引用。函数<code>move</code>的参数类型为<code>T&amp;&amp;</code>，具体来说这个一个<code>universal reference</code>(后面会说到),如果传入的参数T是一个左值引用的话，参数推导的结果仍然是一个左值引用，调用<a href="http://en.cppreference.com/w/cpp/types/remove_reference">std::remove_reference</a>剔除掉引用来确保右值引用作用在一个不是左值引用的类型上。然后就是&rsquo;公理&rsquo;<code>右值引用坐作函数的返回值返回后是右值</code>。
需要注意的是如果<code>std::move</code>的参数如果是<code>a reference-to-const</code>的话，虽然通过移动语义的作用，使其转换成了右值，但是<code>const</code>语义仍然保存了下来，这时候需要注意如果把其赋值给变量，这里用的就不是移动拷贝语义了，而是用的的赋值拷贝语义。</p>
<p>对于<code>std::forward</code>的语义，上面说了其只有在满足条件达成才会被做转换(参数到底是通过左值还是右值进行初始化)，即，该是右值的继续右值，该是左值的继续左值，书中给了一个列子：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">process</span>(<span style="color:#fe8019">const</span> Widget<span style="color:#fe8019">&amp;</span> lvalParam);
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">process</span>(Widget<span style="color:#fe8019">&amp;&amp;</span> rvalParam);
</span></span><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> logAndProcess(T<span style="color:#fe8019">&amp;&amp;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">auto</span> now <span style="color:#fe8019">=</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>system_clock<span style="color:#fe8019">::</span>now();
</span></span><span style="display:flex;"><span>    makeLogEntry(<span style="color:#b8bb26">&#34;Calling &#39;process&#39;&#34;</span>, now);
</span></span><span style="display:flex;"><span>    process(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;</span>(param));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Widget w;
</span></span><span style="display:flex;"><span>logAndProcess(w);<span style="color:#fe8019">&lt;</span><span style="color:#d3869b">1</span><span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span>logAndProcess(std<span style="color:#fe8019">::</span>move(w));<span style="color:#fe8019">&lt;</span><span style="color:#d3869b">2</span><span style="color:#fe8019">&gt;</span>
</span></span></code></pre></div><p>在上面的代码中&lt;1&gt;处传入的是左值，&lt;2&gt;处传入的是右值，但是不管传入的参数是左值还是右值，在函数内部，这个参数都是有址可寻的，既然有址可寻，那就是左值，在进行调用<code>process</code>函数的时候如果不对参数做<code>std::forward</code>语义的处理，调用<code>process</code>的话，调用的函数肯定是<code>void process(const Widget&amp; lvalParam)</code>, 但传入的参数是左值的话，肯定是随着我们符合预期的，但是传入的是右值的话，在函数内部却当成左值处理，肯定是不行的。这时<code>std::forward</code>语义就有用处了。在&lt;2&gt;中我们传入的是右值，进入函数内部却是左值，通过<code>std::forward</code>语义，其判断参数是通过右值进行初始化，所以会做转换处理，继续保持param的右值语义。使在调用<code>process</code>的时候调用的是<code>void process(Widget&amp;&amp; param)</code>，符合我们的预期。</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span>T<span style="color:#fe8019">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>forward(T<span style="color:#fe8019">&amp;&amp;</span> param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">if</span> (is_lvalue_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>value) {
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">return</span> param;
</span></span><span style="display:flex;"><span>    } <span style="color:#fe8019">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">return</span> <span style="color:#fabd2f">move</span>(param);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="item-24-区分universal-references和右值引用">Item 24: 区分Universal references和右值引用</h2>
<p>不能见到形如<code>T&amp;&amp;</code>就一口认定其为右值引用：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">f</span>(Widget<span style="color:#fe8019">&amp;&amp;</span> param); <span style="color:#928374;font-style:italic">// rvalue reference
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>
</span></span><span style="display:flex;"><span>Widget<span style="color:#fe8019">&amp;&amp;</span> var1 <span style="color:#fe8019">=</span> Widget(); <span style="color:#928374;font-style:italic">// rvalue reference
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">auto</span><span style="color:#fe8019">&amp;&amp;</span> var2 <span style="color:#fe8019">=</span> var1; <span style="color:#928374;font-style:italic">// not rvalue reference, Universal reference
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> f(std<span style="color:#fe8019">::</span>vector<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;&amp;&amp;</span> param); <span style="color:#928374;font-style:italic">// rvalue reference
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> f(T<span style="color:#fe8019">&amp;&amp;</span> param); <span style="color:#928374;font-style:italic">// not rvalue reference
</span></span></span></code></pre></div><p><code>T&amp;&amp;</code>不仅代表这右值引用，而且代表这要么是右值引用要么是左值引用(Universal references), 并且可以附加<code>const</code>或者<code>volatile</code>语义。<code>T&amp;&amp;</code>的语义需要通过参数进行推导的时候，<code>T&amp;&amp;</code>类型的参数通常就是<code>Universal references</code>, 如果不是形如<code>T&amp;&amp;</code>, 那肯定就不是<code>Universal reference</code>了。例如模版以及<code>auto</code>的使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> f(T<span style="color:#fe8019">&amp;&amp;</span> param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">auto</span><span style="color:#fe8019">&amp;&amp;</span> var2 <span style="color:#fe8019">=</span> var1;
</span></span></code></pre></div><p>但是形如：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> f(std<span style="color:#fe8019">::</span>vector<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;&amp;&amp;</span> param);
</span></span></code></pre></div><p><code>param</code>就不是<code>Universal reference</code>了，param就是右值引用，因为它的类型为<code>std::vector&lt;T&gt;&amp;&amp;</code>而不是<code>T&amp;&amp;</code>。另外，下面的这个例子中的param也不是<code>Universal reference</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> f(<span style="color:#fe8019">const</span> T<span style="color:#fe8019">&amp;&amp;</span> param);
</span></span></code></pre></div><h2 id="item-25-在右值引用上使用stdmove在universal-references上使用stdforward">Item 25: 在右值引用上使用std::move，在Universal references上使用std::forward</h2>
<p>参考 <code>Item 24</code>:</p>
<ul>
<li>如果传入的是右值引用，请在最后使用该参数的时候使用<code>std::move</code>, 如果需要该参数还作为返回值(函数的签名是返回 值)返回，也一样使用<code>std::move</code>。</li>
<li>如果传入的是Universal references，请在最后使用该参数的时候使用<code>std::forward</code>, 如果该参数还作为返回值(函数的签名是返回 值)返回，也一样使用<code>std::move</code>。</li>
<li>剩余的情况，请相信编译器的<code>return value optimization (RVO)</code> 优化特性，别一股脑儿套用<code>std::move</code>或者<code>std::forward</code>。</li>
</ul>
<h2 id="item-26-避免重载-universal-references">Item 26: 避免重载 Universal references</h2>
<p>避免重载 Universal references，因为根据重载规则和模板参数推导可能其会被优先调用，有时候会导致错误，书中给了一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span> 
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> logAndAdd(T<span style="color:#fe8019">&amp;&amp;</span> name) {
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">auto</span> now <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>system_clock<span style="color:#fe8019">::</span>now(); 
</span></span><span style="display:flex;"><span>    log(now, <span style="color:#b8bb26">&#34;logAndAdd&#34;</span>); 
</span></span><span style="display:flex;"><span>    names.emplace(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;</span>(name));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std<span style="color:#fe8019">::</span>string petName(<span style="color:#b8bb26">&#34;Darla&#34;</span>);         <span style="color:#928374;font-style:italic">// as before
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>logAndAdd(petName);                   <span style="color:#928374;font-style:italic">// as before, copy
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>                                      <span style="color:#928374;font-style:italic">// lvalue into multiset
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>logAndAdd(std<span style="color:#fe8019">::</span>string(<span style="color:#b8bb26">&#34;Persephone&#34;</span>)); <span style="color:#928374;font-style:italic">// move rvalue instead 
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>                                      <span style="color:#928374;font-style:italic">// of copying it
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>logAndAdd(<span style="color:#b8bb26">&#34;Patty Dog&#34;</span>);               <span style="color:#928374;font-style:italic">// create std::string
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>
</span></span><span style="display:flex;"><span>                                      <span style="color:#928374;font-style:italic">// in multiset instead
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>                                      <span style="color:#928374;font-style:italic">// of copying a temporary
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>                                      <span style="color:#928374;font-style:italic">// std::string
</span></span></span></code></pre></div><p>这里重载了该函数</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#fe8019">::</span>string nameFromIdx(<span style="color:#fabd2f">int</span> idx);      <span style="color:#928374;font-style:italic">// return name
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>                                       <span style="color:#928374;font-style:italic">// corresponding to idx
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">logAndAdd</span>(<span style="color:#fabd2f">int</span> idx)               <span style="color:#928374;font-style:italic">// new overload 
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">auto</span> now <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>system_clock<span style="color:#fe8019">::</span>now();
</span></span><span style="display:flex;"><span>    log(now, <span style="color:#b8bb26">&#34;logAndAdd&#34;</span>); 
</span></span><span style="display:flex;"><span>    names.emplace(nameFromIdx(idx));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>看如下调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>logAndAdd(<span style="color:#d3869b">22</span>); <span style="color:#928374;font-style:italic">// calls int overload
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fabd2f">short</span> nameIdx;
</span></span><span style="display:flex;"><span>logAndAdd(nameIdx);                    <span style="color:#928374;font-style:italic">// error!
</span></span></span></code></pre></div><p>这是因为在参数是类型是<code>short</code>,很明显不符合<code>void logAndAdd(int idx)</code>的签名，但是Universal references这个就不一样了，可以通过模板来推导，是符合的，所以会调用这个，
但是<code>std::string</code>是不可以通过<code>short</code>构造，所以才会出错。
而且这种错误在复杂的代码中查找查找起来比较困难，应该避免去重载 Universal references。</p>
<h2 id="item-27-熟悉使用除了通用引用外的其他替代方案">Item 27: 熟悉使用除了通用引用外的其他替代方案</h2>
<ul>
<li>放弃重载，通过函数命名来解决，这个很好理解。</li>
<li>传入的参数由 <code>const T&amp;</code>来修饰</li>
<li>传值
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">class</span> Person {
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">public</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">explicit</span> Person(std<span style="color:#fe8019">::</span>string n)  <span style="color:#928374;font-style:italic">// replace T&amp;&amp; ctro; see
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>      <span style="color:#fe8019">:</span> name(std<span style="color:#fe8019">::</span>move(n)) {}     <span style="color:#928374;font-style:italic">// Item 41 for use of std::move
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">explicit</span> <span style="color:#fabd2f">Person</span>(<span style="color:#fabd2f">int</span> idx)  <span style="color:#928374;font-style:italic">// as before
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>      <span style="color:#fe8019">:</span> name(nameFromIdx(idx)) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">private</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#fe8019">::</span>string name;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>通过C++ 的<code>type traits</code>特性来对具体的实现进行重载，并提供一个对外统一的函数来包裹该实现，下面代码中的<code>std::is_integral</code>，以及<code>std::false_type</code>和<code>std::true_type</code>就是C++ 的<code>type traits</code>特性，这个可以查看<a href="https://en.cppreference.com/w/cpp/header/type_traits">C++ reference文档中的type traits相关内容</a>。
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#fe8019">::</span>multiset<span style="color:#fe8019">&lt;</span>std<span style="color:#fe8019">::</span>string<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span>    names;                <span style="color:#928374;font-style:italic">// global data structure
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fe8019">template</span> <span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>     <span style="color:#928374;font-style:italic">// make log entry and add
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fabd2f">void</span> logAndAdd(T <span style="color:#fe8019">&amp;&amp;</span>name)  <span style="color:#928374;font-style:italic">// name to data structure
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>{
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">auto</span> now <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>system_clock<span style="color:#fe8019">::</span>now();
</span></span><span style="display:flex;"><span>  log(now <span style="color:#b8bb26">&#34;logAndAdd&#34;</span>);
</span></span><span style="display:flex;"><span>  names.emplace(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;</span>(name));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">template</span> <span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> logAndAdd(T <span style="color:#fe8019">&amp;&amp;</span>name) {
</span></span><span style="display:flex;"><span>  logAndAddImpl(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;</span>(name), std<span style="color:#fe8019">::</span>is_integral<span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> std<span style="color:#fe8019">::</span>remove_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&gt;</span>());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">template</span> <span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>                           <span style="color:#928374;font-style:italic">// non-integral
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span><span style="color:#fabd2f">void</span> logAndAddImpl(T <span style="color:#fe8019">&amp;&amp;</span>name, std<span style="color:#fe8019">::</span>false_type)   <span style="color:#928374;font-style:italic">// nargument:
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>{                                               <span style="color:#928374;font-style:italic">// add it to
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>  <span style="color:#fe8019">auto</span> now <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>system_clock<span style="color:#fe8019">::</span>now();  <span style="color:#928374;font-style:italic">// global data
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>  log(now, <span style="color:#b8bb26">&#34;logAndAdd&#34;</span>);                        <span style="color:#928374;font-style:italic">// structure
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>  names.emplace(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;</span>(name));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#fe8019">::</span>string nameFromIdx(<span style="color:#fabd2f">int</span> idx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">logAndAddImpl</span>(<span style="color:#fabd2f">int</span> idx, std<span style="color:#fe8019">::</span>true_type)  <span style="color:#928374;font-style:italic">// integral
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>{                                            <span style="color:#928374;font-style:italic">// argument; look
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>  logAndAdd(nameFromIdx(idx));               <span style="color:#928374;font-style:italic">// up name and
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>}  <span style="color:#928374;font-style:italic">// call logAndAdd with it
</span></span></span></code></pre></div></li>
<li>通过C++的模板偏特化来实现重载，书中主要讲的是<code>std::enable_if</code>搭配<code>type traits</code>来实现的
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">class</span> Person {
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">public</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">template</span> <span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T, <span style="color:#fe8019">typename</span> <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>enable_if<span style="color:#fe8019">&lt;!</span>std<span style="color:#fe8019">::</span>is_base_of<span style="color:#fe8019">&lt;</span>Person, std<span style="color:#fe8019">::</span>decay_t<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;&gt;::</span>value <span style="color:#fe8019">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                                                  <span style="color:#fe8019">!</span>std<span style="color:#fe8019">::</span>is_integral<span style="color:#fe8019">&lt;</span>std<span style="color:#fe8019">::</span>remove_reference_t<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;&gt;::</span>value<span style="color:#fe8019">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">::</span>type <span style="color:#fe8019">explicit</span> Person(T <span style="color:#fe8019">&amp;&amp;</span>n) <span style="color:#fe8019">:</span> name(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;</span>(n)) {}
</span></span><span style="display:flex;"><span>  <span style="color:#fe8019">explicit</span> <span style="color:#fabd2f">Person</span>(<span style="color:#fabd2f">int</span> idx) <span style="color:#fe8019">:</span> name(nameFromIdx(idx)) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">private</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#fe8019">::</span>string name;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
</ul>
<h2 id="item-28-理解引用折叠">Item 28: 理解引用折叠</h2>
<p>C++ 不允许引用 引用 引用， 比较拗口，代码上表示就是形如 <code>A a&amp; &amp; =</code> 在编译的时候是会出错的，在C++11之后的特性&quot;引用折叠&quot; 就
是为<code>std::forward</code>准备的，由左值引用和右值引用的区别，规则如下：</p>
<ul>
<li><code>A&amp; &amp;</code> ==&gt;  <code>A&amp;</code></li>
<li><code>A&amp; &amp;&amp;</code> ==&gt;  <code>A&amp;</code></li>
<li><code>A&amp;&amp; &amp;</code> ==&gt;  <code>A&amp;</code></li>
<li><code>A&amp;&amp; &amp;&amp;</code> ==&gt;  <code>A&amp;&amp;</code></li>
</ul>
<p><code>std::forward</code>的实现大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">template</span><span style="color:#fe8019">&lt;</span><span style="color:#fe8019">typename</span> T<span style="color:#fe8019">&gt;</span>
</span></span><span style="display:flex;"><span>T<span style="color:#fe8019">&amp;&amp;</span> forward(<span style="color:#fe8019">typename</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>remove_reference<span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&amp;</span> param) {
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span>  std<span style="color:#fe8019">::</span><span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>T<span style="color:#fe8019">&amp;&amp;&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结合在<a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/">Effective Modern C++ 读书笔记之第一章</a>中的参数推导规则， 对于左值引用，<code>T</code>推导后的类型为左值引用，即</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Widget<span style="color:#fe8019">&amp;</span> <span style="color:#fe8019">&amp;&amp;</span> forward(<span style="color:#fe8019">typename</span> std<span style="color:#fe8019">::</span>remove_reference<span style="color:#fe8019">&lt;</span>Widget<span style="color:#fe8019">&amp;&gt;::</span>type<span style="color:#fe8019">&amp;</span> param)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>Widget<span style="color:#fe8019">&amp;</span> <span style="color:#fe8019">&amp;&amp;&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>typename std::remove_reference&lt;Widget&amp;&gt;::type</code>就是<code>Widget</code>，然后再应用上引用折叠的规则，即最终代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Widget<span style="color:#fe8019">&amp;</span> forward(Widget<span style="color:#fe8019">&amp;</span> param) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>Widget<span style="color:#fe8019">&amp;&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样结合在<a href="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-one/">Effective Modern C++ 读书笔记之第一章</a>中的参数推导规则， 对于右值引用，<code>T</code>推导后的类型为具体的类型，即</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Widget<span style="color:#fe8019">&amp;&amp;</span> forward(<span style="color:#fe8019">typename</span> std<span style="color:#fe8019">::</span>remove_reference<span style="color:#fe8019">&lt;</span>Widget<span style="color:#fe8019">&gt;::</span>type<span style="color:#fe8019">&amp;</span> param)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>Widget<span style="color:#fe8019">&amp;&amp;&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代入折叠引用，最终的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Widget<span style="color:#fe8019">&amp;&amp;</span> forward(Widget<span style="color:#fe8019">&amp;</span> param) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>Widget<span style="color:#fe8019">&amp;&amp;&gt;</span>(param);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这符合<code>std::forward</code>的功能描述。</p>
<h2 id="item-29-假设移动操作不可用成本高昂且未被使用">Item 29: 假设移动操作不可用、成本高昂且未被使用</h2>
<h2 id="item-30-熟悉完美转发失败的情况">Item 30: 熟悉完美转发失败的情况</h2>

  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/c&#43;&#43;/" class="tag-link">C&#43;&#43;</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="tag-link">读书笔记</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
