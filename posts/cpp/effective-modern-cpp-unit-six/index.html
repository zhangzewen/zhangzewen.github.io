<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.0">

  <title>Effective Modern C&#43;&#43; 读书笔记之第六章 &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="Effective Modern C&#43;&#43; 读书笔记之第六章">
  <meta itemprop="description" content="Item 31 避免使用默认的变量捕获方式 c&#43;&#43;11的lambda表达式有两种变量的捕获方式：按值(复制)捕获和引用捕获(默认模式)。在采用引用模式(默认[&amp;]会捕获定义lambda表达式作用域下的所有变量, [&amp;params]为显示捕获定义lambda表达式作用域下特定的变量)下，如果不加注意的话,lambda表达式很容易走出引用变量的作用域范围，造成悬空引用，会产生未定义的错误。
#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;string&gt; class A { public: A() : name_(&#34;default&#34;){} void Print() const { std::cout &lt;&lt; &#34;A::Print: &#34; &lt;&lt; name_ &lt;&lt; std::endl; } private: std::string name_; }; typedef std::function&lt;void()&gt; func; int main(int argc, char** argv) { func target; { A a; auto f = [&amp;](){ a.Print();}; //auto f = [&amp;a](){ a.Print();}; target = f; } target(); return 0; } 在我自己机器下的测试结果为">
  <meta itemprop="datePublished" content="2025-02-27T18:34:44+08:00">
  <meta itemprop="dateModified" content="2025-02-27T18:34:44+08:00">
  <meta itemprop="wordCount" content="308">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="C&#43;&#43;,读书笔记">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="Effective Modern C&#43;&#43; 读书笔记之第六章">
  <meta name="twitter:description" content="Item 31 避免使用默认的变量捕获方式 c&#43;&#43;11的lambda表达式有两种变量的捕获方式：按值(复制)捕获和引用捕获(默认模式)。在采用引用模式(默认[&amp;]会捕获定义lambda表达式作用域下的所有变量, [&amp;params]为显示捕获定义lambda表达式作用域下特定的变量)下，如果不加注意的话,lambda表达式很容易走出引用变量的作用域范围，造成悬空引用，会产生未定义的错误。
#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;string&gt; class A { public: A() : name_(&#34;default&#34;){} void Print() const { std::cout &lt;&lt; &#34;A::Print: &#34; &lt;&lt; name_ &lt;&lt; std::endl; } private: std::string name_; }; typedef std::function&lt;void()&gt; func; int main(int argc, char** argv) { func target; { A a; auto f = [&amp;](){ a.Print();}; //auto f = [&amp;a](){ a.Print();}; target = f; } target(); return 0; } 在我自己机器下的测试结果为">


<meta property="og:url" content="https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="Effective Modern C&#43;&#43; 读书笔记之第六章">
  <meta property="og:description" content="Item 31 避免使用默认的变量捕获方式 c&#43;&#43;11的lambda表达式有两种变量的捕获方式：按值(复制)捕获和引用捕获(默认模式)。在采用引用模式(默认[&amp;]会捕获定义lambda表达式作用域下的所有变量, [&amp;params]为显示捕获定义lambda表达式作用域下特定的变量)下，如果不加注意的话,lambda表达式很容易走出引用变量的作用域范围，造成悬空引用，会产生未定义的错误。
#include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;string&gt; class A { public: A() : name_(&#34;default&#34;){} void Print() const { std::cout &lt;&lt; &#34;A::Print: &#34; &lt;&lt; name_ &lt;&lt; std::endl; } private: std::string name_; }; typedef std::function&lt;void()&gt; func; int main(int argc, char** argv) { func target; { A a; auto f = [&amp;](){ a.Print();}; //auto f = [&amp;a](){ a.Print();}; target = f; } target(); return 0; } 在我自己机器下的测试结果为">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-27T18:34:44+08:00">
    <meta property="article:modified_time" content="2025-02-27T18:34:44+08:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="读书笔记">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/#webpage",
      "url": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/",
      "name": "Effective Modern C++ 读书笔记之第六章",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2025-02-27T18:34:44+08:00",
      "dateModified": "2025-02-27T18:34:44+08:00",
      "description": "\u003ch2 id=\"item-31-避免使用默认的变量捕获方式\"\u003eItem 31 避免使用默认的变量捕获方式\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ec++11\u003c/code\u003e的\u003ccode\u003elambda\u003c/code\u003e表达式有两种变量的捕获方式：按值(复制)捕获和引用捕获(默认模式)。在采用引用模式(默认\u003ccode\u003e[\u0026amp;]\u003c/code\u003e会捕获定义\u003ccode\u003elambda\u003c/code\u003e表达式作用域下的所有变量, \u003ccode\u003e[\u0026amp;params]\u003c/code\u003e为显示捕获定义\u003ccode\u003elambda\u003c/code\u003e表达式作用域下特定的变量)下，如果不加注意的话,\u003ccode\u003elambda\u003c/code\u003e表达式很容易走出引用变量的作用域范围，造成悬空引用，会产生未定义的错误。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8ec07c\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#8ec07c;font-style:italic\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#8ec07c\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8ec07c\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#8ec07c;font-style:italic\"\u003e\u0026lt;functional\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#8ec07c\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8ec07c\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#8ec07c;font-style:italic\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#8ec07c\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8ec07c\"\u003e\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003eclass\u003c/span\u003e A\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#fe8019\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    A() \u003cspan style=\"color:#fe8019\"\u003e:\u003c/span\u003e name_(\u003cspan style=\"color:#b8bb26\"\u003e\u0026#34;default\u0026#34;\u003c/span\u003e){}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fabd2f\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#fabd2f\"\u003ePrint\u003c/span\u003e() \u003cspan style=\"color:#fe8019\"\u003econst\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        std\u003cspan style=\"color:#fe8019\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#b8bb26\"\u003e\u0026#34;A::Print: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e name_ \u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#fe8019\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#fe8019\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        std\u003cspan style=\"color:#fe8019\"\u003e::\u003c/span\u003estring name_;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fe8019\"\u003etypedef\u003c/span\u003e std\u003cspan style=\"color:#fe8019\"\u003e::\u003c/span\u003efunction\u003cspan style=\"color:#fe8019\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#fabd2f\"\u003evoid\u003c/span\u003e()\u003cspan style=\"color:#fe8019\"\u003e\u0026gt;\u003c/span\u003e func;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fabd2f\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#fabd2f\"\u003emain\u003c/span\u003e(\u003cspan style=\"color:#fabd2f\"\u003eint\u003c/span\u003e argc, \u003cspan style=\"color:#fabd2f\"\u003echar\u003c/span\u003e\u003cspan style=\"color:#fe8019\"\u003e**\u003c/span\u003e argv)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    func target;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        A a;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fe8019\"\u003eauto\u003c/span\u003e f \u003cspan style=\"color:#fe8019\"\u003e=\u003c/span\u003e [\u003cspan style=\"color:#fe8019\"\u003e\u0026amp;\u003c/span\u003e](){ a.Print();};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#928374;font-style:italic\"\u003e//auto f = [\u0026amp;a](){ a.Print();};\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#928374;font-style:italic\"\u003e\u003c/span\u003e        target \u003cspan style=\"color:#fe8019\"\u003e=\u003c/span\u003e f;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    target();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fe8019\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#d3869b\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在我自己机器下的测试结果为\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/#webpage"
      },
      "headline": "Effective Modern C++ 读书笔记之第六章",
      "datePublished": "2025-02-27T18:34:44+08:00",
      "dateModified": "2025-02-27T18:34:44+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "C++",
        "读书笔记"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/cpp/effective-modern-cpp-unit-six/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#item-31-避免使用默认的变量捕获方式">Item 31 避免使用默认的变量捕获方式</a></li>
        <li><a href="#item-32-使用初始化捕获列表把参数移动到闭包中">Item 32: 使用初始化捕获列表把参数移动到闭包中</a></li>
        <li><a href="#item-33-对传入的auto参数使用decltype以便进行完美转发">Item 33: 对传入的auto&amp;&amp;参数使用decltype，以便进行完美转发</a></li>
        <li><a href="#item-34-优先使用lambda而不是stdbind">Item 34: 优先使用lambda，而不是std::bind</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">Effective Modern C&#43;&#43; 读书笔记之第六章</h1>
  
  

  <div class="post-date">
    <time datetime=" 2025-02-27T18:34:44&#43;0800">Created: Feb 27, 2025</time>
    <span class="readtime">&middot; 2 min read</span>
  </div>

  <div>
    <h2 id="item-31-避免使用默认的变量捕获方式">Item 31 避免使用默认的变量捕获方式</h2>
<p><code>c++11</code>的<code>lambda</code>表达式有两种变量的捕获方式：按值(复制)捕获和引用捕获(默认模式)。在采用引用模式(默认<code>[&amp;]</code>会捕获定义<code>lambda</code>表达式作用域下的所有变量, <code>[&amp;params]</code>为显示捕获定义<code>lambda</code>表达式作用域下特定的变量)下，如果不加注意的话,<code>lambda</code>表达式很容易走出引用变量的作用域范围，造成悬空引用，会产生未定义的错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;iostream&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;functional&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;string&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c"></span><span style="color:#fe8019">class</span> A
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">public</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>    A() <span style="color:#fe8019">:</span> name_(<span style="color:#b8bb26">&#34;default&#34;</span>){}
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">void</span> <span style="color:#fabd2f">Print</span>() <span style="color:#fe8019">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>cout <span style="color:#fe8019">&lt;&lt;</span> <span style="color:#b8bb26">&#34;A::Print: &#34;</span> <span style="color:#fe8019">&lt;&lt;</span> name_ <span style="color:#fe8019">&lt;&lt;</span> std<span style="color:#fe8019">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">private</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>string name_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fe8019">typedef</span> std<span style="color:#fe8019">::</span>function<span style="color:#fe8019">&lt;</span><span style="color:#fabd2f">void</span>()<span style="color:#fe8019">&gt;</span> func;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">int</span> <span style="color:#fabd2f">main</span>(<span style="color:#fabd2f">int</span> argc, <span style="color:#fabd2f">char</span><span style="color:#fe8019">**</span> argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    func target;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        A a;
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">auto</span> f <span style="color:#fe8019">=</span> [<span style="color:#fe8019">&amp;</span>](){ a.Print();};
</span></span><span style="display:flex;"><span>        <span style="color:#928374;font-style:italic">//auto f = [&amp;a](){ a.Print();};
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>        target <span style="color:#fe8019">=</span> f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    target();
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#d3869b">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在我自己机器下的测试结果为</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A<span style="color:#fe8019">::</span><span style="color:#fb4934">Print</span>:
</span></span></code></pre></div><p>但是如果是按值捕获的话，是没有问题的。但是这并不意味着按值捕获可以高枕无忧，如果捕获的是<code>指针</code>，如果在某一时刻该指针指向的内容被释放，在调用<code>lambda</code>表达式的时候，一样会产生悬空指针，使结果是未定义的行为。</p>
<p>还说了一个特殊的情况，就是在类的成员函数里面定义的<code>lambda</code>表达式，并捕获类成员变量，实际上捕获的是类的this指针，如果<code>lambda</code>表达式在捕获成员变量后，走出类实例的作用域范围，一样造成悬空指针，产生未定义的行为，解决的方法是可以复制该成员变量然后按值捕获到<code>lambda</code>表达式中去。</p>
<p>还有需要注意的是static变量是不可以被捕获的。当使用按值捕获的时候，但是 lambda 表达式的实现中引用了 static 变量的话，且修改了该变量，这就造成了语义上的不一致。</p>
<h2 id="item-32-使用初始化捕获列表把参数移动到闭包中">Item 32: 使用初始化捕获列表把参数移动到闭包中</h2>
<p>这个Item 解决的问题<code>lambda</code>怎样捕获那些没有copy语义只有move语义的变量，以及通过move语义来提供程序性能。<code>c++11</code>的<code>lambda</code>表达式的捕获列表现在不支持<code>move</code>语义且不支持捕获列表的初始化，但是在<code>c++14</code>中<code>lambda</code>表达式是支持捕获列表的初始化以及<code>move</code>语义，如:</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;iostream&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;functional&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c">#include</span> <span style="color:#8ec07c;font-style:italic">&lt;string&gt;</span><span style="color:#8ec07c">
</span></span></span><span style="display:flex;"><span><span style="color:#8ec07c"></span><span style="color:#fe8019">class</span> A
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">public</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>    A() <span style="color:#fe8019">:</span> name_(<span style="color:#b8bb26">&#34;default&#34;</span>){}
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">void</span> <span style="color:#fabd2f">Print</span>() <span style="color:#fe8019">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>cout <span style="color:#fe8019">&lt;&lt;</span> <span style="color:#b8bb26">&#34;A::Print: &#34;</span> <span style="color:#fe8019">&lt;&lt;</span> name_ <span style="color:#fe8019">&lt;&lt;</span> std<span style="color:#fe8019">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    A(<span style="color:#fe8019">const</span> A<span style="color:#fe8019">&amp;</span> a) {
</span></span><span style="display:flex;"><span>        name_ <span style="color:#fe8019">=</span> a.name_;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    A(A<span style="color:#fe8019">&amp;&amp;</span> a) {
</span></span><span style="display:flex;"><span>        name_ <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>move(a.name_);
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>cout <span style="color:#fe8019">&lt;&lt;</span> <span style="color:#b8bb26">&#34;call A(A&amp;&amp; a)&#34;</span> <span style="color:#fe8019">&lt;&lt;</span> std<span style="color:#fe8019">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#fe8019">private</span><span style="color:#fe8019">:</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#fe8019">::</span>string name_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">int</span> <span style="color:#fabd2f">main</span>(<span style="color:#fabd2f">int</span> argc, <span style="color:#fabd2f">char</span><span style="color:#fe8019">**</span> argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    A a;
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">auto</span> f <span style="color:#fe8019">=</span> [a <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>move(a)](){ a.Print();};
</span></span><span style="display:flex;"><span>    <span style="color:#928374;font-style:italic">//auto f = [&amp;a](){ a.Print();};
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>    f();
</span></span><span style="display:flex;"><span>    a.Print();
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> <span style="color:#d3869b">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用<code>c++14</code>编译选项，测试结果为：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>call A(A<span style="color:#fe8019">&amp;&amp;</span> a)
</span></span><span style="display:flex;"><span>A<span style="color:#fe8019">::</span><span style="color:#fb4934">Print</span>: <span style="color:#fe8019">default</span>
</span></span><span style="display:flex;"><span>A<span style="color:#fe8019">::</span><span style="color:#fb4934">Print</span>:
</span></span></code></pre></div><p>但是使用<code>c++11</code>编译选项，书上说目前<code>c++11</code>不支持，但是我这边的测试环境依然可以编译通过，并和使用<code>c++14</code>编译选项编译运行的结果一致。</p>
<p><code>lambda</code>表达式的捕获参数的<code>move</code>语义可以借助<code>std::bind</code>来完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">auto</span> func <span style="color:#fe8019">=</span> <span style="color:#fb4934">std</span>:bind(
</span></span><span style="display:flex;"><span>    [](A<span style="color:#fe8019">&amp;</span> a) {
</span></span><span style="display:flex;"><span>        a.Print();
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    std<span style="color:#fe8019">::</span>move(a)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>对于<code>std::bind</code>来说，传递到其的参数，如果是左值，就会使用<code>copy construct</code>语义进行传递，如果是右值，就会通过<code>move construct</code>传递参数。在上面的例子中，<code>data</code>通过<code>move construct</code>语义传递到<code>std::bind</code>中，当<code>func</code>被调用的时候，<code>data</code>就会以引用的方式作为参数传入的<code>lambda</code>表达式中去，效果达到了<code>lambda</code>初始化捕获列表中的<code>move</code>语义。</p>
<h2 id="item-33-对传入的auto参数使用decltype以便进行完美转发">Item 33: 对传入的auto&amp;&amp;参数使用decltype，以便进行完美转发</h2>
<p>这个Item说的是在lambda表达式的参数列表中使用auto，这个特性是C++14及之后的版本支持，C++11不支持。
为了对<code>auto&amp;&amp;</code> 类型的参数进行完美转发，可以这样做：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">auto</span> f <span style="color:#fe8019">=</span>
</span></span><span style="display:flex;"><span>     [](<span style="color:#fe8019">auto</span><span style="color:#fe8019">&amp;&amp;</span> param)
</span></span><span style="display:flex;"><span>     {
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">return</span> <span style="color:#fabd2f">func</span>(normalize(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>std<span style="color:#fe8019">::</span><span style="color:#fe8019">decltype</span>(param)<span style="color:#fe8019">&gt;</span>(param)));
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">auto</span> f <span style="color:#fe8019">=</span>
</span></span><span style="display:flex;"><span>    [](<span style="color:#fe8019">auto</span><span style="color:#fe8019">&amp;&amp;</span>... params) {
</span></span><span style="display:flex;"><span>        <span style="color:#fe8019">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fabd2f">func</span>(normalize(std<span style="color:#fe8019">::</span>forward<span style="color:#fe8019">&lt;</span>std<span style="color:#fe8019">::</span><span style="color:#fe8019">decltype</span>(params)<span style="color:#fe8019">&gt;</span>(params)...));
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><h2 id="item-34-优先使用lambda而不是stdbind">Item 34: 优先使用lambda，而不是std::bind</h2>
<p>书中从好几个方面认为<code>lambda</code>比<code>std::bind</code>更有优势（我更认为是编程经验，下面不做比较，纯做经验总结）：</p>
<p>以书中例子为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">using</span> Time <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>time_point<span style="color:#fe8019">&lt;</span>std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>steady_clock<span style="color:#fe8019">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">enum</span> <span style="color:#fe8019">class</span> Sound {Beep, Siren, Whistle };
</span></span><span style="display:flex;"><span><span style="color:#fe8019">using</span> Duration <span style="color:#fe8019">=</span> std<span style="color:#fe8019">::</span>chrono<span style="color:#fe8019">::</span>steady_clock<span style="color:#fe8019">::</span>duration;
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">setAlarm</span>(Time t, Sound s, Duration d);
</span></span></code></pre></div><p>使用<code>lambda</code>表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#928374;font-style:italic">//lambda
</span></span></span><span style="display:flex;"><span><span style="color:#928374;font-style:italic"></span>auot setSoundL <span style="color:#fe8019">=</span>
</span></span><span style="display:flex;"><span>  [](Sound s)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">using</span> <span style="color:#fe8019">namespace</span> std<span style="color:#fe8019">::</span>chrono;
</span></span><span style="display:flex;"><span>    setAlarm(steady_clock<span style="color:#fe8019">::</span>now() <span style="color:#fe8019">+</span> hours(<span style="color:#d3869b">1</span>),
</span></span><span style="display:flex;"><span>             s,
</span></span><span style="display:flex;"><span>             seconds(<span style="color:#d3869b">30</span>));
</span></span><span style="display:flex;"><span>  };
</span></span></code></pre></div><p>使用<code>std::bind</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">using</span> <span style="color:#fe8019">namespace</span> std<span style="color:#fe8019">::</span>chrono;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">using</span> <span style="color:#fe8019">namespace</span> std<span style="color:#fe8019">::</span>placeholders;
</span></span><span style="display:flex;"><span><span style="color:#fe8019">auto</span> setSoundB <span style="color:#fe8019">=</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#fe8019">::</span>bind(setAlarm,
</span></span><span style="display:flex;"><span>            steady_clock<span style="color:#fe8019">::</span>now() <span style="color:#fe8019">+</span> hours(<span style="color:#d3869b">1</span>),
</span></span><span style="display:flex;"><span>            _1,
</span></span><span style="display:flex;"><span>            seconds(<span style="color:#d3869b">30</span>));
</span></span></code></pre></div><p>在参数传递上，<code>lambda</code>显示的指明了传递参数的类型，而<code>std::bind</code>只提供了一个占位符来表示在调用<code>setSoundB</code>时要传入参数()，并且，如果需要传入的参数不止一个的话，即需要多个占位符，还需要不得不考虑占位符和传入的参数的顺序，在直观性上<code>lambda</code>有这很明显的优势。如果对<code>setAlarm</code>函数进行重载的话：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">enum</span> <span style="color:#fe8019">class</span> Volume { Normal, Loud, LoudPlusPlus };
</span></span><span style="display:flex;"><span><span style="color:#fabd2f">void</span> <span style="color:#fabd2f">setAlarm</span>(Time t, Sound s, Duration d, Volume v);
</span></span></code></pre></div><p>上面的<code>lambda</code>表达式依然是可以使用的，但是<code>std::bind</code>就不行了，因为在绑定<code>setAlarm</code>函数时产生了二义性,不知道具体绑定那个函数，就需要手动编码明确指定具体要绑定那个函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fe8019">using</span> setAlarm3ParamType <span style="color:#fe8019">=</span> <span style="color:#fabd2f">void</span>(<span style="color:#fe8019">*</span>)(Time t, Sound s, Duration d);
</span></span><span style="display:flex;"><span><span style="color:#fe8019">auto</span> setSoundB <span style="color:#fe8019">=</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#fe8019">::</span>bind(<span style="color:#fe8019">static_cast</span><span style="color:#fe8019">&lt;</span>setAlarm3ParamType<span style="color:#fe8019">&gt;</span>(setAlarm),
</span></span><span style="display:flex;"><span>            steady_clock<span style="color:#fe8019">::</span>now() <span style="color:#fe8019">+</span> hours(<span style="color:#d3869b">1</span>),
</span></span><span style="display:flex;"><span>            _1,
</span></span><span style="display:flex;"><span>            seconds(<span style="color:#d3869b">30</span>));
</span></span></code></pre></div><p>并且，书中还说道<code>lambda</code>能会内联<code>setAlarm</code>函数，因此，<code>lambda</code>可能会比<code>std::bind</code>运行的稍微快些。</p>
<p>其次，在绑定参数(<code>lambda</code>为捕获参数)上， 正如上面说到的，<code>std::bind</code>在参数传入的时候，如果是左值就按照<code>copy construct</code>语义传递参数，如果是右值的话就是<code>move construct</code>语义传递参数，如果需要以<code>引用</code>方式传递参数的话，需要使用<code>std::ref</code>来实现。在<code>lambda</code>捕获参数的方式就不多复述了。</p>

  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/c&#43;&#43;/" class="tag-link">C&#43;&#43;</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="tag-link">读书笔记</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
