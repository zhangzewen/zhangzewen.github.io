<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.0">

  <title>xv6 之 内存管理 &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="xv6 之 内存管理">
  <meta itemprop="description" content="本篇文章是对学习 xv6 系统的理解和总结，权当笔记，以便日后翻阅，如果阅读起来很跳跃和不连贯，请见谅。
xv6 page table 上图是 RISC-V 多种虚拟内存布局中的一种 — Sv39。">
  <meta itemprop="datePublished" content="2025-07-28T09:43:31+08:00">
  <meta itemprop="dateModified" content="2025-07-28T09:43:31+08:00">
  <meta itemprop="wordCount" content="729">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="公开课,操作系统,Linux,Mit,Xv6">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="xv6 之 内存管理">
  <meta name="twitter:description" content="本篇文章是对学习 xv6 系统的理解和总结，权当笔记，以便日后翻阅，如果阅读起来很跳跃和不连贯，请见谅。
xv6 page table 上图是 RISC-V 多种虚拟内存布局中的一种 — Sv39。">


<meta property="og:url" content="https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="xv6 之 内存管理">
  <meta property="og:description" content="本篇文章是对学习 xv6 系统的理解和总结，权当笔记，以便日后翻阅，如果阅读起来很跳跃和不连贯，请见谅。
xv6 page table 上图是 RISC-V 多种虚拟内存布局中的一种 — Sv39。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-28T09:43:31+08:00">
    <meta property="article:modified_time" content="2025-07-28T09:43:31+08:00">
    <meta property="article:tag" content="公开课">
    <meta property="article:tag" content="操作系统">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Mit">
    <meta property="article:tag" content="Xv6">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/#webpage",
      "url": "https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/",
      "name": "xv6 之 内存管理",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2025-07-28T09:43:31+08:00",
      "dateModified": "2025-07-28T09:43:31+08:00",
      "description": "\u003cp\u003e本篇文章是对学习 xv6 系统的理解和总结，权当笔记，以便日后翻阅，如果阅读起来很跳跃和不连贯，请见谅。\u003c/p\u003e\n\u003ch2 id=\"xv6-page-table\"\u003exv6 page table\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/os/xv6/risc-v-pagetable.png\" alt=\"risc-v page table\"\u003e\u003c/p\u003e\n\u003cp\u003e上图是 \u003ccode\u003eRISC-V\u003c/code\u003e 多种虚拟内存布局中的一种 — \u003ccode\u003eSv39\u003c/code\u003e。\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/#webpage"
      },
      "headline": "xv6 之 内存管理",
      "datePublished": "2025-07-28T09:43:31+08:00",
      "dateModified": "2025-07-28T09:43:31+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "公开课",
        "操作系统",
        "Linux",
        "Mit",
        "Xv6"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/os/xv6/xv6_memory_management/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#xv6-page-table">xv6 page table</a></li>
        <li><a href="#xv6-内核内存布局">xv6 内核内存布局</a></li>
        <li><a href="#xv6-用户进程内存布局">xv6 用户进程内存布局</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li><li>
          <a href="/about-me/">About Me</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
      <a href="https://github.com/zhangzewen" rel="me" title="GitHub" target="_blank">
        <i class="fab fa-github" aria-hidden="true"></i>
      </a>
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">xv6 之 内存管理</h1>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


  <div class="post-date">
    <time datetime=" 2025-07-28T09:43:31&#43;0800">Created: Jul 28, 2025</time>
    <span class="readtime">&middot; 4 min read</span>
  </div>

  <div>
    <p>本篇文章是对学习 xv6 系统的理解和总结，权当笔记，以便日后翻阅，如果阅读起来很跳跃和不连贯，请见谅。</p>
<h2 id="xv6-page-table">xv6 page table</h2>
<p><img src="/images/os/xv6/risc-v-pagetable.png" alt="risc-v page table"></p>
<p>上图是 <code>RISC-V</code> 多种虚拟内存布局中的一种 — <code>Sv39</code>。</p>
<p>通常，第一级 page table entry（上图的L2）指向第二级 page table，第二级 page table entry（上图的L1）指向第三级 page table，第三级 page table entry（上图的L0）指向的是实际的物理内存，将连续的且对齐的 4KB 虚拟内存映射到连续的且对齐的 4KB 物理内存（注意上面的虚拟地址的 offset， $1&laquo;12 = 4096$，所以对一个实际的物理地址左右移动不超过 12 位，都可以复原到原本的物理地址）。</p>
<p>和第三级 page table entry 的功能相似，如果第二级 page table entry 是叶子节点，则它指向的是 2MB 的物理内存。还需要知道的是如果第一级 page table entry 是叶子节点，则它指向的是 1GB 的物理内存。</p>
<p>一个 page table 的大小是 4KB， 一个 page table entry 的大小是 8 bytes，所以 <code>Sv39</code> 可以的表达 512GB 的内存空间。</p>
<p><img src="/images/os/xv6/pagetable-level.png" alt=""></p>
<p>xv6 为每个进程维护一个page table，描述每个进程的用户地址空间，再加上一个单独的页表（全局 <code>kernel_pagetable</code>）来描述内核的地址空间映射。内核通过预设地址空间的布局，以便通过虚拟地址获得对物理内存和各种硬件资源的访问。</p>
<h2 id="xv6-内核内存布局">xv6 内核内存布局</h2>
<p>如下是内核的page table 映射布局，其逻辑实现在 <code>kernel/vm.c</code> 下的 <code>kvminit</code>，特别需要注意的是<code>proc_mapstacks</code> 和 <code>procinit</code>，他给每个进程都分配了内核栈且映射信息是保存在内核 page table上的，下图的 Guard page 其实就是没有做映射的虚拟地址段。然后调用<code>kvminithart</code> 把 内核 page table 的物理地址写入到寄存器 <code>satp</code>中。</p>
<p><img src="/images/os/xv6/xv6_kernel_va_pa_layout.png" alt="xv6 内核内存布局"></p>
<h2 id="xv6-用户进程内存布局">xv6 用户进程内存布局</h2>
<p>每个进程都有自己的page table，当xv6在进程之间切换时，它也切换了page table，用户进程的page table 的虚拟地址最大为 <code>MAXVA</code>，即可以达高达 256GB 的内存空间，这个值定义在<code>kernel/riscv.h</code>中。</p>
<p><img src="/images/os/xv6/user_process_pa_va_layout.png" alt="用户进程的page table 布局"></p>
<p>下面来拆解这张图是怎么实现的。</p>
<p>在交互环境（执行 <code>make qemu</code> 进入）下执行<code>ctrl + p</code> 可以看到类似<code>ps</code>命令的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">1</span> sleep  init
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">2</span> sleep  sh
</span></span></code></pre></div><p>第一个用户进程就是<code>init</code>，它是通过 <code>kernel/main.c</code> 下的 <code>userinit</code> 初始化和拉起来的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">void</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">userinit</span>(<span style="color:#8be9fd">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> proc <span style="color:#ff79c6">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  p <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">allocproc</span>();
</span></span><span style="display:flex;"><span>  initproc <span style="color:#ff79c6">=</span> p;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// allocate one user page and copy initcode&#39;s instructions
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// and data into it.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#50fa7b">uvmfirst</span>(p<span style="color:#ff79c6">-&gt;</span>pagetable, initcode, <span style="color:#ff79c6">sizeof</span>(initcode));
</span></span><span style="display:flex;"><span>  p<span style="color:#ff79c6">-&gt;</span>sz <span style="color:#ff79c6">=</span> PGSIZE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// prepare for the very first &#34;return&#34; from kernel to user.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p<span style="color:#ff79c6">-&gt;</span>trapframe<span style="color:#ff79c6">-&gt;</span>epc <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;      <span style="color:#6272a4">// user program counter
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p<span style="color:#ff79c6">-&gt;</span>trapframe<span style="color:#ff79c6">-&gt;</span>sp <span style="color:#ff79c6">=</span> PGSIZE;  <span style="color:#6272a4">// user stack pointer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">safestrcpy</span>(p<span style="color:#ff79c6">-&gt;</span>name, <span style="color:#f1fa8c">&#34;initcode&#34;</span>, <span style="color:#ff79c6">sizeof</span>(p<span style="color:#ff79c6">-&gt;</span>name));
</span></span><span style="display:flex;"><span>  p<span style="color:#ff79c6">-&gt;</span>cwd <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">namei</span>(<span style="color:#f1fa8c">&#34;/&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  p<span style="color:#ff79c6">-&gt;</span>state <span style="color:#ff79c6">=</span> RUNNABLE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">release</span>(<span style="color:#ff79c6">&amp;</span>p<span style="color:#ff79c6">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从上面的代码可以看到 <code>initcode</code> 的流程如下：</p>
<ul>
<li>使用 <code>allocproc</code> 分配进程，在这里会给每个进程分配一个page table，并调用 <code>proc_pagetable</code> 设置初始的映射，这里需要注意 <code>TRAMPOLINE</code> 的映射信息，这个是实现用户态和内核态平滑切换的关键。</li>
<li>把 <code>initcode.S</code> 拷贝到分配到的 页 中，并把该页映射到虚拟地址<code>0x0</code>，这段逻辑在<code>uvmfirst</code>中实现。</li>
<li>设置栈帧，并修改为状态为<code>RUNNABLE</code></li>
</ul>
<p>至此已经完成上图的头尾两端的映射逻辑实现。如下是<code>initcode.S</code> 的汇编代码，只需要知道是使用系统调用 <code>exec</code> 来调用 <code>init.c</code> 即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#6272a4"># Initial process that execs /init.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"># This code runs in user space.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#include &#34;syscall.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># exec(init, argv)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#50fa7b">.globl</span> start
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">start:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">la</span> a0, init
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">la</span> a1, argv
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">li</span> a7, SYS_exec
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">ecall</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># for(;;) exit();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">exit:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">li</span> a7, SYS_exit
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">ecall</span>
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">jal</span> exit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># char init[] = &#34;/init\0&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">init:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">.string</span> <span style="color:#f1fa8c">&#34;/init\0&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># char *argv[] = { init, 0 };
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#50fa7b">.p2align</span> <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">argv:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">.quad</span> init
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">.quad</span> <span style="color:#bd93f9">0</span>
</span></span></code></pre></div><p>如下是 <code>exec</code> 的代码：
<code>exec</code> 执行流程如下：</p>
<ul>
<li>创建新的page table，并设置其虚拟地址顶部的映射关系，完成上图的顶端部分。</li>
<li>装载可执行文件到内存中，以虚拟地址<code>0x0</code>开始，注意如下代码中的变量<code>sz</code>，这就完成了上图的底端部分。</li>
<li>然后申请两个页来做用户态的栈空间，但是又清除一个页（用户栈下方）的映射作为Guard page，即用户栈的大小是一个页，用户栈是向下增长的，生长到 Guard page 会产生 exception。</li>
<li>拷贝参数到用户栈，此步骤和上一步完成上图的中间部分。</li>
<li>替换page table，以及设置寄存器</li>
</ul>
<p>至此，上面的用户态内存布局的拼图完成。</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">exec</span>(<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>path, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>s, <span style="color:#ff79c6">*</span>last;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">int</span> i, off;
</span></span><span style="display:flex;"><span>  uint64 argc, sz <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>, sp, ustack[MAXARG], stackbase;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> elfhdr elf;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> inode <span style="color:#ff79c6">*</span>ip;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> proghdr ph;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">pagetable_t</span> pagetable <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>, oldpagetable;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> proc <span style="color:#ff79c6">*</span>p <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">myproc</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">begin_op</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>((ip <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">namei</span>(path)) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">end_op</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">ilock</span>(ip);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Check ELF header
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span>(<span style="color:#50fa7b">readi</span>(ip, <span style="color:#bd93f9">0</span>, (uint64)<span style="color:#ff79c6">&amp;</span>elf, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">sizeof</span>(elf)) <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">sizeof</span>(elf))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>(elf.magic <span style="color:#ff79c6">!=</span> ELF_MAGIC)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 可以理解为其复制了调用exec的进程的头部虚拟地址映射关系
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span>((pagetable <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">proc_pagetable</span>(p)) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Load program into memory.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">for</span>(i<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>, off<span style="color:#ff79c6">=</span>elf.phoff; i<span style="color:#ff79c6">&lt;</span>elf.phnum; i<span style="color:#ff79c6">++</span>, off<span style="color:#ff79c6">+=</span><span style="color:#ff79c6">sizeof</span>(ph)){
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(<span style="color:#50fa7b">readi</span>(ip, <span style="color:#bd93f9">0</span>, (uint64)<span style="color:#ff79c6">&amp;</span>ph, off, <span style="color:#ff79c6">sizeof</span>(ph)) <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">sizeof</span>(ph))
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(ph.type <span style="color:#ff79c6">!=</span> ELF_PROG_LOAD)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">continue</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(ph.memsz <span style="color:#ff79c6">&lt;</span> ph.filesz)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(ph.vaddr <span style="color:#ff79c6">+</span> ph.memsz <span style="color:#ff79c6">&lt;</span> ph.vaddr)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(ph.vaddr <span style="color:#ff79c6">%</span> PGSIZE <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    uint64 sz1;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>((sz1 <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">uvmalloc</span>(pagetable, sz, ph.vaddr <span style="color:#ff79c6">+</span> ph.memsz, <span style="color:#50fa7b">flags2perm</span>(ph.flags))) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    sz <span style="color:#ff79c6">=</span> sz1;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(<span style="color:#50fa7b">loadseg</span>(pagetable, ph.vaddr, ip, ph.off, ph.filesz) <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">iunlockput</span>(ip);
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">end_op</span>();
</span></span><span style="display:flex;"><span>  ip <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  p <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">myproc</span>();
</span></span><span style="display:flex;"><span>  uint64 oldsz <span style="color:#ff79c6">=</span> p<span style="color:#ff79c6">-&gt;</span>sz;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Allocate some pages at the next page boundary.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// Make the first inaccessible as a stack guard.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// Use the rest as the user stack.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  sz <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">PGROUNDUP</span>(sz);
</span></span><span style="display:flex;"><span>  uint64 sz1;
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 申请两个页并做映射
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span>((sz1 <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">uvmalloc</span>(pagetable, sz, sz <span style="color:#ff79c6">+</span> (USERSTACK<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>)<span style="color:#ff79c6">*</span>PGSIZE, PTE_W)) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>  sz <span style="color:#ff79c6">=</span> sz1;
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 清除用户栈下的页的映射，作为 Guard page
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#50fa7b">uvmclear</span>(pagetable, sz<span style="color:#ff79c6">-</span>(USERSTACK<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>)<span style="color:#ff79c6">*</span>PGSIZE);
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 设置栈帧
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  sp <span style="color:#ff79c6">=</span> sz;
</span></span><span style="display:flex;"><span>  stackbase <span style="color:#ff79c6">=</span> sp <span style="color:#ff79c6">-</span> USERSTACK<span style="color:#ff79c6">*</span>PGSIZE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Push argument strings, prepare rest of stack in ustack.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 把内核态的参数列表拷贝到刚申请的用户态的栈中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">for</span>(argc <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; argv[argc]; argc<span style="color:#ff79c6">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(argc <span style="color:#ff79c6">&gt;=</span> MAXARG)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    sp <span style="color:#ff79c6">-=</span> <span style="color:#50fa7b">strlen</span>(argv[argc]) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>    sp <span style="color:#ff79c6">-=</span> sp <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">16</span>; <span style="color:#6272a4">// riscv sp must be 16-byte aligned
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span>(sp <span style="color:#ff79c6">&lt;</span> stackbase)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(<span style="color:#50fa7b">copyout</span>(pagetable, sp, argv[argc], <span style="color:#50fa7b">strlen</span>(argv[argc]) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>    ustack[argc] <span style="color:#ff79c6">=</span> sp;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 休止标志位
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  ustack[argc] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// push the array of argv[] pointers.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 参数列表的首地址压入到栈中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  sp <span style="color:#ff79c6">-=</span> (argc<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">sizeof</span>(uint64);
</span></span><span style="display:flex;"><span>  sp <span style="color:#ff79c6">-=</span> sp <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">16</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>(sp <span style="color:#ff79c6">&lt;</span> stackbase)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>(<span style="color:#50fa7b">copyout</span>(pagetable, sp, (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)ustack, (argc<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>)<span style="color:#ff79c6">*</span><span style="color:#ff79c6">sizeof</span>(uint64)) <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> bad;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// arguments to user main(argc, argv)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// argc is returned via the system call return
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// value, which goes in a0.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p<span style="color:#ff79c6">-&gt;</span>trapframe<span style="color:#ff79c6">-&gt;</span>a1 <span style="color:#ff79c6">=</span> sp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Save program name for debugging.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">for</span>(last<span style="color:#ff79c6">=</span>s<span style="color:#ff79c6">=</span>path; <span style="color:#ff79c6">*</span>s; s<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span>(<span style="color:#ff79c6">*</span>s <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;/&#39;</span>)
</span></span><span style="display:flex;"><span>      last <span style="color:#ff79c6">=</span> s<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">safestrcpy</span>(p<span style="color:#ff79c6">-&gt;</span>name, last, <span style="color:#ff79c6">sizeof</span>(p<span style="color:#ff79c6">-&gt;</span>name));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Commit to the user image.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 替换page table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  oldpagetable <span style="color:#ff79c6">=</span> p<span style="color:#ff79c6">-&gt;</span>pagetable;
</span></span><span style="display:flex;"><span>  p<span style="color:#ff79c6">-&gt;</span>pagetable <span style="color:#ff79c6">=</span> pagetable;
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 设置进程栈的大小，其实也是heap的起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p<span style="color:#ff79c6">-&gt;</span>sz <span style="color:#ff79c6">=</span> sz;
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 设置pc 寄存器，指向下一个要执行的指令
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p<span style="color:#ff79c6">-&gt;</span>trapframe<span style="color:#ff79c6">-&gt;</span>epc <span style="color:#ff79c6">=</span> elf.entry;  <span style="color:#6272a4">// initial program counter = main
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 设置栈指针sp
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p<span style="color:#ff79c6">-&gt;</span>trapframe<span style="color:#ff79c6">-&gt;</span>sp <span style="color:#ff79c6">=</span> sp; <span style="color:#6272a4">// initial stack pointer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 释放掉旧的pagetable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#50fa7b">proc_freepagetable</span>(oldpagetable, oldsz);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> argc; <span style="color:#6272a4">// this ends up in a0, the first argument to main(argc, argv)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span> <span style="color:#8be9fd;font-style:italic">bad</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>(pagetable)
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">proc_freepagetable</span>(pagetable, sz);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>(ip){
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">iunlockput</span>(ip);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">end_op</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details>


  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/" class="tag-link">公开课</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="tag-link">操作系统</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/linux/" class="tag-link">Linux</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/mit/" class="tag-link">Mit</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/xv6/" class="tag-link">Xv6</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
