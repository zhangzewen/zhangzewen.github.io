<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  xml:lang="zh-cn" lang="zh-cn" >

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.149.0">

  <title>MIT 公开课 6.S081 实现总结 &middot; What a Life!</title>

  <meta name="description" content="" />

  
  <meta itemprop="name" content="MIT 公开课 6.S081 实现总结">
  <meta itemprop="description" content="6.S081 是非常著名的 MIT 操作系统课程。该公开课链接的年份后缀的是可以更改的，这个课程提供的可编程 lab 每年都稍微有些不同，每个 lab 的自评测中的 answers-*.txt 和 time.txt 需要自行填写。 本篇文章对应的是 2024 年度课程的实现总结。">
  <meta itemprop="datePublished" content="2025-08-20T09:43:31+08:00">
  <meta itemprop="dateModified" content="2025-08-20T09:43:31+08:00">
  <meta itemprop="wordCount" content="15908">
  <meta itemprop="image" content="https://www.zhangzewen.net/images/profile.png">
  <meta itemprop="keywords" content="公开课,操作系统,Linux,Mit,Xv6">


  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.zhangzewen.net/images/profile.png">
  <meta name="twitter:title" content="MIT 公开课 6.S081 实现总结">
  <meta name="twitter:description" content="6.S081 是非常著名的 MIT 操作系统课程。该公开课链接的年份后缀的是可以更改的，这个课程提供的可编程 lab 每年都稍微有些不同，每个 lab 的自评测中的 answers-*.txt 和 time.txt 需要自行填写。 本篇文章对应的是 2024 年度课程的实现总结。">


<meta property="og:url" content="https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/">
  <meta property="og:site_name" content="What a Life!">
  <meta property="og:title" content="MIT 公开课 6.S081 实现总结">
  <meta property="og:description" content="6.S081 是非常著名的 MIT 操作系统课程。该公开课链接的年份后缀的是可以更改的，这个课程提供的可编程 lab 每年都稍微有些不同，每个 lab 的自评测中的 answers-*.txt 和 time.txt 需要自行填写。 本篇文章对应的是 2024 年度课程的实现总结。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-20T09:43:31+08:00">
    <meta property="article:modified_time" content="2025-08-20T09:43:31+08:00">
    <meta property="article:tag" content="公开课">
    <meta property="article:tag" content="操作系统">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Mit">
    <meta property="article:tag" content="Xv6">
    <meta property="og:image" content="https://www.zhangzewen.net/images/profile.png">



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type":"Person",
      "@id": "https://www.zhangzewen.net/#author",
      "name": "Zhang Zewen",
      "image": {
        "@type":"ImageObject",
        
        "url": "https://www.zhangzewen.net/images/android-chrome-512x512.png"
        
      },
      "description": "Software Engineer"
    },
    {
      "@type": "WebSite",
      "@id": "https://www.zhangzewen.net/#website",
      "url": "https://www.zhangzewen.net/",
      "name": "What a Life!",
      "description": "Software Engineer",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "inLanguage": "zh-cn"
    },
    {
      "@type": "ImageObject",
      "url": "https://www.zhangzewen.net/images/profile.png",
      "caption": "What a Life!"
    },
    {
      "@type": "WebPage",
      "@id": "https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/#webpage",
      "url": "https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/",
      "name": "MIT 公开课 6.S081 实现总结",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/#website"
      },
      "about": {
         "@id": "https://www.zhangzewen.net/#author"
      },
      "datePublished": "2025-08-20T09:43:31+08:00",
      "dateModified": "2025-08-20T09:43:31+08:00",
      "description": "\u003cp\u003e\u003cstrong\u003e6.S081\u003c/strong\u003e 是非常著名的 MIT 操作系统课程。该公开课链接的年份后缀的是可以更改的，这个课程提供的可编程 lab 每年都稍微有些不同，每个 lab 的自评测中的 answers-*.txt 和 time.txt 需要自行填写。 本篇文章对应的是\u003ca href=\"https://pdos.csail.mit.edu/6.828/2024/\"\u003e 2024 年度课程\u003c/a\u003e的实现总结。\u003c/p\u003e",
      "inLanguage": "zh-cn",
      "potentialAction": [
        {
          "@type": "ReadAction",
          "target": [
            "https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/"
          ]
        }
      ]
    },
    {
      "@type": "Article",
      "isPartOf": {
        "@id": "https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/#webpage"
      },
      "mainEntityOfPage": {
        "@id": "https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/#webpage"
      },
      "headline": "MIT 公开课 6.S081 实现总结",
      "datePublished": "2025-08-20T09:43:31+08:00",
      "dateModified": "2025-08-20T09:43:31+08:00",
      "publisher": {
        "@id": "https://www.zhangzewen.net/#author"
      },
      "keywords": [
        "公开课",
        "操作系统",
        "Linux",
        "Mit",
        "Xv6"
      ],
      "articleSection": [
      ],
      "inLanguage": "zh-cn",
      "author": {
        "@type": "Person",
        "name":  null 
      },
      "potentialAction": [
        {
          "@type": "CommentAction",
          "name": "Comment",
          "target": [
            "https://www.zhangzewen.net/posts/os/xv6/6.s081_summary/#comments"
          ]
        }
      ]
    }
  ]
}
</script>



  <link type="text/css" rel="stylesheet" href="/css/print.css" media="print">

  <link type="text/css" rel="stylesheet" href="/css/poole.css">

  <link type="text/css" rel="stylesheet" href="/css/hyde.css">

  


  

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
    integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>

<body>
  <aside class="toc">
  
  
  <h3>目录</h3>
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#lab-utilities">Lab Utilities</a></li>
        <li><a href="#lab-system-calls">Lab System calls</a></li>
        <li><a href="#lab-page-tables">Lab Page tables</a></li>
        <li><a href="#lab-traps">Lab Traps</a></li>
        <li><a href="#lab-copy-on-write">Lab Copy on-write</a></li>
        <li><a href="#lab-network-driver">Lab network driver</a></li>
        <li><a href="#lab-lock">Lab Lock</a></li>
        <li><a href="#lab-file-system">Lab File system</a></li>
        <li><a href="#lab-mmap">Lab mmap</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
</aside>

  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <a href="https://www.zhangzewen.net/">
            <img src="/images/android-chrome-512x512.png" class="img-circle img-headshot center" alt="Profile Picture">
          </a>
        </div>
        
      

      <h1>What a Life!</h1>

      
      <p class="lead">Software Engineer</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://www.zhangzewen.net/">Home</a>
        </li>
        <li>
          <a href="/tags/">Tags</a>
        </li><li>
          <a href="/archive/">Archives</a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
    </section>
  </div>
</aside>


  <main class="content container">
    <div class="post">
  <h1 class="title">MIT 公开课 6.S081 实现总结</h1>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


  <div class="post-date">
    <time datetime=" 2025-08-20T09:43:31&#43;0800">Created: Aug 20, 2025</time>
    <span class="readtime">&middot; 75 min read</span>
  </div>

  <div>
    <p><strong>6.S081</strong> 是非常著名的 MIT 操作系统课程。该公开课链接的年份后缀的是可以更改的，这个课程提供的可编程 lab 每年都稍微有些不同，每个 lab 的自评测中的 answers-*.txt 和 time.txt 需要自行填写。 本篇文章对应的是<a href="https://pdos.csail.mit.edu/6.828/2024/"> 2024 年度课程</a>的实现总结。</p>
<h2 id="lab-utilities">Lab Utilities</h2>
<ul>
<li>sleep 实现参考 <code>kill.c</code>，调用 <code>sleep</code> 函数即可。</li>
<li>find 参考 <code>ls</code> 的实现，需要对目录进行递归调用，注意处理 <code>.</code> 和 <code>..</code> 的情况。</li>
<li>pingpong 考查对进程间 pipe 的使用。</li>
<li>primes 照着其提供的<a href="https://swtch.com/~rsc/thread/">资料</a>上的图，首先想到的是递归，但是有进程数量的限制，所以解法是：一个进程生产数据，然后循环生成进程来读取数据判断是不是素数。</li>
<li>xargs 重新组装参数列表，fork 后子进程调用 <code>exec</code>。</li>
</ul>
<p>lab 打分运行结果如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./grade-lab-util
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel&#39; is up to date.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test sleep, no <span style="color:#8be9fd;font-style:italic">arguments</span> <span style="color:#ff79c6">==</span> sleep, no arguments: OK <span style="color:#ff79c6">(</span>1.6s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test sleep, <span style="color:#8be9fd;font-style:italic">returns</span> <span style="color:#ff79c6">==</span> sleep, returns: OK <span style="color:#ff79c6">(</span>0.9s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test sleep, makes <span style="color:#8be9fd;font-style:italic">syscall</span> <span style="color:#ff79c6">==</span> sleep, makes syscall: OK <span style="color:#ff79c6">(</span>1.1s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">pingpong</span> <span style="color:#ff79c6">==</span> pingpong: OK <span style="color:#ff79c6">(</span>1.0s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">primes</span> <span style="color:#ff79c6">==</span> primes: OK <span style="color:#ff79c6">(</span>2.1s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">(</span>Old xv6.out.primes failure log removed<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test find, in current <span style="color:#8be9fd;font-style:italic">directory</span> <span style="color:#ff79c6">==</span> find, in current directory: OK <span style="color:#ff79c6">(</span>1.0s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test find, in sub-directory <span style="color:#ff79c6">==</span> find, in sub-directory: OK <span style="color:#ff79c6">(</span>1.3s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test find, <span style="color:#8be9fd;font-style:italic">recursive</span> <span style="color:#ff79c6">==</span> find, recursive: OK <span style="color:#ff79c6">(</span>1.6s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">xargs</span> <span style="color:#ff79c6">==</span> xargs: OK <span style="color:#ff79c6">(</span>1.7s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test xargs, multi-line <span style="color:#8be9fd;font-style:italic">echo</span> <span style="color:#ff79c6">==</span> xargs, multi-line echo: OK <span style="color:#ff79c6">(</span>0.7s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 109/110
</span></span></code></pre></div>
</details>

<p>实现代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/Makefile b/Makefile
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 74e454f..bff9ef0 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -194,6 +194,11 @@ UPROGS=\
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 	$U/_grind\
</span></span><span style="display:flex;"><span> 	$U/_wc\
</span></span><span style="display:flex;"><span> 	$U/_zombie\
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_sleep\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_pingpong\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_primes\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_find\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_xargs\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/find.c b/user/find.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>new file mode 100644
</span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0000000..2c0a1b9
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- /dev/null
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/find.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -0,0 +1,86 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/types.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/fcntl.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/fs.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/stat.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;user/user.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *fmtname(char *path) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  static char buf[DIRSIZ + 1];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *p;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  // Find first character after last slash.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (p = path + strlen(path); p &gt;= path &amp;&amp; *p != &#39;/&#39;; p--)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    ;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p++;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  // Return blank-padded name.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (strlen(p) &gt;= DIRSIZ)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return p;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  memmove(buf, p, strlen(p));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  memset(buf + strlen(p), &#39; &#39;, DIRSIZ - strlen(p));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return buf;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void find(char *path, char *filename) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char buf[512], *p;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int fd;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct stat st;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct dirent de;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if ((fd = open(path, O_RDONLY)) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    fprintf(2, &#34;find: cannot open %s\n&#34;, path);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (fstat(fd, &amp;st) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    fprintf(2, &#34;find: cannot stat %s\n&#34;, path);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    close(fd);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  switch (st.type) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  case T_DEVICE:
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  case T_FILE:
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (strncmp(fmtname(path), filename, strlen(filename)) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;%s\n&#34;, path);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  case T_DIR:
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;find: path too long\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    strcpy(buf, path);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p = buf + strlen(buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    *p++ = &#39;/&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    // find(buf, filename);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (de.inum == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        continue;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      memmove(p, de.name, DIRSIZ);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p[DIRSIZ] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (stat(buf, &amp;st) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        printf(&#34;find: cannot stat %s\n&#34;, buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        continue;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (strncmp(fmtname(buf), &#34;..&#34;, 2) == 0 ||
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+          strncmp(fmtname(buf), &#34;.&#34;, 1) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        continue;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      find(buf, filename);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  close(fd);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int main(int argc, char *argv[]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (argc &lt; 3) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    fprintf(2, &#34;Usage: find path filename ...\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  find(argv[1], argv[2]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  exit(0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/pingpong.c b/user/pingpong.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>new file mode 100644
</span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0000000..e5e9537
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- /dev/null
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/pingpong.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -0,0 +1,36 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/types.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;user/user.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int main(int argc, char **argv) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int pipefd[2];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char buf;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int cpid;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (pipe(pipefd) == -1) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  cpid = fork();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (cpid == -1) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    printf(&#34;fork error!\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (cpid == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    read(pipefd[0], &amp;buf, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    printf(&#34;%d: received ping\n&#34;, getpid());
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    close(pipefd[0]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    write(pipefd[1], &amp;buf, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    close(pipefd[1]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    exit(0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    write(pipefd[1], &amp;buf, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    wait((int *)0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    close(pipefd[1]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    read(pipefd[0], &amp;buf, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    printf(&#34;%d: received pong\n&#34;, getpid());
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    close(pipefd[0]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    exit(0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/primes.c b/user/primes.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>new file mode 100644
</span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0000000..45689ee
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- /dev/null
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/primes.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -0,0 +1,4 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/types.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;user/user.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int main(int argc, char *argv[]) { return 0; }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/sleep.c b/user/sleep.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>new file mode 100644
</span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0000000..f4adce0
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- /dev/null
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/sleep.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -0,0 +1,12 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/types.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;user/user.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int main(int argc, char **argv) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (argc &lt; 2) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    fprintf(2, &#34;Usage: sleep number(an interval of time)...\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int sleepn = atoi(argv[1]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  sleep(sleepn);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/ulib.c b/user/ulib.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0064846..031bdca 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/ulib.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/ulib.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,134 +1,126 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;kernel/types.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#f55">-#include &#34;kernel/stat.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;kernel/fcntl.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/stat.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;user/user.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> //
</span></span><span style="display:flex;"><span> // wrapper so that it&#39;s OK if main() does not call exit().
</span></span><span style="display:flex;"><span> //
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-start()
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void start() {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   extern int main();
</span></span><span style="display:flex;"><span>   main();
</span></span><span style="display:flex;"><span>   exit(0);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-char*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-strcpy(char *s, const char *t)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+char *strcpy(char *s, const char *t) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   char *os;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   os = s;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  while((*s++ = *t++) != 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  while ((*s++ = *t++) != 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     ;
</span></span><span style="display:flex;"><span>   return os;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-strcmp(const char *p, const char *q)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  while(*p &amp;&amp; *p == *q)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int strcmp(const char *p, const char *q) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while (*p &amp;&amp; *p == *q)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     p++, q++;
</span></span><span style="display:flex;"><span>   return (uchar)*p - (uchar)*q;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-strlen(const char *s)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int strncmp(const char *p, const char *q, int n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while (n &gt; 0 &amp;&amp; *p &amp;&amp; *p == *q) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p++;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    q++;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    n--;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (n == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return (uchar)*p - (uchar)*q;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint strlen(const char *s) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int n;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(n = 0; s[n]; n++)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (n = 0; s[n]; n++)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     ;
</span></span><span style="display:flex;"><span>   return n;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-void*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-memset(void *dst, int c, uint n)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  char *cdst = (char *) dst;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void *memset(void *dst, int c, uint n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *cdst = (char *)dst;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int i;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(i = 0; i &lt; n; i++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (i = 0; i &lt; n; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     cdst[i] = c;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   return dst;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-char*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-strchr(const char *s, char c)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  for(; *s; s++)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(*s == c)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      return (char*)s;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+char *strchr(const char *s, char c) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (; *s; s++)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (*s == c)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return (char *)s;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-char*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-gets(char *buf, int max)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+char *gets(char *buf, int max) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int i, cc;
</span></span><span style="display:flex;"><span>   char c;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(i=0; i+1 &lt; max; ){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (i = 0; i + 1 &lt; max;) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     cc = read(0, &amp;c, 1);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(cc &lt; 1)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (cc &lt; 1)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       break;
</span></span><span style="display:flex;"><span>     buf[i++] = c;
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(c == &#39;\n&#39; || c == &#39;\r&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (c == &#39;\n&#39; || c == &#39;\r&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       break;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   buf[i] = &#39;\0&#39;;
</span></span><span style="display:flex;"><span>   return buf;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-stat(const char *n, struct stat *st)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int stat(const char *n, struct stat *st) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int fd;
</span></span><span style="display:flex;"><span>   int r;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   fd = open(n, O_RDONLY);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(fd &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (fd &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   r = fstat(fd, st);
</span></span><span style="display:flex;"><span>   close(fd);
</span></span><span style="display:flex;"><span>   return r;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-atoi(const char *s)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int atoi(const char *s) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int n;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   n = 0;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  while(&#39;0&#39; &lt;= *s &amp;&amp; *s &lt;= &#39;9&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    n = n*10 + *s++ - &#39;0&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  while (&#39;0&#39; &lt;= *s &amp;&amp; *s &lt;= &#39;9&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    n = n * 10 + *s++ - &#39;0&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   return n;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-void*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-memmove(void *vdst, const void *vsrc, int n)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void *memmove(void *vdst, const void *vsrc, int n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   char *dst;
</span></span><span style="display:flex;"><span>   const char *src;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   dst = vdst;
</span></span><span style="display:flex;"><span>   src = vsrc;
</span></span><span style="display:flex;"><span>   if (src &gt; dst) {
</span></span><span style="display:flex;"><span><span style="color:#f55">-    while(n-- &gt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    while (n-- &gt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       *dst++ = *src++;
</span></span><span style="display:flex;"><span>   } else {
</span></span><span style="display:flex;"><span>     dst += n;
</span></span><span style="display:flex;"><span>     src += n;
</span></span><span style="display:flex;"><span><span style="color:#f55">-    while(n-- &gt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    while (n-- &gt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       *--dst = *--src;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   return vdst;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-memcmp(const void *s1, const void *s2, uint n)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int memcmp(const void *s1, const void *s2, uint n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   const char *p1 = s1, *p2 = s2;
</span></span><span style="display:flex;"><span>   while (n-- &gt; 0) {
</span></span><span style="display:flex;"><span>     if (*p1 != *p2) {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -140,8 +132,6 @@ memcmp(const void *s1, const void *s2, uint n)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-void *
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-memcpy(void *dst, const void *src, uint n)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void *memcpy(void *dst, const void *src, uint n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   return memmove(dst, src, n);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/user.h b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f16fe27..252bd3b 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -3,41 +3,42 @@ struct stat;
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // system calls
</span></span><span style="display:flex;"><span> int fork(void);
</span></span><span style="display:flex;"><span> int exit(int) __attribute__((noreturn));
</span></span><span style="display:flex;"><span><span style="color:#f55">-int wait(int*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int pipe(int*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int write(int, const void*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int read(int, void*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int wait(int *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int pipe(int *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int write(int, const void *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int read(int, void *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int close(int);
</span></span><span style="display:flex;"><span> int kill(int);
</span></span><span style="display:flex;"><span><span style="color:#f55">-int exec(const char*, char**);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int open(const char*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int mknod(const char*, short, short);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int unlink(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int fstat(int fd, struct stat*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int link(const char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int mkdir(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int chdir(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int exec(const char *, char **);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int open(const char *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int mknod(const char *, short, short);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int unlink(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int fstat(int fd, struct stat *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int link(const char *, const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int mkdir(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int chdir(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int dup(int);
</span></span><span style="display:flex;"><span> int getpid(void);
</span></span><span style="display:flex;"><span><span style="color:#f55">-char* sbrk(int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+char *sbrk(int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int sleep(int);
</span></span><span style="display:flex;"><span> int uptime(void);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // ulib.c
</span></span><span style="display:flex;"><span><span style="color:#f55">-int stat(const char*, struct stat*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-char* strcpy(char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void *memmove(void*, const void*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-char* strchr(const char*, char c);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int strcmp(const char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void fprintf(int, const char*, ...) __attribute__ ((format (printf, 2, 3)));
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void printf(const char*, ...) __attribute__ ((format (printf, 1, 2)));
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-char* gets(char*, int max);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-uint strlen(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void* memset(void*, int, uint);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int atoi(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int stat(const char *, struct stat *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *strcpy(char *, const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void *memmove(void *, const void *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *strchr(const char *, char c);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int strcmp(const char *, const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int strncmp(const char *, const char *, int n);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void fprintf(int, const char *, ...) __attribute__((format(printf, 2, 3)));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void printf(const char *, ...) __attribute__((format(printf, 1, 2)));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *gets(char *, int max);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint strlen(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void *memset(void *, int, uint);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int atoi(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int memcmp(const void *, const void *, uint);
</span></span><span style="display:flex;"><span> void *memcpy(void *, const void *, uint);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // umalloc.c
</span></span><span style="display:flex;"><span><span style="color:#f55">-void* malloc(uint);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void free(void*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void *malloc(uint);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void free(void *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/xargs.c b/user/xargs.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>new file mode 100644
</span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0000000..686eaf7
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- /dev/null
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/xargs.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -0,0 +1,30 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/types.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/param.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;user/user.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int main(int argc, char *argv[]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *new_argv[MAXARG];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int i = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (; i &lt; argc; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    new_argv[i] = argv[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char buff[256];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while (1) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    int count = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    while (read(0, buff + count, sizeof(char)) != 0 &amp;&amp; buff[count] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      count++;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (count == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    buff[count] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    new_argv[i] = buff;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    new_argv[i + 1] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (fork() == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      exec(new_argv[1], new_argv + 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      wait((int *)0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  exit(0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span></code></pre></div>
</details>

<h2 id="lab-system-calls">Lab System calls</h2>
<p><code>trace</code> 这个比较简单，其核心是对寄存器 <code>a7</code> 的理解并在 <code>syscall</code> 处添加代码，然后就是根据 <code>struct proc</code> 资源的申请和释放，依葫芦画瓢添加字段即可。</p>
<p><code>attack</code> 这个纯靠阅读代码搞清楚 page 的分配逻辑，再说直白一点就是 <code>kalloc</code> 和 <code>kfree</code> 中链表的操作。</p>
<p>lab 打分运行结果如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./grade-lab-syscall
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel&#39; is up to date.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test answers-syscall.txt <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>answers-syscall.txt: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> answers-syscall.txt
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test trace <span style="color:#bd93f9">32</span> <span style="color:#8be9fd;font-style:italic">grep</span> <span style="color:#ff79c6">==</span> trace <span style="color:#bd93f9">32</span> grep: OK <span style="color:#ff79c6">(</span>1.6s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test trace close <span style="color:#8be9fd;font-style:italic">grep</span> <span style="color:#ff79c6">==</span> trace close grep: OK <span style="color:#ff79c6">(</span>0.9s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test trace <span style="color:#8be9fd;font-style:italic">exec</span> + open <span style="color:#8be9fd;font-style:italic">grep</span> <span style="color:#ff79c6">==</span> trace <span style="color:#8be9fd;font-style:italic">exec</span> + open grep: OK <span style="color:#ff79c6">(</span>0.9s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test trace all <span style="color:#8be9fd;font-style:italic">grep</span> <span style="color:#ff79c6">==</span> trace all grep: OK <span style="color:#ff79c6">(</span>1.0s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test trace <span style="color:#8be9fd;font-style:italic">nothing</span> <span style="color:#ff79c6">==</span> trace nothing: OK <span style="color:#ff79c6">(</span>1.0s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test trace <span style="color:#8be9fd;font-style:italic">children</span> <span style="color:#ff79c6">==</span> trace children: OK <span style="color:#ff79c6">(</span>26.4s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">(</span>Old xv6.out.trace_children failure log removed<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">attack</span> <span style="color:#ff79c6">==</span> attack: OK <span style="color:#ff79c6">(</span>0.6s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 44/50
</span></span></code></pre></div>
</details>

<p>上面结果是注释 case: <code>r.match('^\\d+: syscall fork -&gt; -1')</code> 后的结果（暂时还没有去搞清楚这个 case，先搁置）， 在交互环境下(<code>make qemu</code>) 直接执行是通过的：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ make qemu
</span></span><span style="display:flex;"><span>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp <span style="color:#bd93f9">3</span> -nographic -global virtio-mmio.force-legacy<span style="color:#ff79c6">=</span><span style="color:#8be9fd;font-style:italic">false</span> -drive <span style="color:#8be9fd;font-style:italic">file</span><span style="color:#ff79c6">=</span>fs.img,if<span style="color:#ff79c6">=</span>none,format<span style="color:#ff79c6">=</span>raw,id<span style="color:#ff79c6">=</span>x0 -device virtio-blk-device,drive<span style="color:#ff79c6">=</span>x0,bus<span style="color:#ff79c6">=</span>virtio-mmio-bus.0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xv6 kernel is booting
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hart <span style="color:#bd93f9">2</span> starting
</span></span><span style="display:flex;"><span>hart <span style="color:#bd93f9">1</span> starting
</span></span><span style="display:flex;"><span>init: starting sh
</span></span><span style="display:flex;"><span>$ trace <span style="color:#bd93f9">2</span> usertests forkforkfork
</span></span><span style="display:flex;"><span>usertests starting
</span></span><span style="display:flex;"><span>3: syscall fork -&gt; <span style="color:#bd93f9">4</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">test</span> forkforkfork: 3: syscall fork -&gt; <span style="color:#bd93f9">5</span>
</span></span><span style="display:flex;"><span>5: syscall fork -&gt; <span style="color:#bd93f9">6</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">7</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">8</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">9</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">10</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">11</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">12</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">13</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">14</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">15</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">16</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">17</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">18</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">19</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">20</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">21</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">22</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">23</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">24</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">25</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">26</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">27</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">28</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">29</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">30</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">31</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">32</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">33</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">34</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">35</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">36</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">37</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">38</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">39</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">40</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">41</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">42</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">43</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">44</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">45</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">46</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">47</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">48</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">49</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">50</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">51</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">52</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">53</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">54</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">55</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">56</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">57</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">58</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">59</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">60</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">61</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">62</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">63</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">64</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">65</span>
</span></span><span style="display:flex;"><span>8: syscall fork -&gt; <span style="color:#bd93f9">18446744073709551615</span>
</span></span><span style="display:flex;"><span>6: syscall fork -&gt; <span style="color:#bd93f9">18446744073709551615</span>
</span></span><span style="display:flex;"><span>7: syscall fork -&gt; <span style="color:#bd93f9">18446744073709551615</span>
</span></span><span style="display:flex;"><span>9: syscall fork -&gt; <span style="color:#bd93f9">18446744073709551615</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>3: syscall fork -&gt; <span style="color:#bd93f9">66</span>
</span></span><span style="display:flex;"><span>ALL TESTS PASSED
</span></span><span style="display:flex;"><span>$
</span></span></code></pre></div>
</details>

<p>实现代码如下，因为自动格式化的缘故导致该 diff 看起来改动挺多，见谅：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/Makefile b/Makefile
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 74e454f..2d9a763 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -194,6 +194,7 @@ UPROGS=\
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 	$U/_grind\
</span></span><span style="display:flex;"><span> 	$U/_wc\
</span></span><span style="display:flex;"><span> 	$U/_zombie\
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_trace\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/proc.c b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 130d9ce..e07786e 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,9 +1,15 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;types.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;param.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;memlayout.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;riscv.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;spinlock.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;proc.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> struct cpu cpus[NCPU];
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -29,59 +35,50 @@ struct spinlock wait_lock;
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Allocate a page for each process&#39;s kernel stack.
</span></span><span style="display:flex;"><span> // Map it high in memory, followed by an invalid
</span></span><span style="display:flex;"><span> // guard page.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-proc_mapstacks(pagetable_t kpgtbl)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void proc_mapstacks(pagetable_t kpgtbl) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     char *pa = kalloc();
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(pa == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (pa == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       panic(&#34;kalloc&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    uint64 va = KSTACK((int) (p - proc));
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    uint64 va = KSTACK((int)(p - proc));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // initialize the proc table.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-procinit(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void procinit(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   initlock(&amp;pid_lock, &#34;nextpid&#34;);
</span></span><span style="display:flex;"><span>   initlock(&amp;wait_lock, &#34;wait_lock&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      initlock(&amp;p-&gt;lock, &#34;proc&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      p-&gt;state = UNUSED;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      p-&gt;kstack = KSTACK((int) (p - proc));
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    initlock(&amp;p-&gt;lock, &#34;proc&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;state = UNUSED;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;kstack = KSTACK((int)(p - proc));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;trace_syscall = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Must be called with interrupts disabled,
</span></span><span style="display:flex;"><span> // to prevent race with process being moved
</span></span><span style="display:flex;"><span> // to a different CPU.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-cpuid()
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int cpuid() {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int id = r_tp();
</span></span><span style="display:flex;"><span>   return id;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Return this CPU&#39;s cpu struct.
</span></span><span style="display:flex;"><span> // Interrupts must be disabled.
</span></span><span style="display:flex;"><span><span style="color:#f55">-struct cpu*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-mycpu(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+struct cpu *mycpu(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int id = cpuid();
</span></span><span style="display:flex;"><span>   struct cpu *c = &amp;cpus[id];
</span></span><span style="display:flex;"><span>   return c;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Return the current struct proc *, or zero if none.
</span></span><span style="display:flex;"><span><span style="color:#f55">-struct proc*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-myproc(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+struct proc *myproc(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   push_off();
</span></span><span style="display:flex;"><span>   struct cpu *c = mycpu();
</span></span><span style="display:flex;"><span>   struct proc *p = c-&gt;proc;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -89,11 +86,9 @@ myproc(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return p;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-allocpid()
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int allocpid() {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int pid;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   acquire(&amp;pid_lock);
</span></span><span style="display:flex;"><span>   pid = nextpid;
</span></span><span style="display:flex;"><span>   nextpid = nextpid + 1;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -106,14 +101,12 @@ allocpid()
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // If found, initialize state required to run in the kernel,
</span></span><span style="display:flex;"><span> // and return with p-&gt;lock held.
</span></span><span style="display:flex;"><span> // If there are no free procs, or a memory allocation fails, return 0.
</span></span><span style="display:flex;"><span><span style="color:#f55">-static struct proc*
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-allocproc(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+static struct proc *allocproc(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p-&gt;state == UNUSED) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;state == UNUSED) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       goto found;
</span></span><span style="display:flex;"><span>     } else {
</span></span><span style="display:flex;"><span>       release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -126,7 +119,7 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   p-&gt;state = USED;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Allocate a trapframe page.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if ((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     freeproc(p);
</span></span><span style="display:flex;"><span>     release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span>     return 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -134,7 +127,7 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // An empty user page table.
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = proc_pagetable(p);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(p-&gt;pagetable == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (p-&gt;pagetable == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     freeproc(p);
</span></span><span style="display:flex;"><span>     release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span>     return 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -152,13 +145,11 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // free a proc structure and the data hanging from it,
</span></span><span style="display:flex;"><span> // including user pages.
</span></span><span style="display:flex;"><span> // p-&gt;lock must be held.
</span></span><span style="display:flex;"><span><span style="color:#f55">-static void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-freeproc(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  if(p-&gt;trapframe)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    kfree((void*)p-&gt;trapframe);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+static void freeproc(struct proc *p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (p-&gt;trapframe)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree((void *)p-&gt;trapframe);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   p-&gt;trapframe = 0;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(p-&gt;pagetable)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (p-&gt;pagetable)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = 0;
</span></span><span style="display:flex;"><span>   p-&gt;sz = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -173,30 +164,28 @@ freeproc(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Create a user page table for a given process, with no user memory,
</span></span><span style="display:flex;"><span> // but with trampoline and trapframe pages.
</span></span><span style="display:flex;"><span><span style="color:#f55">-pagetable_t
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-proc_pagetable(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+pagetable_t proc_pagetable(struct proc *p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   pagetable_t pagetable;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // An empty page table.
</span></span><span style="display:flex;"><span>   pagetable = uvmcreate();
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(pagetable == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (pagetable == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return 0;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // map the trampoline code (for system call return)
</span></span><span style="display:flex;"><span>   // at the highest user virtual address.
</span></span><span style="display:flex;"><span>   // only the supervisor uses it, on the way
</span></span><span style="display:flex;"><span>   // to/from user space, so not PTE_U.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-              (uint64)trampoline, PTE_R | PTE_X) &lt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+               PTE_R | PTE_X) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     uvmfree(pagetable, 0);
</span></span><span style="display:flex;"><span>     return 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // map the trapframe page just below the trampoline page, for
</span></span><span style="display:flex;"><span>   // trampoline.S.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-&gt;trapframe),
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+               PTE_R | PTE_W) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
</span></span><span style="display:flex;"><span>     uvmfree(pagetable, 0);
</span></span><span style="display:flex;"><span>     return 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -207,9 +196,7 @@ proc_pagetable(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Free a process&#39;s page table, and free the
</span></span><span style="display:flex;"><span> // physical memory it refers to.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-proc_freepagetable(pagetable_t pagetable, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void proc_freepagetable(pagetable_t pagetable, uint64 sz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
</span></span><span style="display:flex;"><span>   uvmunmap(pagetable, TRAPFRAME, 1, 0);
</span></span><span style="display:flex;"><span>   uvmfree(pagetable, sz);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -218,33 +205,28 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // a user program that calls exec(&#34;/init&#34;)
</span></span><span style="display:flex;"><span> // assembled from ../user/initcode.S
</span></span><span style="display:flex;"><span> // od -t xC ../user/initcode
</span></span><span style="display:flex;"><span><span style="color:#f55">-uchar initcode[] = {
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  0x00, 0x00, 0x00, 0x00
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-};
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uchar initcode[] = {0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02, 0x97,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                    0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02, 0x93, 0x08,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                    0x70, 0x00, 0x73, 0x00, 0x00, 0x00, 0x93, 0x08, 0x20,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                    0x00, 0x73, 0x00, 0x00, 0x00, 0xef, 0xf0, 0x9f, 0xff,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                    0x2f, 0x69, 0x6e, 0x69, 0x74, 0x00, 0x00, 0x24, 0x00,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Set up first user process.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-userinit(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void userinit(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   p = allocproc();
</span></span><span style="display:flex;"><span>   initproc = p;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   // allocate one user page and copy initcode&#39;s instructions
</span></span><span style="display:flex;"><span>   // and data into it.
</span></span><span style="display:flex;"><span>   uvmfirst(p-&gt;pagetable, initcode, sizeof(initcode));
</span></span><span style="display:flex;"><span>   p-&gt;sz = PGSIZE;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // prepare for the very first &#34;return&#34; from kernel to user.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  p-&gt;trapframe-&gt;epc = 0;      // user program counter
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  p-&gt;trapframe-&gt;sp = PGSIZE;  // user stack pointer
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;trapframe-&gt;epc = 0;     // user program counter
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;trapframe-&gt;sp = PGSIZE; // user stack pointer
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   safestrcpy(p-&gt;name, &#34;initcode&#34;, sizeof(p-&gt;name));
</span></span><span style="display:flex;"><span>   p-&gt;cwd = namei(&#34;/&#34;);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -256,18 +238,16 @@ userinit(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Grow or shrink user memory by n bytes.
</span></span><span style="display:flex;"><span> // Return 0 on success, -1 on failure.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-growproc(int n)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int growproc(int n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uint64 sz;
</span></span><span style="display:flex;"><span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   sz = p-&gt;sz;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(n &gt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (n &gt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((sz = uvmalloc(p-&gt;pagetable, sz, sz + n, PTE_W)) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       return -1;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span><span style="color:#f55">-  } else if(n &lt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  } else if (n &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   p-&gt;sz = sz;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -276,20 +256,18 @@ growproc(int n)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Create a new process, copying the parent.
</span></span><span style="display:flex;"><span> // Sets up child kernel stack to return as if from fork() system call.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-fork(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int fork(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int i, pid;
</span></span><span style="display:flex;"><span>   struct proc *np;
</span></span><span style="display:flex;"><span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Allocate process.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if((np = allocproc()) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if ((np = allocproc()) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Copy user memory from parent to child.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     freeproc(np);
</span></span><span style="display:flex;"><span>     release(&amp;np-&gt;lock);
</span></span><span style="display:flex;"><span>     return -1;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -301,10 +279,11 @@ fork(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // Cause fork to return 0 in the child.
</span></span><span style="display:flex;"><span>   np-&gt;trapframe-&gt;a0 = 0;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  np-&gt;trace_syscall = p-&gt;trace_syscall;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // increment reference counts on open file descriptors.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(i = 0; i &lt; NOFILE; i++)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p-&gt;ofile[i])
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (i = 0; i &lt; NOFILE; i++)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;ofile[i])
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);
</span></span><span style="display:flex;"><span>   np-&gt;cwd = idup(p-&gt;cwd);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -327,13 +306,11 @@ fork(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Pass p&#39;s abandoned children to init.
</span></span><span style="display:flex;"><span> // Caller must hold wait_lock.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-reparent(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void reparent(struct proc *p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *pp;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(pp = proc; pp &lt; &amp;proc[NPROC]; pp++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(pp-&gt;parent == p){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (pp = proc; pp &lt; &amp;proc[NPROC]; pp++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (pp-&gt;parent == p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       pp-&gt;parent = initproc;
</span></span><span style="display:flex;"><span>       wakeup(initproc);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -343,22 +320,21 @@ reparent(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Exit the current process.  Does not return.
</span></span><span style="display:flex;"><span> // An exited process remains in the zombie state
</span></span><span style="display:flex;"><span> // until its parent calls wait().
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-exit(int status)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void exit(int status) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(p == initproc)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (p == initproc)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     panic(&#34;init exiting&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Close all open files.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(int fd = 0; fd &lt; NOFILE; fd++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p-&gt;ofile[fd]){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (int fd = 0; fd &lt; NOFILE; fd++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;ofile[fd]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       struct file *f = p-&gt;ofile[fd];
</span></span><span style="display:flex;"><span>       fileclose(f);
</span></span><span style="display:flex;"><span>       p-&gt;ofile[fd] = 0;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;trace_syscall = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   begin_op();
</span></span><span style="display:flex;"><span>   iput(p-&gt;cwd);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -372,7 +348,7 @@ exit(int status)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // Parent might be sleeping in wait().
</span></span><span style="display:flex;"><span>   wakeup(p-&gt;parent);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   p-&gt;xstate = status;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -387,29 +363,27 @@ exit(int status)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Wait for a child process to exit and return its pid.
</span></span><span style="display:flex;"><span> // Return -1 if this process has no children.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-wait(uint64 addr)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int wait(uint64 addr) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *pp;
</span></span><span style="display:flex;"><span>   int havekids, pid;
</span></span><span style="display:flex;"><span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   acquire(&amp;wait_lock);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(;;){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (;;) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     // Scan through table looking for exited children.
</span></span><span style="display:flex;"><span>     havekids = 0;
</span></span><span style="display:flex;"><span><span style="color:#f55">-    for(pp = proc; pp &lt; &amp;proc[NPROC]; pp++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      if(pp-&gt;parent == p){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    for (pp = proc; pp &lt; &amp;proc[NPROC]; pp++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (pp-&gt;parent == p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>         // make sure the child isn&#39;t still in exit() or swtch().
</span></span><span style="display:flex;"><span>         acquire(&amp;pp-&gt;lock);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>         havekids = 1;
</span></span><span style="display:flex;"><span><span style="color:#f55">-        if(pp-&gt;state == ZOMBIE){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+        if (pp-&gt;state == ZOMBIE) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>           // Found one.
</span></span><span style="display:flex;"><span>           pid = pp-&gt;pid;
</span></span><span style="display:flex;"><span><span style="color:#f55">-          if(addr != 0 &amp;&amp; copyout(p-&gt;pagetable, addr, (char *)&amp;pp-&gt;xstate,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-                                  sizeof(pp-&gt;xstate)) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+          if (addr != 0 &amp;&amp; copyout(p-&gt;pagetable, addr, (char *)&amp;pp-&gt;xstate,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                                   sizeof(pp-&gt;xstate)) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>             release(&amp;pp-&gt;lock);
</span></span><span style="display:flex;"><span>             release(&amp;wait_lock);
</span></span><span style="display:flex;"><span>             return -1;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -424,13 +398,13 @@ wait(uint64 addr)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>     // No point waiting if we don&#39;t have any children.
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(!havekids || killed(p)){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (!havekids || killed(p)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       release(&amp;wait_lock);
</span></span><span style="display:flex;"><span>       return -1;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span><span style="color:#f55">-    
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     // Wait for a child to exit.
</span></span><span style="display:flex;"><span><span style="color:#f55">-    sleep(p, &amp;wait_lock);  //DOC: wait-sleep
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    sleep(p, &amp;wait_lock); // DOC: wait-sleep
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -441,23 +415,21 @@ wait(uint64 addr)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> //  - swtch to start running that process.
</span></span><span style="display:flex;"><span> //  - eventually that process transfers control
</span></span><span style="display:flex;"><span> //    via swtch back to the scheduler.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-scheduler(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void scheduler(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span>   struct cpu *c = mycpu();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   c-&gt;proc = 0;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(;;){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (;;) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     // The most recent process to run may have had interrupts
</span></span><span style="display:flex;"><span>     // turned off; enable them to avoid a deadlock if all
</span></span><span style="display:flex;"><span>     // processes are waiting.
</span></span><span style="display:flex;"><span>     intr_on();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>     int found = 0;
</span></span><span style="display:flex;"><span><span style="color:#f55">-    for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="color:#f55">-      if(p-&gt;state == RUNNABLE) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+      if (p-&gt;state == RUNNABLE) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>         // Switch to chosen process.  It is the process&#39;s job
</span></span><span style="display:flex;"><span>         // to release its lock and then reacquire it
</span></span><span style="display:flex;"><span>         // before jumping back to us.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -472,7 +444,7 @@ scheduler(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>       }
</span></span><span style="display:flex;"><span>       release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(found == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (found == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       // nothing to run; stop running on this core until an interrupt.
</span></span><span style="display:flex;"><span>       intr_on();
</span></span><span style="display:flex;"><span>       asm volatile(&#34;wfi&#34;);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -487,19 +459,17 @@ scheduler(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // be proc-&gt;intena and proc-&gt;noff, but that would
</span></span><span style="display:flex;"><span> // break in the few places where a lock is held but
</span></span><span style="display:flex;"><span> // there&#39;s no process.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sched(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void sched(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int intena;
</span></span><span style="display:flex;"><span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(!holding(&amp;p-&gt;lock))
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (!holding(&amp;p-&gt;lock))
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     panic(&#34;sched p-&gt;lock&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(mycpu()-&gt;noff != 1)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (mycpu()-&gt;noff != 1)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     panic(&#34;sched locks&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(p-&gt;state == RUNNING)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (p-&gt;state == RUNNING)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     panic(&#34;sched running&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(intr_get())
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (intr_get())
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     panic(&#34;sched interruptible&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   intena = mycpu()-&gt;intena;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -508,9 +478,7 @@ sched(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Give up the CPU for one scheduling round.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-yield(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void yield(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span>   acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span>   p-&gt;state = RUNNABLE;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -520,9 +488,7 @@ yield(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // A fork child&#39;s very first scheduling by scheduler()
</span></span><span style="display:flex;"><span> // will swtch to forkret.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-forkret(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void forkret(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   static int first = 1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Still holding p-&gt;lock from scheduler.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -544,11 +510,9 @@ forkret(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Atomically release lock and sleep on chan.
</span></span><span style="display:flex;"><span> // Reacquires lock when awakened.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sleep(void *chan, struct spinlock *lk)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void sleep(void *chan, struct spinlock *lk) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   // Must acquire p-&gt;lock in order to
</span></span><span style="display:flex;"><span>   // change p-&gt;state and then call sched.
</span></span><span style="display:flex;"><span>   // Once we hold p-&gt;lock, we can be
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -556,7 +520,7 @@ sleep(void *chan, struct spinlock *lk)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   // (wakeup locks p-&gt;lock),
</span></span><span style="display:flex;"><span>   // so it&#39;s okay to release lk.
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  acquire(&amp;p-&gt;lock);  //DOC: sleeplock1
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;p-&gt;lock); // DOC: sleeplock1
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   release(lk);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Go to sleep.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -575,15 +539,13 @@ sleep(void *chan, struct spinlock *lk)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Wake up all processes sleeping on chan.
</span></span><span style="display:flex;"><span> // Must be called without any p-&gt;lock.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-wakeup(void *chan)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void wakeup(void *chan) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p != myproc()){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p != myproc()) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="color:#f55">-      if(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+      if (p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>         p-&gt;state = RUNNABLE;
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>       release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -594,16 +556,14 @@ wakeup(void *chan)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Kill the process with the given pid.
</span></span><span style="display:flex;"><span> // The victim won&#39;t exit until it tries to return
</span></span><span style="display:flex;"><span> // to user space (see usertrap() in trap.c).
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-kill(int pid)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int kill(int pid) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(p = proc; p &lt; &amp;proc[NPROC]; p++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p-&gt;pid == pid){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;pid == pid) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       p-&gt;killed = 1;
</span></span><span style="display:flex;"><span><span style="color:#f55">-      if(p-&gt;state == SLEEPING){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+      if (p-&gt;state == SLEEPING) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>         // Wake process from sleep().
</span></span><span style="display:flex;"><span>         p-&gt;state = RUNNABLE;
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -615,19 +575,15 @@ kill(int pid)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return -1;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-setkilled(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void setkilled(struct proc *p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span>   p-&gt;killed = 1;
</span></span><span style="display:flex;"><span>   release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-killed(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int killed(struct proc *p) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int k;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   acquire(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span>   k = p-&gt;killed;
</span></span><span style="display:flex;"><span>   release(&amp;p-&gt;lock);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -637,11 +593,9 @@ killed(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Copy to either a user address, or kernel address,
</span></span><span style="display:flex;"><span> // depending on usr_dst.
</span></span><span style="display:flex;"><span> // Returns 0 on success, -1 on error.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int either_copyout(int user_dst, uint64 dst, void *src, uint64 len) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(user_dst){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (user_dst) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return copyout(p-&gt;pagetable, dst, src, len);
</span></span><span style="display:flex;"><span>   } else {
</span></span><span style="display:flex;"><span>     memmove((char *)dst, src, len);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -652,14 +606,12 @@ either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Copy from either a user address, or kernel address,
</span></span><span style="display:flex;"><span> // depending on usr_src.
</span></span><span style="display:flex;"><span> // Returns 0 on success, -1 on error.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-either_copyin(void *dst, int user_src, uint64 src, uint64 len)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int either_copyin(void *dst, int user_src, uint64 src, uint64 len) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(user_src){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (user_src) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return copyin(p-&gt;pagetable, dst, src, len);
</span></span><span style="display:flex;"><span>   } else {
</span></span><span style="display:flex;"><span><span style="color:#f55">-    memmove(dst, (char*)src, len);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    memmove(dst, (char *)src, len);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -667,25 +619,18 @@ either_copyin(void *dst, int user_src, uint64 src, uint64 len)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Print a process listing to console.  For debugging.
</span></span><span style="display:flex;"><span> // Runs when user types ^P on console.
</span></span><span style="display:flex;"><span> // No lock to avoid wedging a stuck machine further.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-procdump(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void procdump(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   static char *states[] = {
</span></span><span style="display:flex;"><span><span style="color:#f55">-  [UNUSED]    &#34;unused&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  [USED]      &#34;used&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  [SLEEPING]  &#34;sleep &#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  [RUNNABLE]  &#34;runble&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  [RUNNING]   &#34;run   &#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  [ZOMBIE]    &#34;zombie&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  };
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+      [UNUSED] &#34;unused&#34;,   [USED] &#34;used&#34;,      [SLEEPING] &#34;sleep &#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      [RUNNABLE] &#34;runble&#34;, [RUNNING] &#34;run   &#34;, [ZOMBIE] &#34;zombie&#34;};
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p;
</span></span><span style="display:flex;"><span>   char *state;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   printf(&#34;\n&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(p = proc; p &lt; &amp;proc[NPROC]; p++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p-&gt;state == UNUSED)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;state == UNUSED)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       continue;
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(p-&gt;state &gt;= 0 &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;state &gt;= 0 &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       state = states[p-&gt;state];
</span></span><span style="display:flex;"><span>     else
</span></span><span style="display:flex;"><span>       state = &#34;???&#34;;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/proc.h b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d021857..218b4bc 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -20,10 +20,10 @@ struct context {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Per-CPU state.
</span></span><span style="display:flex;"><span> struct cpu {
</span></span><span style="display:flex;"><span><span style="color:#f55">-  struct proc *proc;          // The process running on this cpu, or null.
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  struct context context;     // swtch() here to enter scheduler().
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int noff;                   // Depth of push_off() nesting.
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int intena;                 // Were interrupts enabled before push_off()?
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  struct proc *proc;      // The process running on this cpu, or null.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct context context; // swtch() here to enter scheduler().
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int noff;               // Depth of push_off() nesting.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int intena;             // Were interrupts enabled before push_off()?
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> extern struct cpu cpus[NCPU];
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -86,14 +86,14 @@ struct proc {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   struct spinlock lock;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // p-&gt;lock must be held when using these:
</span></span><span style="display:flex;"><span><span style="color:#f55">-  enum procstate state;        // Process state
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  void *chan;                  // If non-zero, sleeping on chan
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int killed;                  // If non-zero, have been killed
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int xstate;                  // Exit status to be returned to parent&#39;s wait
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int pid;                     // Process ID
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  enum procstate state; // Process state
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  void *chan;           // If non-zero, sleeping on chan
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int killed;           // If non-zero, have been killed
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int xstate;           // Exit status to be returned to parent&#39;s wait
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int pid;              // Process ID
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // wait_lock must be held when using this:
</span></span><span style="display:flex;"><span><span style="color:#f55">-  struct proc *parent;         // Parent process
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  struct proc *parent; // Parent process
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // these are private to the process, so p-&gt;lock need not be held.
</span></span><span style="display:flex;"><span>   uint64 kstack;               // Virtual address of kernel stack
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -104,4 +104,5 @@ struct proc {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   struct file *ofile[NOFILE];  // Open files
</span></span><span style="display:flex;"><span>   struct inode *cwd;           // Current directory
</span></span><span style="display:flex;"><span>   char name[16];               // Process name (debugging)
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int trace_syscall;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.c b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index ed65409..e32f325 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,38 +1,40 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;types.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;param.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;memlayout.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;riscv.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;spinlock.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;proc.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;syscall.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Fetch the uint64 at addr from the current process.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-fetchaddr(uint64 addr, uint64 *ip)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int fetchaddr(uint64 addr, uint64 *ip) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(addr &gt;= p-&gt;sz || addr+sizeof(uint64) &gt; p-&gt;sz) // both tests needed, in case of overflow
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (addr &gt;= p-&gt;sz ||
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      addr + sizeof(uint64) &gt; p-&gt;sz) // both tests needed, in case of overflow
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(copyin(p-&gt;pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (copyin(p-&gt;pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Fetch the nul-terminated string at addr from the current process.
</span></span><span style="display:flex;"><span> // Returns length of string, not including nul, or -1 for error.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-fetchstr(uint64 addr, char *buf, int max)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int fetchstr(uint64 addr, char *buf, int max) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (copyinstr(p-&gt;pagetable, buf, addr, max) &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   return strlen(buf);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-static uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-argraw(int n)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+static uint64 argraw(int n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span>   switch (n) {
</span></span><span style="display:flex;"><span>   case 0:
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -53,27 +55,17 @@ argraw(int n)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Fetch the nth 32-bit system call argument.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-argint(int n, int *ip)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  *ip = argraw(n);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-}
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void argint(int n, int *ip) { *ip = argraw(n); }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Retrieve an argument as a pointer.
</span></span><span style="display:flex;"><span> // Doesn&#39;t check for legality, since
</span></span><span style="display:flex;"><span> // copyin/copyout will do that.
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-argaddr(int n, uint64 *ip)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  *ip = argraw(n);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-}
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void argaddr(int n, uint64 *ip) { *ip = argraw(n); }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Fetch the nth word-sized system call argument as a null-terminated string.
</span></span><span style="display:flex;"><span> // Copies into buf, at most max.
</span></span><span style="display:flex;"><span> // Returns string length if OK (including nul), -1 if error.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-argstr(int n, char *buf, int max)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int argstr(int n, char *buf, int max) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uint64 addr;
</span></span><span style="display:flex;"><span>   argaddr(n, &amp;addr);
</span></span><span style="display:flex;"><span>   return fetchstr(addr, buf, max);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -101,47 +93,42 @@ extern uint64 sys_unlink(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> extern uint64 sys_link(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_mkdir(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_close(void);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+extern uint64 sys_trace(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // An array mapping syscall numbers from syscall.h
</span></span><span style="display:flex;"><span> // to the function that handles the system call.
</span></span><span style="display:flex;"><span> static uint64 (*syscalls[])(void) = {
</span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_fork]    sys_fork,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_exit]    sys_exit,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_wait]    sys_wait,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_pipe]    sys_pipe,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_read]    sys_read,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_kill]    sys_kill,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_exec]    sys_exec,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_fstat]   sys_fstat,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_chdir]   sys_chdir,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_dup]     sys_dup,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_getpid]  sys_getpid,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_sbrk]    sys_sbrk,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_sleep]   sys_sleep,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_uptime]  sys_uptime,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_open]    sys_open,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_write]   sys_write,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_mknod]   sys_mknod,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_unlink]  sys_unlink,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_link]    sys_link,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_mkdir]   sys_mkdir,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-[SYS_close]   sys_close,
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_pipe] sys_pipe,   [SYS_read] sys_read,     [SYS_kill] sys_kill,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_exec] sys_exec,   [SYS_fstat] sys_fstat,   [SYS_chdir] sys_chdir,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_dup] sys_dup,     [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    [SYS_trace] sys_trace,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-void
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-syscall(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+static char *syscall_name[] = {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    &#34;unknown&#34;, &#34;fork&#34;,  &#34;exit&#34;,   &#34;wait&#34;,   &#34;pipe&#34;,  &#34;read&#34;,  &#34;kill&#34;,   &#34;exec&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    &#34;fstat&#34;,   &#34;chdir&#34;, &#34;dup&#34;,    &#34;getpid&#34;, &#34;sbrk&#34;,  &#34;sleep&#34;, &#34;uptime&#34;, &#34;open&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    &#34;write&#34;,   &#34;mknod&#34;, &#34;unlink&#34;, &#34;link&#34;,   &#34;mkdir&#34;, &#34;close&#34;, &#34;trace&#34;};
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void syscall(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int num;
</span></span><span style="display:flex;"><span>   struct proc *p = myproc();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   num = p-&gt;trapframe-&gt;a7;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     // Use num to lookup the system call function for num, call it,
</span></span><span style="display:flex;"><span>     // and store its return value in p-&gt;trapframe-&gt;a0
</span></span><span style="display:flex;"><span>     p-&gt;trapframe-&gt;a0 = syscalls[num]();
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;trace_syscall != 0 &amp;&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        (p-&gt;trace_syscall &amp; (1 &lt;&lt; p-&gt;trapframe-&gt;a7)) != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;%d: syscall %s -&gt; %lu\n&#34;, p-&gt;pid, syscall_name[p-&gt;trapframe-&gt;a7],
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+             p-&gt;trapframe-&gt;a0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   } else {
</span></span><span style="display:flex;"><span><span style="color:#f55">-    printf(&#34;%d %s: unknown sys call %d\n&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-            p-&gt;pid, p-&gt;name, num);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    printf(&#34;%d %s: unknown sys call %d\n&#34;, p-&gt;pid, p-&gt;name, num);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     p-&gt;trapframe-&gt;a0 = -1;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.h b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index bc5f356..718190f 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,22 +1,23 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // System call numbers
</span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_fork    1
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_exit    2
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_wait    3
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_pipe    4
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_read    5
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_kill    6
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_exec    7
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_fstat   8
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_chdir   9
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_dup    10
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define SYS_fork 1
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_exit 2
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_wait 3
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_pipe 4
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_read 5
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_kill 6
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_exec 7
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_fstat 8
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_chdir 9
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_dup 10
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #define SYS_getpid 11
</span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_sbrk   12
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_sleep  13
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define SYS_sbrk 12
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_sleep 13
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #define SYS_uptime 14
</span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_open   15
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_write  16
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_mknod  17
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define SYS_open 15
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_write 16
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_mknod 17
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #define SYS_unlink 18
</span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_link   19
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_mkdir  20
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-#define SYS_close  21
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define SYS_link 19
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_mkdir 20
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_close 21
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_trace 22
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/sysproc.c b/kernel/sysproc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 3b4d5bd..9ee7ce5 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/sysproc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/sysproc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,66 +1,56 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;types.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;riscv.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;param.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;memlayout.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;spinlock.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;proc.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_exit(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_exit(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int n;
</span></span><span style="display:flex;"><span>   argint(0, &amp;n);
</span></span><span style="display:flex;"><span>   exit(n);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  return 0;  // not reached
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  return 0; // not reached
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_getpid(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  return myproc()-&gt;pid;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-}
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_getpid(void) { return myproc()-&gt;pid; }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_fork(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  return fork();
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-}
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_fork(void) { return fork(); }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_wait(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_wait(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uint64 p;
</span></span><span style="display:flex;"><span>   argaddr(0, &amp;p);
</span></span><span style="display:flex;"><span>   return wait(p);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_sbrk(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_sbrk(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uint64 addr;
</span></span><span style="display:flex;"><span>   int n;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   argint(0, &amp;n);
</span></span><span style="display:flex;"><span>   addr = myproc()-&gt;sz;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(growproc(n) &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (growproc(n) &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   return addr;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_sleep(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_sleep(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int n;
</span></span><span style="display:flex;"><span>   uint ticks0;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   argint(0, &amp;n);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(n &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (n &lt; 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     n = 0;
</span></span><span style="display:flex;"><span>   acquire(&amp;tickslock);
</span></span><span style="display:flex;"><span>   ticks0 = ticks;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  while(ticks - ticks0 &lt; n){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(killed(myproc())){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  while (ticks - ticks0 &lt; n) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (killed(myproc())) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       release(&amp;tickslock);
</span></span><span style="display:flex;"><span>       return -1;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -70,9 +60,7 @@ sys_sleep(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_kill(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_kill(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int pid;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   argint(0, &amp;pid);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -81,9 +69,7 @@ sys_kill(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // return how many clock tick interrupts have occurred
</span></span><span style="display:flex;"><span> // since start.
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-sys_uptime(void)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_uptime(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uint xticks;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   acquire(&amp;tickslock);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -91,3 +77,10 @@ sys_uptime(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   release(&amp;tickslock);
</span></span><span style="display:flex;"><span>   return xticks;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_trace(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int trace_syscall;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(0, &amp;trace_syscall);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  myproc()-&gt;trace_syscall = trace_syscall;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/attack.c b/user/attack.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 928e7d0..dd8479a 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/attack.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/attack.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -8,6 +8,9 @@ main(int argc, char *argv[])
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> {
</span></span><span style="display:flex;"><span>   // your code here.  you should write the secret to fd 2 using write
</span></span><span style="display:flex;"><span>   // (e.g., write(2, secret, 8)
</span></span><span style="display:flex;"><span><span style="color:#f55">-
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  //
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *end = sbrk(17 *PGSIZE );
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  end = end + 16 * PGSIZE + 32 ;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  write(2, end, 8);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  exit(0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/trace.c b/user/trace.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 474b26c..e899f26 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/trace.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/trace.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,15 +1,14 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">-#include &#34;kernel/param.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span> #include &#34;kernel/types.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;kernel/param.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #include &#34;kernel/stat.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;user/user.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-main(int argc, char *argv[])
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int main(int argc, char *argv[]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   int i;
</span></span><span style="display:flex;"><span>   char *nargv[MAXARG];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(argc &lt; 3 || (argv[1][0] &lt; &#39;0&#39; || argv[1][0] &gt; &#39;9&#39;)){
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (argc &lt; 3 || (argv[1][0] &lt; &#39;0&#39; || argv[1][0] &gt; &#39;9&#39;)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     fprintf(2, &#34;Usage: %s mask command\n&#34;, argv[0]);
</span></span><span style="display:flex;"><span>     exit(1);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -18,11 +17,11 @@ main(int argc, char *argv[])
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     fprintf(2, &#34;%s: trace failed\n&#34;, argv[0]);
</span></span><span style="display:flex;"><span>     exit(1);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    nargv[i-2] = argv[i];
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    nargv[i - 2] = argv[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span><span style="color:#f55">-  nargv[argc-2] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  nargv[argc - 2] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   exec(nargv[0], nargv);
</span></span><span style="display:flex;"><span>   printf(&#34;trace: exec failed\n&#34;);
</span></span><span style="display:flex;"><span>   exit(0);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/ulib.c b/user/ulib.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0064846..e861590 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/ulib.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/ulib.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -25,6 +25,18 @@ strcpy(char *s, const char *t)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return os;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char*
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+strncpy(char *s, const char *t, int n)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *os;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  os = s;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while(n&gt;0 &amp;&amp;(*s++ = *t++) != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    n--;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return os;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int
</span></span><span style="display:flex;"><span> strcmp(const char *p, const char *q)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/user.h b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f16fe27..cdf09f8 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -3,41 +3,43 @@ struct stat;
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // system calls
</span></span><span style="display:flex;"><span> int fork(void);
</span></span><span style="display:flex;"><span> int exit(int) __attribute__((noreturn));
</span></span><span style="display:flex;"><span><span style="color:#f55">-int wait(int*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int pipe(int*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int write(int, const void*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int read(int, void*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int wait(int *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int pipe(int *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int write(int, const void *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int read(int, void *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int close(int);
</span></span><span style="display:flex;"><span> int kill(int);
</span></span><span style="display:flex;"><span><span style="color:#f55">-int exec(const char*, char**);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int open(const char*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int mknod(const char*, short, short);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int unlink(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int fstat(int fd, struct stat*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int link(const char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int mkdir(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int chdir(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int exec(const char *, char **);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int open(const char *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int mknod(const char *, short, short);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int unlink(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int fstat(int fd, struct stat *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int link(const char *, const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int mkdir(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int chdir(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int dup(int);
</span></span><span style="display:flex;"><span> int getpid(void);
</span></span><span style="display:flex;"><span><span style="color:#f55">-char* sbrk(int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+char *sbrk(int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int sleep(int);
</span></span><span style="display:flex;"><span> int uptime(void);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int trace(int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // ulib.c
</span></span><span style="display:flex;"><span><span style="color:#f55">-int stat(const char*, struct stat*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-char* strcpy(char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void *memmove(void*, const void*, int);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-char* strchr(const char*, char c);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int strcmp(const char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void fprintf(int, const char*, ...) __attribute__ ((format (printf, 2, 3)));
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void printf(const char*, ...) __attribute__ ((format (printf, 1, 2)));
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-char* gets(char*, int max);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-uint strlen(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void* memset(void*, int, uint);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-int atoi(const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int stat(const char *, struct stat *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *strcpy(char *, const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *strncpy(char *, const char *, int n);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void *memmove(void *, const void *, int);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *strchr(const char *, char c);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int strcmp(const char *, const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void fprintf(int, const char *, ...) __attribute__((format(printf, 2, 3)));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void printf(const char *, ...) __attribute__((format(printf, 1, 2)));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+char *gets(char *, int max);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint strlen(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void *memset(void *, int, uint);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int atoi(const char *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> int memcmp(const void *, const void *, uint);
</span></span><span style="display:flex;"><span> void *memcpy(void *, const void *, uint);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // umalloc.c
</span></span><span style="display:flex;"><span><span style="color:#f55">-void* malloc(uint);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-void free(void*);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+void *malloc(uint);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void free(void *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/usys.pl b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 01e426e..9c97b05 100755
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -36,3 +36,4 @@ entry(&#34;getpid&#34;);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> entry(&#34;sbrk&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;sleep&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;uptime&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+entry(&#34;trace&#34;);
</span></span></span></code></pre></div>
</details>

<h2 id="lab-page-tables">Lab Page tables</h2>
<p>该 lab 主要是强化虚拟地址，物理地址以及 page table 设计思想的理解。虚拟地址转换为物理地址的流程如下：</p>
<p><img src="/images/os/xv6/risc-v-pagetable.png" alt="risc-v page table"></p>
<p>上图是 <code>RISC-V</code> 多种虚拟内存布局中的一种 —— <code>Sv39</code>。</p>
<p>通常，第一级 page table entry（上图的L2）指向第二级 page table，第二级 page table entry（上图的L1）指向第三级 page table，第三级 page table entry（上图的L0）指向的是实际的物理内存，将连续的且对齐的 4KB 虚拟内存映射到连续的且对齐的 4KB 物理内存（注意上面的虚拟地址的 offset， $1&laquo;12 = 4096$，所以对一个实际的物理地址左右移动不超过 12 位，都可以复原到原本的物理地址）。</p>
<p>和第三级 page table entry 的功能相似，如果第二级 page table entry 是叶子节点，则它指向的是 2MB 的物理内存。还需要知道的是如果第一级 page table entry 是叶子节点，则它指向的是 1GB 的物理内存。</p>
<p>一个 page table 的大小是 4KB， 一个 page table entry 的大小是 8 bytes，所以 <code>Sv39</code> 可以的表达 512GB 的内存空间。</p>
<p><img src="/images/os/xv6/pagetable-level.png" alt=""></p>
<p>至此，lab 中的 <code>Print a page table</code> 就很简单了， 根据 <code>freewalk</code> 来写代码，只需要根据 page table entry 的下标来计算虚拟地址即可。</p>
<p><code>Use superpages</code> 这个题目的难点是需要看懂 <code>walk</code> 这个函数是干啥的（<strong>特别是叶子节点</strong>），是怎么和 <code>mappages</code> 相互交互的，明白了这个基本上这个题目就解决了。还需要注意的是在分配superpage要分配的足够大，具体可以看 <code>usertests</code> 的测试用例 <code>sbrkmuch</code> 。</p>
<p><code>pgtbltest</code> 通过， 但是 <code>usertest</code> 测试用例<code>sbrkmuch</code> 没有通过，后续有时间在找原因吧。</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>hart <span style="color:#bd93f9">1</span> starting
</span></span><span style="display:flex;"><span>hart <span style="color:#bd93f9">2</span> starting
</span></span><span style="display:flex;"><span>init: starting sh
</span></span><span style="display:flex;"><span>$ pgtbltest
</span></span><span style="display:flex;"><span>print_pgtbl starting
</span></span><span style="display:flex;"><span>va 0x0 pte 0x205C7C5B pa 0x8171F000 perm 0x5B
</span></span><span style="display:flex;"><span>va 0x1000 pte 0x205C7017 pa 0x8171C000 perm 0x17
</span></span><span style="display:flex;"><span>va 0x2000 pte 0x205C6C07 pa 0x8171B000 perm 0x7
</span></span><span style="display:flex;"><span>va 0x3000 pte 0x205C68D7 pa 0x8171A000 perm 0xD7
</span></span><span style="display:flex;"><span>va 0x4000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0x5000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0x6000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0x7000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0x8000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0x9000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFF6000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFF7000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFF8000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFF9000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFFA000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFFB000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFFC000 pte 0x0 pa 0x0 perm 0x0
</span></span><span style="display:flex;"><span>va 0xFFFFD000 pte 0x205D4C13 pa 0x81753000 perm 0x13
</span></span><span style="display:flex;"><span>va 0xFFFFE000 pte 0x205D00C7 pa 0x81740000 perm 0xC7
</span></span><span style="display:flex;"><span>va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4B
</span></span><span style="display:flex;"><span>print_pgtbl: OK
</span></span><span style="display:flex;"><span>ugetpid_test starting
</span></span><span style="display:flex;"><span>ugetpid_test: OK
</span></span><span style="display:flex;"><span>print_kpgtbl starting
</span></span><span style="display:flex;"><span>page table 0x0000000081722000
</span></span><span style="display:flex;"><span> ..0x0000000000000000: pte 0x00000000205c7801 pa 0x000000008171e000
</span></span><span style="display:flex;"><span> .. ..0x0000000000000000: pte 0x00000000205c7401 pa 0x000000008171d000
</span></span><span style="display:flex;"><span> .. .. ..0x0000000000000000: pte 0x00000000205c7c5b pa 0x000000008171f000
</span></span><span style="display:flex;"><span> .. .. ..0x0000000000001000: pte 0x00000000205c70d7 pa 0x000000008171c000
</span></span><span style="display:flex;"><span> .. .. ..0x0000000000002000: pte 0x00000000205c6c07 pa 0x000000008171b000
</span></span><span style="display:flex;"><span> .. .. ..0x0000000000003000: pte 0x00000000205c68d7 pa 0x000000008171a000
</span></span><span style="display:flex;"><span> ..0x0000003fc0000000: pte 0x00000000205c8401 pa 0x0000000081721000
</span></span><span style="display:flex;"><span> .. ..0x0000003fffe00000: pte 0x00000000205c8001 pa 0x0000000081720000
</span></span><span style="display:flex;"><span> .. .. ..0x0000003fffffd000: pte 0x00000000205d4c13 pa 0x0000000081753000
</span></span><span style="display:flex;"><span> .. .. ..0x0000003fffffe000: pte 0x00000000205d00c7 pa 0x0000000081740000
</span></span><span style="display:flex;"><span> .. .. ..0x0000003ffffff000: pte 0x000000002000184b pa 0x0000000080006000
</span></span><span style="display:flex;"><span>print_kpgtbl: OK
</span></span><span style="display:flex;"><span>superpg_test starting
</span></span><span style="display:flex;"><span>superpg_test: OK
</span></span><span style="display:flex;"><span>pgtbltest: all tests succeeded
</span></span><span style="display:flex;"><span>$ QEMU: Terminated
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel<span style="color:#f1fa8c">&#39; is up to date.
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test pgtbltest == (1.9s)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   pgtbltest: ugetpid ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  pgtbltest: ugetpid: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   pgtbltest: print_kpgtbl ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  pgtbltest: print_kpgtbl: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   pgtbltest: superpg ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  pgtbltest: superpg: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test answers-pgtbl.txt ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">answers-pgtbl.txt: FAIL
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    Cannot read answers-pgtbl.txt
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test usertests == Timeout! (300.2s)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   usertests: all tests ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  usertests: all tests: FAIL
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    ...
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         test forktest: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         test sbrkbasic: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         test sbrkmuch: va=102760448 pte=0
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         panic: uvmunmap: not mapped
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         qemu-system-riscv64: terminating on signal 15 from pid 44492 (&lt;unknown process&gt;)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    MISSING &#39;</span>^ALL TESTS PASSED$&#39;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 35/51
</span></span></code></pre></div>
</details>

<p>实现代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/defs.h b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d133cd3..020aadb 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -66,6 +66,8 @@ void            ramdiskrw(struct buf*);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // kalloc.c
</span></span><span style="display:flex;"><span> void*           kalloc(void);
</span></span><span style="display:flex;"><span> void            kfree(void *);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void*           kalloc_super_page(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void            kfree_super_page(void *);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> void            kinit(void);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // log.c
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/kalloc.c b/kernel/kalloc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0699e7e..8188cfe 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/kalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/kalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -10,6 +10,7 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void freerange(void *pa_start, void *pa_end);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void freerange_super_page(void *pa_start, void *pa_end);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> extern char end[]; // first address after kernel.
</span></span><span style="display:flex;"><span>                    // defined by kernel.ld.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -21,13 +22,16 @@ struct run {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> struct {
</span></span><span style="display:flex;"><span>   struct spinlock lock;
</span></span><span style="display:flex;"><span>   struct run *freelist;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct run *superfreelist;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> } kmem;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void
</span></span><span style="display:flex;"><span> kinit()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>   initlock(&amp;kmem.lock, &#34;kmem&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  freerange(end, (void*)PHYSTOP);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  freerange(end, (void *)PHYSTOP - SUPERPGCOUNT * SUPERPGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  freerange_super_page((void *)PHYSTOP - SUPERPGCOUNT * SUPERPGSIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                       (void *)PHYSTOP);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -39,6 +43,16 @@ freerange(void *pa_start, void *pa_end)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     kfree(p);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+freerange_super_page(void *pa_start, void *pa_end)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *p;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p = (char*)SUPERPGROUNDUP((uint64)pa_start);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for(; p + SUPERPGSIZE &lt;= (char*)pa_end; p += SUPERPGSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree_super_page(p);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // Free the page of physical memory pointed at by pa,
</span></span><span style="display:flex;"><span> // which normally should have been returned by a
</span></span><span style="display:flex;"><span> // call to kalloc().  (The exception is when
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -48,7 +62,7 @@ kfree(void *pa)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> {
</span></span><span style="display:flex;"><span>   struct run *r;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP - SUPERPGCOUNT * SUPERPGSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     panic(&#34;kfree&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // Fill with junk to catch dangling refs.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -62,6 +76,25 @@ kfree(void *pa)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   release(&amp;kmem.lock);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+kfree_super_page(void *pa)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct run *r;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(((uint64)pa % SUPERPGSIZE) != 0 || (uint64)pa &lt; PHYSTOP - SUPERPGCOUNT * SUPERPGSIZE || (uint64)pa &gt;= PHYSTOP)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;kfree_super_page&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  // Fill with junk to catch dangling refs.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  memset(pa, 1, SUPERPGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  r = (struct run*)pa;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;kmem.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  r-&gt;next = kmem.superfreelist;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  kmem.superfreelist = r;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;kmem.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // Allocate one 4096-byte page of physical memory.
</span></span><span style="display:flex;"><span> // Returns a pointer that the kernel can use.
</span></span><span style="display:flex;"><span> // Returns 0 if the memory cannot be allocated.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -80,3 +113,19 @@ kalloc(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     memset((char*)r, 5, PGSIZE); // fill with junk
</span></span><span style="display:flex;"><span>   return (void*)r;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void *
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+kalloc_super_page(void)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct run *r;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;kmem.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  r = kmem.superfreelist;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(r)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kmem.superfreelist = r-&gt;next;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;kmem.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(r)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    memset((char*)r, 6, SUPERPGSIZE); // fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return (void*)r;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/proc.c b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 130d9ce..884c092 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -132,6 +132,13 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     return 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    freeproc(p);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;p-&gt;lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;usyscall-&gt;pid = p-&gt;pid;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   // An empty user page table.
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = proc_pagetable(p);
</span></span><span style="display:flex;"><span>   if(p-&gt;pagetable == 0){
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -158,6 +165,9 @@ freeproc(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   if(p-&gt;trapframe)
</span></span><span style="display:flex;"><span>     kfree((void*)p-&gt;trapframe);
</span></span><span style="display:flex;"><span>   p-&gt;trapframe = 0;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (p-&gt;usyscall) 
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree((void*)p-&gt;usyscall);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;usyscall = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   if(p-&gt;pagetable)
</span></span><span style="display:flex;"><span>     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -201,6 +211,13 @@ proc_pagetable(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     uvmfree(pagetable, 0);
</span></span><span style="display:flex;"><span>     return 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(mappages(pagetable, USYSCALL, PGSIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uvmunmap(pagetable, TRAPFRAME, 1, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uvmfree(pagetable, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   return pagetable;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -212,6 +229,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> {
</span></span><span style="display:flex;"><span>   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
</span></span><span style="display:flex;"><span>   uvmunmap(pagetable, TRAPFRAME, 1, 0);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uvmunmap(pagetable, USYSCALL, 1, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uvmfree(pagetable, sz);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/proc.h b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d021857..861b6fe 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -20,10 +20,10 @@ struct context {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Per-CPU state.
</span></span><span style="display:flex;"><span> struct cpu {
</span></span><span style="display:flex;"><span><span style="color:#f55">-  struct proc *proc;          // The process running on this cpu, or null.
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  struct context context;     // swtch() here to enter scheduler().
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int noff;                   // Depth of push_off() nesting.
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int intena;                 // Were interrupts enabled before push_off()?
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  struct proc *proc;      // The process running on this cpu, or null.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct context context; // swtch() here to enter scheduler().
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int noff;               // Depth of push_off() nesting.
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int intena;             // Were interrupts enabled before push_off()?
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> extern struct cpu cpus[NCPU];
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -86,22 +86,23 @@ struct proc {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   struct spinlock lock;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // p-&gt;lock must be held when using these:
</span></span><span style="display:flex;"><span><span style="color:#f55">-  enum procstate state;        // Process state
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  void *chan;                  // If non-zero, sleeping on chan
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int killed;                  // If non-zero, have been killed
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int xstate;                  // Exit status to be returned to parent&#39;s wait
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  int pid;                     // Process ID
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  enum procstate state; // Process state
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  void *chan;           // If non-zero, sleeping on chan
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int killed;           // If non-zero, have been killed
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int xstate;           // Exit status to be returned to parent&#39;s wait
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int pid;              // Process ID
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // wait_lock must be held when using this:
</span></span><span style="display:flex;"><span><span style="color:#f55">-  struct proc *parent;         // Parent process
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  struct proc *parent; // Parent process
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   // these are private to the process, so p-&gt;lock need not be held.
</span></span><span style="display:flex;"><span>   uint64 kstack;               // Virtual address of kernel stack
</span></span><span style="display:flex;"><span>   uint64 sz;                   // Size of process memory (bytes)
</span></span><span style="display:flex;"><span>   pagetable_t pagetable;       // User page table
</span></span><span style="display:flex;"><span>   struct trapframe *trapframe; // data page for trampoline.S
</span></span><span style="display:flex;"><span><span style="color:#f55">-  struct context context;      // swtch() here to run process
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  struct file *ofile[NOFILE];  // Open files
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  struct inode *cwd;           // Current directory
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  char name[16];               // Process name (debugging)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  struct usyscall *usyscall;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct context context;     // swtch() here to run process
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct file *ofile[NOFILE]; // Open files
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct inode *cwd;          // Current directory
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char name[16];              // Process name (debugging)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/riscv.h b/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 6cfff1e..a736c75 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -363,6 +363,7 @@ typedef uint64 *pagetable_t; // 512 PTEs
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define PGSHIFT 12  // bits of offset within a page
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> #ifdef LAB_PGTBL
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SUPERPGCOUNT 52
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #define SUPERPGSIZE (2 * (1 &lt;&lt; 20)) // bytes per page
</span></span><span style="display:flex;"><span> #define SUPERPGROUNDUP(sz)  (((sz)+SUPERPGSIZE-1) &amp; ~(SUPERPGSIZE-1))
</span></span><span style="display:flex;"><span> #endif
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/vm.c b/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 7f388fe..734e806 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -93,12 +93,11 @@ kvminithart()
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> //   12..20 -- 9 bits of level-0 index.
</span></span><span style="display:flex;"><span> //    0..11 -- 12 bits of byte offset within the page.
</span></span><span style="display:flex;"><span> pte_t *
</span></span><span style="display:flex;"><span><span style="color:#f55">-walk(pagetable_t pagetable, uint64 va, int alloc)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+do_walk(pagetable_t pagetable, uint64 va, int alloc, int pte_level) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   if(va &gt;= MAXVA)
</span></span><span style="display:flex;"><span>     panic(&#34;walk&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(int level = 2; level &gt; 0; level--) {
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for(int level = 2; level &gt; pte_level; level--) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     pte_t *pte = &amp;pagetable[PX(level, va)];
</span></span><span style="display:flex;"><span>     if(*pte &amp; PTE_V) {
</span></span><span style="display:flex;"><span>       pagetable = (pagetable_t)PTE2PA(*pte);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -114,9 +113,15 @@ walk(pagetable_t pagetable, uint64 va, int alloc)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>       *pte = PA2PTE(pagetable) | PTE_V;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#f55">-  return &amp;pagetable[PX(0, va)];
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  return &amp;pagetable[PX(pte_level, va)];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+pte_t *
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+walk(pagetable_t pagetable, uint64 va, int alloc)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return do_walk(pagetable, va, alloc, 0); 
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // Look up a virtual address, return the physical address,
</span></span><span style="display:flex;"><span> // or 0 if not mapped.
</span></span><span style="display:flex;"><span> // Can only be used to look up user pages.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -187,6 +192,38 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+mappages_super_page(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 a, last;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  pte_t *pte;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if((va % SUPERPGSIZE) != 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;mappages_super_page: va not aligned&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if((size % SUPERPGSIZE) != 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;mappages_super_page: size not aligned&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(size == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;mappages_super_page: size&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  a = va;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  last = va + size - SUPERPGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for(;;){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if((pte = do_walk(pagetable, a, 1,1)) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if(*pte &amp; PTE_V)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      panic(&#34;mappages_super_page: remap&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    *pte = PA2PTE(pa) | perm | PTE_V;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if(a == last)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    a += SUPERPGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    pa += SUPERPGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // Remove npages of mappings starting from va. va must be
</span></span><span style="display:flex;"><span> // page-aligned. The mappings must exist.
</span></span><span style="display:flex;"><span> // Optionally free the physical memory.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -201,7 +238,6 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     panic(&#34;uvmunmap: not aligned&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   for(a = va; a &lt; va + npages*PGSIZE; a += sz){
</span></span><span style="display:flex;"><span><span style="color:#f55">-    sz = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span>     if((pte = walk(pagetable, a, 0)) == 0)
</span></span><span style="display:flex;"><span>       panic(&#34;uvmunmap: walk&#34;);
</span></span><span style="display:flex;"><span>     if((*pte &amp; PTE_V) == 0) {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -210,9 +246,17 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     }
</span></span><span style="display:flex;"><span>     if(PTE_FLAGS(*pte) == PTE_V)
</span></span><span style="display:flex;"><span>       panic(&#34;uvmunmap: not a leaf&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(do_free){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      uint64 pa = PTE2PA(*pte);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      kfree((void*)pa);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    uint64 pa = PTE2PA(*pte);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((uint64)pa &gt;= PHYSTOP - SUPERPGCOUNT * SUPERPGSIZE) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      sz = SUPERPGSIZE; 
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if(do_free){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        kfree_super_page((void*)pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      sz = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if(do_free){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        kfree((void*)pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     }
</span></span><span style="display:flex;"><span>     *pte = 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -250,31 +294,49 @@ uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Allocate PTEs and physical memory to grow process from oldsz to
</span></span><span style="display:flex;"><span> // newsz, which need not be page aligned.  Returns new size or 0 on error.
</span></span><span style="display:flex;"><span><span style="color:#f55">-uint64
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   char *mem;
</span></span><span style="display:flex;"><span>   uint64 a;
</span></span><span style="display:flex;"><span>   int sz;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(newsz &lt; oldsz)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (newsz &lt; oldsz)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     return oldsz;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   oldsz = PGROUNDUP(oldsz);
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(a = oldsz; a &lt; newsz; a += sz){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    sz = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    mem = kalloc();
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(mem == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      uvmdealloc(pagetable, a, oldsz);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    }
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (a = oldsz; a &lt; newsz; a += sz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (a % SUPERPGSIZE == 0 &amp;&amp; a + SUPERPGSIZE &lt;= newsz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      sz = SUPERPGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      mem = kalloc_super_page();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (mem == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        uvmdealloc(pagetable, a, oldsz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#ifndef LAB_SYSCALL
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      memset(mem, 0, sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#endif
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (mappages_super_page(pagetable, a, sz, (uint64)mem,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                              PTE_R | PTE_U | xperm) != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        kfree_super_page(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        uvmdealloc(pagetable, a, oldsz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      sz = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      mem = kalloc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (mem == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        uvmdealloc(pagetable, a, oldsz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #ifndef LAB_SYSCALL
</span></span><span style="display:flex;"><span><span style="color:#f55">-    memset(mem, 0, sz);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+      memset(mem, 0, sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #endif
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if(mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      kfree(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      uvmdealloc(pagetable, a, oldsz);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+      if (mappages(pagetable, a, sz, (uint64)mem, PTE_R | PTE_U | xperm) != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        kfree(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        uvmdealloc(pagetable, a, oldsz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   return newsz;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -334,35 +396,44 @@ uvmfree(pagetable_t pagetable, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // physical memory.
</span></span><span style="display:flex;"><span> // returns 0 on success, -1 on failure.
</span></span><span style="display:flex;"><span> // frees any allocated pages on failure.
</span></span><span style="display:flex;"><span><span style="color:#f55">-int
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-{
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   pte_t *pte;
</span></span><span style="display:flex;"><span>   uint64 pa, i;
</span></span><span style="display:flex;"><span>   uint flags;
</span></span><span style="display:flex;"><span>   char *mem;
</span></span><span style="display:flex;"><span>   int szinc;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  for(i = 0; i &lt; sz; i += szinc){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    szinc = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    szinc = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if((pte = walk(old, i, 0)) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  for (i = 0; i &lt; sz; i += szinc) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((pte = walk(old, i, 0)) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       panic(&#34;uvmcopy: pte should exist&#34;);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if((*pte &amp; PTE_V) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if ((*pte &amp; PTE_V) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       panic(&#34;uvmcopy: page not present&#34;);
</span></span><span style="display:flex;"><span>     pa = PTE2PA(*pte);
</span></span><span style="display:flex;"><span>     flags = PTE_FLAGS(*pte);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if((mem = kalloc()) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    memmove(mem, (char*)pa, PGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      kfree(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if ((uint64)pa &gt;= PHYSTOP - SUPERPGCOUNT * SUPERPGSIZE) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      szinc = SUPERPGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if ((mem = kalloc_super_page()) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      memmove(mem, (char *)pa, SUPERPGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (mappages_super_page(new, i, SUPERPGSIZE, (uint64)mem, flags) != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        kfree_super_page(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      szinc = PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if ((mem = kalloc()) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      memmove(mem, (char *)pa, PGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        kfree(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">- err:
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+err:
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   uvmunmap(new, 0, i / PGSIZE, 1);
</span></span><span style="display:flex;"><span>   return -1;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -488,9 +559,36 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> #ifdef LAB_PGTBL
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+static uint64 n_times(int level) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 times = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for(int i = level; i &lt; 2; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    times *= 512;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return  times;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+static void do_vmprint(pagetable_t pagetable, int level, uint64 npages) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for(int i = 0; i &lt; 512; i++){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    pte_t pte = pagetable[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if(pte &amp; PTE_V) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34; ..&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      for(int j=0;j&lt;level;j++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        printf(&#34; ..&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;%p: pte %p pa %p\n&#34;,(void*)((npages+i) *n_times(level) * 4096), (void*)pte, (void*)PTE2PA(pte));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if((pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        uint64 child = PTE2PA(pte);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        do_vmprint((pagetable_t)child,level+1, (npages + i)*512);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> void
</span></span><span style="display:flex;"><span> vmprint(pagetable_t pagetable) {
</span></span><span style="display:flex;"><span>   // your code here
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  printf(&#34;page table %p\n&#34;, pagetable);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  do_vmprint(pagetable, 0, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> #endif
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div>
</details>

<h2 id="lab-traps">Lab Traps</h2>
<p><code>Backtrace</code> 这个比较简单，考查的对函数的调用栈的理解。寄存器 <code>fp</code> 指向当前栈帧的开始地址，寄存器 <code>sp</code> 指向当前栈帧的结束地址。栈是从高地址往低地址生长的，从寄存器 <code>fp</code> 指向栈帧的开始算起，第一个 8 字节(<code>fp-8</code>) 是 return address ，即被调用者（callee）返回的地址，调用者（caller）调用被调用者（callee）的这个指令的下一条指令的地址压入到栈。第二个 8 字节（<code>fp-16</code>）就是调用者（caller）的栈帧开始的地址。然后就是保存的寄存器、局部变量等。如下图：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>                   .
</span></span><span style="display:flex;"><span>                   .
</span></span><span style="display:flex;"><span>      +-&gt;          .
</span></span><span style="display:flex;"><span>      |   +-----------------+   |
</span></span><span style="display:flex;"><span>      |   | <span style="color:#ff79c6">return</span> address  |   |
</span></span><span style="display:flex;"><span>      |   |   previous fp ------+
</span></span><span style="display:flex;"><span>      |   | saved registers |
</span></span><span style="display:flex;"><span>      |   | <span style="color:#8be9fd;font-style:italic">local</span> variables |
</span></span><span style="display:flex;"><span>      |   |       ...       | &lt;-+
</span></span><span style="display:flex;"><span>      |   +-----------------+   |
</span></span><span style="display:flex;"><span>      |   | <span style="color:#ff79c6">return</span> address  |   |
</span></span><span style="display:flex;"><span>      +------ previous fp   |   |
</span></span><span style="display:flex;"><span>          | saved registers |   |
</span></span><span style="display:flex;"><span>          | <span style="color:#8be9fd;font-style:italic">local</span> variables |   |
</span></span><span style="display:flex;"><span>      +-&gt; |       ...       |   |
</span></span><span style="display:flex;"><span>      |   +-----------------+   |
</span></span><span style="display:flex;"><span>      |   | <span style="color:#ff79c6">return</span> address  |   |
</span></span><span style="display:flex;"><span>      |   |   previous fp ------+
</span></span><span style="display:flex;"><span>      |   | saved registers |
</span></span><span style="display:flex;"><span>      |   | <span style="color:#8be9fd;font-style:italic">local</span> variables |
</span></span><span style="display:flex;"><span>      |   |       ...       | &lt;-+
</span></span><span style="display:flex;"><span>      |   +-----------------+   |
</span></span><span style="display:flex;"><span>      |   | <span style="color:#ff79c6">return</span> address  |   |
</span></span><span style="display:flex;"><span>      +------ previous fp   |   |
</span></span><span style="display:flex;"><span>          | saved registers |   |
</span></span><span style="display:flex;"><span>          | <span style="color:#8be9fd;font-style:italic">local</span> variables |   |
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">$fp</span> --&gt; |       ...       |   |
</span></span><span style="display:flex;"><span>          +-----------------+   |
</span></span><span style="display:flex;"><span>          | <span style="color:#ff79c6">return</span> address  |   |
</span></span><span style="display:flex;"><span>          |   previous fp ------+
</span></span><span style="display:flex;"><span>          | saved registers |
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">$sp</span> --&gt; | <span style="color:#8be9fd;font-style:italic">local</span> variables |
</span></span><span style="display:flex;"><span>          +-----------------+
</span></span></code></pre></div><p>读取寄存器 <code>fp</code> 的函数已经提供了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">static</span> <span style="color:#ff79c6">inline</span> uint64
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">r_fp</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  uint64 x;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">asm</span> <span style="color:#ff79c6">volatile</span>(<span style="color:#f1fa8c">&#34;mv %0, s0&#34;</span> <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;=r&#34;</span> (x) );
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>backtrace</code> 的实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">backtrace</span>() {
</span></span><span style="display:flex;"><span>  uint64 fp <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">r_fp</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">while</span>(fp <span style="color:#ff79c6">!=</span> <span style="color:#50fa7b">PGROUNDUP</span>(fp)) {
</span></span><span style="display:flex;"><span>    uint64 ra <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(uint64<span style="color:#ff79c6">*</span>)(fp <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">8</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">printf</span>(<span style="color:#f1fa8c">&#34;%p</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, (<span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span>)ra);
</span></span><span style="display:flex;"><span>    fp <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(uint64<span style="color:#ff79c6">*</span>)(fp <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">16</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>alarm</code> 这个题目的描述已经明确告知需要在那些地方添加代码，在实现的过程中，每次 alarm 触发的时候需要把 <code>struct proc</code> 中的字段 <code>trapframe</code> 给保存起来，然后把寄存器 <code>pc</code> 设置为 回调函数的地址。<code>struct proc</code> 中新增加的字段如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#8be9fd">int</span> alarm_interval;  <span style="color:#6272a4">// alarm 间隔时间
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> alarm_ticks;  <span style="color:#6272a4">// 当前 alarm 的ticks 数量，当 &lt;=0 的时候，触发回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> alarm_ongoing; <span style="color:#6272a4">// 标志位，判断当前是否正在处理超时的alarm
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>alarm_handler)(); <span style="color:#6272a4">// alarm 回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> trapframe <span style="color:#ff79c6">*</span>alarm_trapframe; <span style="color:#6272a4">// 保存和恢复当前进程的trapframe
</span></span></span></code></pre></div><p>核心逻辑如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#6272a4">//...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (p<span style="color:#ff79c6">-&gt;</span>alarm_interval <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>      p<span style="color:#ff79c6">-&gt;</span>alarm_ticks<span style="color:#ff79c6">--</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> (p<span style="color:#ff79c6">-&gt;</span>alarm_ticks <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> p<span style="color:#ff79c6">-&gt;</span>alarm_ongoing <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">1</span>) {
</span></span><span style="display:flex;"><span>        p<span style="color:#ff79c6">-&gt;</span>alarm_ticks <span style="color:#ff79c6">=</span> p<span style="color:#ff79c6">-&gt;</span>alarm_interval;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>p<span style="color:#ff79c6">-&gt;</span>alarm_trapframe <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>p<span style="color:#ff79c6">-&gt;</span>trapframe;
</span></span><span style="display:flex;"><span>        p<span style="color:#ff79c6">-&gt;</span>trapframe<span style="color:#ff79c6">-&gt;</span>epc <span style="color:#ff79c6">=</span> (uint64)p<span style="color:#ff79c6">-&gt;</span>alarm_handler;
</span></span><span style="display:flex;"><span>        p<span style="color:#ff79c6">-&gt;</span>alarm_ongoing <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//...
</span></span></span></code></pre></div><p>lab 打分运行结果如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ bttest
</span></span><span style="display:flex;"><span>0x0000000080001d3c
</span></span><span style="display:flex;"><span>0x0000000080001c5a
</span></span><span style="display:flex;"><span>0x00000000800019dc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ riscv64-unknown-elf-addr2line -e kernel/kernel
</span></span><span style="display:flex;"><span>0x0000000080001d3c
</span></span><span style="display:flex;"><span>/path/to/xv6-labs-2024/kernel/sysproc.c:57
</span></span><span style="display:flex;"><span>0x0000000080001c5a
</span></span><span style="display:flex;"><span>/path/to/xv6-labs-2024/kernel/syscall.c:141
</span></span><span style="display:flex;"><span>0x00000000800019dc
</span></span><span style="display:flex;"><span>/path/to/xv6-labs-2024/kernel/trap.c:76
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ alarmtest
</span></span><span style="display:flex;"><span>test0 start
</span></span><span style="display:flex;"><span>............................alarm!
</span></span><span style="display:flex;"><span>test0 passed
</span></span><span style="display:flex;"><span>test1 start
</span></span><span style="display:flex;"><span>...alarm!
</span></span><span style="display:flex;"><span>..alarm!
</span></span><span style="display:flex;"><span>...alarm!
</span></span><span style="display:flex;"><span>..alarm!
</span></span><span style="display:flex;"><span>..alarm!
</span></span><span style="display:flex;"><span>...alarm!
</span></span><span style="display:flex;"><span>..alarm!
</span></span><span style="display:flex;"><span>...alarm!
</span></span><span style="display:flex;"><span>...alarm!
</span></span><span style="display:flex;"><span>..alarm!
</span></span><span style="display:flex;"><span>test1 passed
</span></span><span style="display:flex;"><span>test2 start
</span></span><span style="display:flex;"><span>................................alarm!
</span></span><span style="display:flex;"><span>test2 passed
</span></span><span style="display:flex;"><span>test3 start
</span></span><span style="display:flex;"><span>test3 passed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ./grade-lab-traps
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">&#39;kernel/kernel&#39;</span> is up to date.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test answers-traps.txt <span style="color:#ff79c6">==</span> 
</span></span><span style="display:flex;"><span>answers-traps.txt: FAIL 
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> answers-traps.txt
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test backtrace <span style="color:#8be9fd;font-style:italic">test</span> <span style="color:#ff79c6">==</span> backtrace test: OK <span style="color:#ff79c6">(</span>3.2s<span style="color:#ff79c6">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test running <span style="color:#8be9fd;font-style:italic">alarmtest</span> <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">(</span>4.9s<span style="color:#ff79c6">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   alarmtest: <span style="color:#8be9fd;font-style:italic">test0</span> <span style="color:#ff79c6">==</span> 
</span></span><span style="display:flex;"><span>  alarmtest: test0: <span style="color:#8be9fd;font-style:italic">OK</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   alarmtest: <span style="color:#8be9fd;font-style:italic">test1</span> <span style="color:#ff79c6">==</span> 
</span></span><span style="display:flex;"><span>  alarmtest: test1: <span style="color:#8be9fd;font-style:italic">OK</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   alarmtest: <span style="color:#8be9fd;font-style:italic">test2</span> <span style="color:#ff79c6">==</span> 
</span></span><span style="display:flex;"><span>  alarmtest: test2: <span style="color:#8be9fd;font-style:italic">OK</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   alarmtest: <span style="color:#8be9fd;font-style:italic">test3</span> <span style="color:#ff79c6">==</span> 
</span></span><span style="display:flex;"><span>  alarmtest: test3: <span style="color:#8be9fd;font-style:italic">OK</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">usertests</span> <span style="color:#ff79c6">==</span> usertests: OK <span style="color:#ff79c6">(</span>282.5s<span style="color:#ff79c6">)</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span> 
</span></span><span style="display:flex;"><span>time: FAIL 
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 89/95
</span></span></code></pre></div>
</details>

<p>实现代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/Makefile b/Makefile
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 74e454f..8da0c24 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -194,6 +194,7 @@ UPROGS=\
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 	$U/_grind\
</span></span><span style="display:flex;"><span> 	$U/_wc\
</span></span><span style="display:flex;"><span> 	$U/_zombie\
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_alarmtest\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/defs.h b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d1b6bb9..f1113d3 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -185,5 +185,8 @@ void            virtio_disk_init(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> void            virtio_disk_rw(struct buf *, int);
</span></span><span style="display:flex;"><span> void            virtio_disk_intr(void);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+// backtrace
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void            backtrace(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // number of elements in fixed-size array
</span></span><span style="display:flex;"><span> #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/printf.c b/kernel/printf.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d20534c..2d626b5 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/printf.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/printf.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -176,3 +176,21 @@ printfinit(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   initlock(&amp;pr.lock, &#34;pr&#34;);
</span></span><span style="display:flex;"><span>   pr.locking = 1;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+static inline uint64
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+r_fp()
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 x;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  asm volatile(&#34;mv %0, s0&#34; : &#34;=r&#34; (x) );
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return x;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void backtrace() {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 fp = r_fp();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while(fp != PGROUNDUP(fp)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uint64 ra = *(uint64*)(fp - 8);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    printf(&#34;%p\n&#34;, (void*)ra);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    fp = *(uint64*)(fp - 16);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/proc.c b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 130d9ce..5dc56f2 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -132,6 +132,12 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     return 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if((p-&gt;alarm_trapframe = (struct trapframe *)kalloc()) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    freeproc(p);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;p-&gt;lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   // An empty user page table.
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = proc_pagetable(p);
</span></span><span style="display:flex;"><span>   if(p-&gt;pagetable == 0){
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -140,6 +146,11 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     return 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_handler = (void(*)())0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_interval = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_ticks = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_ongoing = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   // Set up new context to start executing at forkret,
</span></span><span style="display:flex;"><span>   // which returns to user space.
</span></span><span style="display:flex;"><span>   memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -158,6 +169,11 @@ freeproc(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   if(p-&gt;trapframe)
</span></span><span style="display:flex;"><span>     kfree((void*)p-&gt;trapframe);
</span></span><span style="display:flex;"><span>   p-&gt;trapframe = 0;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(p-&gt;alarm_trapframe)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree((void*)p-&gt;alarm_trapframe);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_trapframe = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   if(p-&gt;pagetable)
</span></span><span style="display:flex;"><span>     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -169,6 +185,10 @@ freeproc(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   p-&gt;killed = 0;
</span></span><span style="display:flex;"><span>   p-&gt;xstate = 0;
</span></span><span style="display:flex;"><span>   p-&gt;state = UNUSED;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_handler = (void(*)())0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_interval = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_ticks = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_ongoing = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Create a user page table for a given process, with no user memory,
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/proc.h b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d021857..adf6382 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -104,4 +104,12 @@ struct proc {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   struct file *ofile[NOFILE];  // Open files
</span></span><span style="display:flex;"><span>   struct inode *cwd;           // Current directory
</span></span><span style="display:flex;"><span>   char name[16];               // Process name (debugging)
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  // for sigalarm and sigreturn
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int alarm_interval;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int alarm_ticks;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int alarm_ongoing;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  void (*alarm_handler)();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct trapframe *alarm_trapframe; 
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.c b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index ed65409..bfb4c11 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -102,6 +102,9 @@ extern uint64 sys_link(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> extern uint64 sys_mkdir(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_close(void);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+extern uint64 sys_sigalarm(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+extern uint64 sys_sigreturn(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // An array mapping syscall numbers from syscall.h
</span></span><span style="display:flex;"><span> // to the function that handles the system call.
</span></span><span style="display:flex;"><span> static uint64 (*syscalls[])(void) = {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -126,6 +129,8 @@ static uint64 (*syscalls[])(void) = {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> [SYS_link]    sys_link,
</span></span><span style="display:flex;"><span> [SYS_mkdir]   sys_mkdir,
</span></span><span style="display:flex;"><span> [SYS_close]   sys_close,
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+[SYS_sigalarm] sys_sigalarm ,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+[SYS_sigreturn] sys_sigreturn,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.h b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index bc5f356..bcf4342 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -20,3 +20,6 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define SYS_link   19
</span></span><span style="display:flex;"><span> #define SYS_mkdir  20
</span></span><span style="display:flex;"><span> #define SYS_close  21
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_sigalarm 22
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_sigreturn 23
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/sysproc.c b/kernel/sysproc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 3b4d5bd..a34ad05 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/sysproc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/sysproc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -53,7 +53,7 @@ sys_sleep(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> {
</span></span><span style="display:flex;"><span>   int n;
</span></span><span style="display:flex;"><span>   uint ticks0;
</span></span><span style="display:flex;"><span><span style="color:#f55">-
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  backtrace();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   argint(0, &amp;n);
</span></span><span style="display:flex;"><span>   if(n &lt; 0)
</span></span><span style="display:flex;"><span>     n = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -91,3 +91,22 @@ sys_uptime(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   release(&amp;tickslock);
</span></span><span style="display:flex;"><span>   return xticks;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_sigalarm(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 handler;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int interval;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(0, &amp;interval);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(1, &amp;handler);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_handler = (void (*)())handler;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_interval = interval;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_ticks = interval;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_sigreturn(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  *p-&gt;trapframe = *p-&gt;alarm_trapframe;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  p-&gt;alarm_ongoing = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return  p-&gt;trapframe-&gt;a0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/trap.c b/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d454a7d..50bdc16 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -77,8 +77,18 @@ usertrap(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     exit(-1);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   // give up the CPU if this is a timer interrupt.
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(which_dev == 2)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if (which_dev == 2) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;alarm_interval != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;alarm_ticks--;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (p-&gt;alarm_ticks &lt;= 0 &amp;&amp; p-&gt;alarm_ongoing != 1) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        p-&gt;alarm_ticks = p-&gt;alarm_interval;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        *p-&gt;alarm_trapframe = *p-&gt;trapframe;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        p-&gt;alarm_ongoing = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     yield();
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   usertrapret();
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/user.h b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f16fe27..6680fed 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -41,3 +41,6 @@ void *memcpy(void *, const void *, uint);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // umalloc.c
</span></span><span style="display:flex;"><span> void* malloc(uint);
</span></span><span style="display:flex;"><span> void free(void*);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int sigalarm(int ticks, void (*handler)());
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int sigreturn(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/usys.pl b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 01e426e..fa548b0 100755
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -36,3 +36,5 @@ entry(&#34;getpid&#34;);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> entry(&#34;sbrk&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;sleep&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;uptime&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+entry(&#34;sigalarm&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+entry(&#34;sigreturn&#34;);
</span></span></span></code></pre></div>
</details>

<h2 id="lab-copy-on-write">Lab Copy on-write</h2>
<p>这个 lab 的具体解法在课件和 lab 描述中说很清楚：</p>
<ul>
<li>需要判断 叶子节点 PTE 是否是COW，这个可以使用 PTE 保留的 RSW 标志位(2bit, 下标编号8，9)，前提是有效的叶子节点。</li>
<li><code>uvmcopy</code> 中删除物理内存分配的逻辑，重置 PTE 的 W 标志位，并添加 COW 标志位，完成上面的步骤，</li>
<li>在 <code>trap.c</code> 相应的地方添加根据寄存器 <code>scause</code> 的值判断是否是page fault 的处理流程的逻辑，虚拟地址存储在寄存器 <code>stval</code> 中。
<img src="/images/os/xv6/r_scause.png" alt="page fault"></li>
<li>引用计数问题，lab 描述的很明确，下标可以使用 <code>pa/4096</code> 来计算，依照结构体 <code>kmem</code>：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> spinlock lock;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">int</span> refs[REFS_ARRAY_LEN];
</span></span><span style="display:flex;"><span>} page_refs;
</span></span></code></pre></div></li>
<li>修改<code>uvmcopy</code>的实现，剔除内存分配的逻辑，并更新PTE的写标志位，并增加对应的物理内存的引用
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">*</span>pte <span style="color:#ff79c6">&amp;</span> PTE_W) {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>pte <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">*</span>pte <span style="color:#ff79c6">&amp;</span> (<span style="color:#ff79c6">~</span>PTE_W)) <span style="color:#ff79c6">|</span> PTE_COW;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#50fa7b">ref_page</span>(pa);
</span></span></code></pre></div></li>
<li>重点是 <code>cow</code> 的实现，如下是完整代码：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">uvmcopy_cow_page</span>(uint64 va)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">pte_t</span> <span style="color:#ff79c6">*</span>pte <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">pte_t</span><span style="color:#ff79c6">*</span>)<span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>mem <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span>)<span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  uint flags <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> proc <span style="color:#ff79c6">*</span>p <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">myproc</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span>((pte <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">walk</span>(p<span style="color:#ff79c6">-&gt;</span>pagetable, va, <span style="color:#bd93f9">0</span>)) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">panic</span>(<span style="color:#f1fa8c">&#34;uvmcopy_cow_page: walk</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  flags <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">PTE_FLAGS</span>(<span style="color:#ff79c6">*</span>pte);
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// mark write flag, earse COW flag
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  flags <span style="color:#ff79c6">=</span> (flags <span style="color:#ff79c6">|</span> PTE_W) <span style="color:#ff79c6">&amp;</span> (<span style="color:#ff79c6">~</span>PTE_COW);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  uint64 pa <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">PTE2PA</span>(<span style="color:#ff79c6">*</span>pte);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (<span style="color:#50fa7b">page_ref_count</span>(pa) <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>pte <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">*</span>pte <span style="color:#ff79c6">|</span> PTE_W) <span style="color:#ff79c6">&amp;</span> (<span style="color:#ff79c6">~</span>PTE_COW);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ((mem <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">kalloc</span>()) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">memmove</span>(mem, (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)pa, PGSIZE);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// erase va -&gt; pa
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">uvmunmap</span>(p<span style="color:#ff79c6">-&gt;</span>pagetable, <span style="color:#50fa7b">PGROUNDDOWN</span>(va), <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">unref_page</span>(pa);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// recreate va -&gt; mem
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (<span style="color:#50fa7b">mappages</span>(p<span style="color:#ff79c6">-&gt;</span>pagetable, <span style="color:#50fa7b">PGROUNDDOWN</span>(va), PGSIZE, (uint64)mem, flags) <span style="color:#ff79c6">!=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#50fa7b">printf</span>(<span style="color:#f1fa8c">&#34;uvmcopy_cow_page: mappages failed</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#50fa7b">kfree</span>(mem);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<p>lab 打分运行结果如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./grade-lab-cow
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel&#39; is up to date.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test running <span style="color:#8be9fd;font-style:italic">cowtest</span> <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">(</span>30.3s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   <span style="color:#8be9fd;font-style:italic">simple</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  simple: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   <span style="color:#8be9fd;font-style:italic">three</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  three: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   <span style="color:#8be9fd;font-style:italic">file</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  file: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   <span style="color:#8be9fd;font-style:italic">forkfork</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  forkfork: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">usertests</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>174.8s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   usertests: <span style="color:#8be9fd;font-style:italic">copyin</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  usertests: copyin: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   usertests: <span style="color:#8be9fd;font-style:italic">copyout</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  usertests: copyout: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   usertests: all <span style="color:#8be9fd;font-style:italic">tests</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  usertests: all tests: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt<span style="color:#f1fa8c">``</span>shell
</span></span><span style="display:flex;"><span>Score: 129/130
</span></span></code></pre></div>
</details>

<p>参考代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/defs.h b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d1b6bb9..394e694 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -185,5 +185,11 @@ void            virtio_disk_init(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> void            virtio_disk_rw(struct buf *, int);
</span></span><span style="display:flex;"><span> void            virtio_disk_intr(void);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+// cow
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int uvmcopy_cow_page(uint64 va);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int ref_page(uint64 pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int unref_page(uint64 pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int page_ref_count(uint64 pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int is_cow_page(uint64 va);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // number of elements in fixed-size array
</span></span><span style="display:flex;"><span> #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/kalloc.c b/kernel/kalloc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0699e7e..ffb8894 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/kalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/kalloc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -23,10 +23,51 @@ struct {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   struct run *freelist;
</span></span><span style="display:flex;"><span> } kmem;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define PA2IDX(pa) (((pa) - KERNBASE)/PGSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define REFS_ARRAY_LEN (PA2IDX(PHYSTOP))
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+struct {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct spinlock lock;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int refs[REFS_ARRAY_LEN];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+} page_refs;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int ref_page(uint64 pa) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int ref;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ref = ++page_refs.refs[PA2IDX(pa)];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return ref;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int unref_page(uint64 pa) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int ref;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ref = --page_refs.refs[PA2IDX(pa)];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return  ref;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int page_ref_count(uint64 pa) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int ref;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ref = page_refs.refs[PA2IDX(pa)];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return  ref;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+static void reset_page_ref(uint64 pa , int count) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  page_refs.refs[PA2IDX(pa)] = count;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;page_refs.lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> void
</span></span><span style="display:flex;"><span> kinit()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>   initlock(&amp;kmem.lock, &#34;kmem&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  initlock(&amp;page_refs.lock, &#34;page_refs_for_cow&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   freerange(end, (void*)PHYSTOP);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -51,6 +92,10 @@ kfree(void *pa)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)
</span></span><span style="display:flex;"><span>     panic(&#34;kfree&#34;);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (unref_page((uint64)pa) &gt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   // Fill with junk to catch dangling refs.
</span></span><span style="display:flex;"><span>   memset(pa, 1, PGSIZE);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -76,7 +121,9 @@ kalloc(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     kmem.freelist = r-&gt;next;
</span></span><span style="display:flex;"><span>   release(&amp;kmem.lock);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(r)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  if(r) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     memset((char*)r, 5, PGSIZE); // fill with junk
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    reset_page_ref((uint64)r, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   return (void*)r;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/riscv.h b/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f7aaa8a..c0ecc58 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -380,3 +380,5 @@ typedef uint64 *pagetable_t; // 512 PTEs
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> // Sv39, to avoid having to sign-extend virtual addresses
</span></span><span style="display:flex;"><span> // that have the high bit set.
</span></span><span style="display:flex;"><span> #define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define PTE_COW (1L&lt;&lt;8)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/trap.c b/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d454a7d..db9c348 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -67,6 +67,10 @@ usertrap(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     syscall();
</span></span><span style="display:flex;"><span>   } else if((which_dev = devintr()) != 0){
</span></span><span style="display:flex;"><span>     // ok
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  } else if ((r_scause() == 13 || r_scause() == 15)&amp;&amp; is_cow_page(r_stval())) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (uvmcopy_cow_page(r_stval()) == -1) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;killed = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   } else {
</span></span><span style="display:flex;"><span>     printf(&#34;usertrap(): unexpected scause 0x%lx pid=%d\n&#34;, r_scause(), p-&gt;pid);
</span></span><span style="display:flex;"><span>     printf(&#34;            sepc=0x%lx stval=0x%lx\n&#34;, r_sepc(), r_stval());
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/vm.c b/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 62421a2..122d427 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -5,6 +5,8 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;riscv.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;fs.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;spinlock.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;proc.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> /*
</span></span><span style="display:flex;"><span>  * the kernel&#39;s page table.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -315,7 +317,6 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   pte_t *pte;
</span></span><span style="display:flex;"><span>   uint64 pa, i;
</span></span><span style="display:flex;"><span>   uint flags;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  char *mem;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span> 
</span></span><span style="display:flex;"><span>   for(i = 0; i &lt; sz; i += PGSIZE){
</span></span><span style="display:flex;"><span>     if((pte = walk(old, i, 0)) == 0)
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -323,14 +324,14 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     if((*pte &amp; PTE_V) == 0)
</span></span><span style="display:flex;"><span>       panic(&#34;uvmcopy: page not present&#34;);
</span></span><span style="display:flex;"><span>     pa = PTE2PA(*pte);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (*pte &amp; PTE_W) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      *pte = (*pte &amp; (~PTE_W)) | PTE_COW;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     flags = PTE_FLAGS(*pte);
</span></span><span style="display:flex;"><span><span style="color:#f55">-    if((mem = kalloc()) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      goto err;
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    memmove(mem, (char*)pa, PGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-      kfree(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>       goto err;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    ref_page(pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -351,7 +352,8 @@ uvmclear(pagetable_t pagetable, uint64 va)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     panic(&#34;uvmclear&#34;);
</span></span><span style="display:flex;"><span>   *pte &amp;= ~PTE_U;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#f55">-
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define USE_COW
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#ifndef USE_COW
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // Copy from kernel to user.
</span></span><span style="display:flex;"><span> // Copy len bytes from src to virtual address dstva in a given page table.
</span></span><span style="display:flex;"><span> // Return 0 on success, -1 on error.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -381,6 +383,44 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#else
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 n, va0, pa0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  pte_t *pte;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while(len &gt; 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (is_cow_page(dstva)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      uvmcopy_cow_page(dstva);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    va0 = PGROUNDDOWN(dstva);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if(va0 &gt;= MAXVA)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    pte = walk(pagetable, va0, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0 ||(*pte &amp; PTE_W) == 0 ) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    //if (*pte &amp; PTE_COW) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    //  uvmcopy_cow_page(dstva);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    //} else if ((*pte &amp; PTE_W) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    //  return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    //}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    pa0 = walkaddr(pagetable, va0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    n = PGSIZE - (dstva - va0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if(n &gt; len)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      n = len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    memmove((void *)(pa0 + (dstva - va0)), src, n);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    len -= n;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    src += n;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    dstva = va0 + PGSIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#endif
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Copy from user to kernel.
</span></span><span style="display:flex;"><span> // Copy len bytes to dst from virtual address srcva in a given page table.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -449,3 +489,49 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uvmcopy_cow_page(uint64 va)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  pte_t *pte = (pte_t*)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char *mem = (char*)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint flags = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if((pte = walk(p-&gt;pagetable, va, 0)) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;uvmcopy_cow_page: walk\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  flags = PTE_FLAGS(*pte);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  flags = (flags | PTE_W) &amp; (~PTE_COW);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 pa = PTE2PA(*pte);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (page_ref_count(pa) &lt;= 1) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    *pte = (*pte | PTE_W) &amp; (~PTE_COW);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((mem = kalloc()) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    memmove(mem, (char *)pa, PGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    // erase va -&gt; pa
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uvmunmap(p-&gt;pagetable, PGROUNDDOWN(va), 1, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    unref_page(pa);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    // recreate va -&gt; mem
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, flags) !=
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;uvmcopy_cow_page: mappages failed\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      kfree(mem);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int is_cow_page(uint64 va) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  pte_t *pte;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return va &lt; p-&gt;sz &amp;&amp; ((pte = walk(p-&gt;pagetable, va, 0)) != 0) &amp;&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+         (*pte &amp; PTE_V) &amp;&amp; (*pte &amp; PTE_COW);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span></code></pre></div>
</details>

<h2 id="lab-network-driver">Lab network driver</h2>
<p>该 lab 的 e1000 和 udp receive 是一前后依赖的，e1000 的实现可以根据 lab 的提示文档来写。 udp receive 的实现细节：</p>
<ul>
<li>使用长度65536 的数组来保存端口号分配的状态。</li>
<li>udp packet的存储使用读写双游标追赶来实现环形缓冲区，每个端口号对应一个缓冲区。</li>
<li>sys_recv 和 ip_rx 对照着 lab 上的提示来写即可。</li>
</ul>
<p>lab 打分运行结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./grade-lab-net
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel&#39; is up to date.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test running <span style="color:#8be9fd;font-style:italic">nettest</span> <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">(</span>23.8s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">txone</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: txone: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">arp_rx</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: arp_rx: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">ip_rx</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: ip_rx: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">ping0</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: ping0: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">ping1</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: ping1: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">ping2</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: ping2: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">ping3</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: ping3: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">dns</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: dns: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   nettest: <span style="color:#8be9fd;font-style:italic">free</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  nettest: free: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 170/171
</span></span></code></pre></div><p>实现代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/e1000.c b/kernel/e1000.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 009e977..8d70777 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/e1000.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/e1000.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -101,8 +101,23 @@ e1000_transmit(char *buf, int len)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   // the TX descriptor ring so that the e1000 sends it. Stash
</span></span><span style="display:flex;"><span>   // a pointer so that it can be freed after send completes.
</span></span><span style="display:flex;"><span>   //
</span></span><span style="display:flex;"><span><span style="color:#f55">-
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;e1000_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint32 tdt = regs[E1000_TDT];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if ( (tx_ring[tdt].status &amp; E1000_TXD_STAT_DD) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;e1000_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (tx_bufs[tdt] != (char*)0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree(tx_bufs[tdt]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    tx_bufs[tdt] = (char*)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  tx_ring[tdt].addr = (uint64)buf;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  tx_ring[tdt].length = len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  tx_ring[tdt].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  tx_bufs[tdt] = buf;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  regs[E1000_TDT] = (tdt + 1) % TX_RING_SIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;e1000_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -115,7 +130,17 @@ e1000_recv(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   // Check for packets that have arrived from the e1000
</span></span><span style="display:flex;"><span>   // Create and deliver a buf for each packet (using net_rx()).
</span></span><span style="display:flex;"><span>   //
</span></span><span style="display:flex;"><span><span style="color:#f55">-
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  uint32 rdt = (regs[E1000_RDT] + 1) % RX_RING_SIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while (rx_ring[rdt].status &amp; E1000_RXD_STAT_DD) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    net_rx(rx_bufs[rdt], rx_ring[rdt].length);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((rx_bufs[rdt] = kalloc()) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      panic(&#34;e1000_recv: kalloc failed\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    rx_ring[rdt].addr = (uint64)(rx_bufs[rdt]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    rx_ring[rdt].status = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    regs[E1000_RDT] = rdt;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    rdt = (rdt + 1) % RX_RING_SIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/net.c b/kernel/net.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f4f9a45..fd2ee4f 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -19,10 +19,64 @@ static uint8 host_mac[ETHADDR_LEN] = { 0x52, 0x55, 0x0a, 0x00, 0x02, 0x02 };
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> static struct spinlock netlock;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+// udp receiver
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+//
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define UDP_MAX_PORT 65535
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define UDP_PACKET_RING_BUFFER_SIZE 16
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define UDP_PACKET_PALYLOAD_MAX_SIZE (PGSIZE -sizeof(struct eth) - sizeof(struct ip) - sizeof(struct udp))
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+static struct spinlock udp_port_lock;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int udp_binded_ports_state [UDP_MAX_PORT + 1];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+struct udp_packet {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint16 src_port;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int palyload_len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint32 src_ip;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char payload[UDP_PACKET_PALYLOAD_MAX_SIZE];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+};
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+struct ring_buffer {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int capacity;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int write_pos;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int read_pos;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct udp_packet* buffer[UDP_PACKET_RING_BUFFER_SIZE + 1];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+};
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void ringbuffer_push(struct ring_buffer *buf, struct udp_packet *packet) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  buf-&gt;buffer[buf-&gt;write_pos] = packet;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  buf-&gt;write_pos = (buf-&gt;write_pos + 1) % buf-&gt;capacity;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void ringbuffer_pop(struct ring_buffer *buf, struct udp_packet **packet) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  *packet = buf-&gt;buffer[buf-&gt;read_pos];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  buf-&gt;buffer[buf-&gt;read_pos] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  buf-&gt;read_pos = (buf-&gt;read_pos + 1) % buf-&gt;capacity;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int ringbuffer_is_empty(struct ring_buffer *buf) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return buf-&gt;read_pos == buf-&gt;write_pos;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int ringbuffer_is_full(struct ring_buffer *buf) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return (buf-&gt;write_pos + 1) % buf-&gt;capacity == buf-&gt;read_pos;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+struct  ring_buffer udp_queues[UDP_MAX_PORT + 1];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> void
</span></span><span style="display:flex;"><span> netinit(void)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>   initlock(&amp;netlock, &#34;netlock&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  initlock(&amp;udp_port_lock, &#34;udp_port_lock&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  memset(udp_binded_ports_state, 0, sizeof(udp_binded_ports_state));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for(int i = 0 ;i &lt; UDP_MAX_PORT + 1; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    memset(udp_queues[i].buffer, 0, sizeof(udp_queues[i].buffer));
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    udp_queues[i].capacity = UDP_PACKET_RING_BUFFER_SIZE + 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    udp_queues[i].write_pos = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    udp_queues[i].read_pos = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -37,8 +91,19 @@ sys_bind(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   //
</span></span><span style="display:flex;"><span>   // Your code here.
</span></span><span style="display:flex;"><span>   //
</span></span><span style="display:flex;"><span><span style="color:#f55">-
</span></span></span><span style="display:flex;"><span><span style="color:#f55">-  return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  int port;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(0, &amp;port);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (port &lt; 0 || port &gt; UDP_MAX_PORT) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (udp_binded_ports_state[port] != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  udp_binded_ports_state[port] = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> //
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -52,6 +117,18 @@ sys_unbind(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   //
</span></span><span style="display:flex;"><span>   // Optional: Your code here.
</span></span><span style="display:flex;"><span>   //
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int port;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(0, &amp;port);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (port &lt; 0 || port &gt; UDP_MAX_PORT) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (udp_binded_ports_state[port] == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  udp_binded_ports_state[port] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -77,7 +154,46 @@ sys_recv(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   //
</span></span><span style="display:flex;"><span>   // Your code here.
</span></span><span style="display:flex;"><span>   //
</span></span><span style="display:flex;"><span><span style="color:#f55">-  return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  int dport;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 src_ip_addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 src_port_addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 buf_addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int maxlen;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(0, &amp;dport);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(1, &amp;src_ip_addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(2, &amp;src_port_addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(3, &amp;buf_addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(4, &amp;maxlen);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (udp_binded_ports_state[dport] == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct ring_buffer *rb = &amp;udp_queues[dport];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  while (ringbuffer_is_empty(rb)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    sleep(rb, &amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct udp_packet *packet = (struct udp_packet*)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ringbuffer_pop(rb, &amp;packet);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (copyout(myproc()-&gt;pagetable, src_ip_addr, (char *)(&amp;packet-&gt;src_ip),
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+              sizeof(packet-&gt;src_ip)) &lt; 0 ||
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      copyout(myproc()-&gt;pagetable, src_port_addr, (char *)(&amp;packet-&gt;src_port),
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+              sizeof(packet-&gt;src_port)) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int copylen = packet-&gt;palyload_len &lt; maxlen ? packet-&gt;palyload_len : maxlen;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (copyout(myproc()-&gt;pagetable, buf_addr, packet-&gt;payload, copylen) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return  -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  kfree(packet);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return copylen;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // This code is lifted from FreeBSD&#39;s ping.c, and is copyright by the Regents
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -191,7 +307,43 @@ ip_rx(char *buf, int len)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   //
</span></span><span style="display:flex;"><span>   // Your code here.
</span></span><span style="display:flex;"><span>   //
</span></span><span style="display:flex;"><span><span style="color:#f55">-  
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  struct eth *eth = (struct eth*)buf;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct ip *ip = (struct ip*)(eth + 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (ip-&gt;ip_p != IPPROTO_UDP) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree(buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct udp * udp = (struct udp*) (ip + 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int dport = ntohs(udp-&gt;dport);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int sport = ntohs(udp-&gt;sport);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int ulen = ntohs(udp-&gt;ulen)-sizeof(struct udp);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  acquire(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(udp_binded_ports_state[dport] == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree(buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct ring_buffer *rb = &amp;udp_queues[dport];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (ringbuffer_is_full(rb)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree(buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct udp_packet *packet;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if ((packet = kalloc()) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    kfree(buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  packet-&gt;src_ip = ntohl(ip-&gt;ip_src);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  packet-&gt;src_port = sport;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  packet-&gt;palyload_len = ulen;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  memmove(packet-&gt;payload, ((char*)udp+sizeof(struct udp)), ulen);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ringbuffer_push(rb, packet);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  release(&amp;udp_port_lock);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  kfree(buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  wakeup(rb);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> //
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/net.h b/kernel/net.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 42c0971..1a1bcd5 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -125,3 +125,8 @@ struct dns_data {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   uint32 ttl;
</span></span><span style="display:flex;"><span>   uint16 len;
</span></span><span style="display:flex;"><span> } __attribute__((packed));
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span></code></pre></div>
</details>

<h2 id="lab-lock">Lab Lock</h2>
<h2 id="lab-file-system">Lab File system</h2>
<p><code>bigfile</code> 这个比较简单，一图胜千言：</p>
<p><img src="/images/os/xv6/inode.png" alt="struct inode"></p>
<p>根据 <code>bigfile</code> 的要求描述，依照 <code>bmap</code> 和 <code>itrunc</code> 中 single indirect 的逻辑， double indirect 的实现基本上是复制粘贴。</p>
<p><code>Symbolic links</code>，按照其提供的 hints 来写问题也不大，在实现 <code>sys_symlink</code> 的时候需要把实际的文件的路径通过 <code>writei</code> 写到软链接的 inode 中。然后在 <code>sys_open</code> 需要处理软链接和 <code>O_NOFOLLOW</code> 标志位的问题，需要通过递归 <code>readi</code> 来访问软链接所链接的最终文件，需要注意的是递归是有层数限制的，这个可以自定义。</p>
<p>lab 执行结果如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ bigfile
</span></span><span style="display:flex;"><span>..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
</span></span><span style="display:flex;"><span>wrote <span style="color:#bd93f9">65803</span> blocks
</span></span><span style="display:flex;"><span>reading bigfile
</span></span><span style="display:flex;"><span>..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ symlinktest
</span></span><span style="display:flex;"><span>Start: <span style="color:#8be9fd;font-style:italic">test</span> symlinks
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">test</span> symlinks: ok
</span></span><span style="display:flex;"><span>Start: <span style="color:#8be9fd;font-style:italic">test</span> concurrent symlinks
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">test</span> concurrent symlinks: ok
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ./grade-lab-fs
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel&#39; is up to date.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test running <span style="color:#8be9fd;font-style:italic">bigfile</span> <span style="color:#ff79c6">==</span> running bigfile: OK <span style="color:#ff79c6">(</span>224.7s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test running <span style="color:#8be9fd;font-style:italic">symlinktest</span> <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">(</span>3.3s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   symlinktest: <span style="color:#8be9fd;font-style:italic">symlinks</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  symlinktest: symlinks: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test   symlinktest: concurrent <span style="color:#8be9fd;font-style:italic">symlinks</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>  symlinktest: concurrent symlinks: <span style="color:#8be9fd;font-style:italic">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">usertests</span> <span style="color:#ff79c6">==</span> usertests: OK <span style="color:#ff79c6">(</span>61.3s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">(</span>Old xv6.out.usertests failure log removed<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 99/100
</span></span></code></pre></div>
</details>

<p>参考代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/Makefile b/Makefile
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index b7fb22d..ed702b4 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -194,6 +194,7 @@ UPROGS=\
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 	$U/_grind\
</span></span><span style="display:flex;"><span> 	$U/_wc\
</span></span><span style="display:flex;"><span> 	$U/_zombie\
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_symlinktest\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/fcntl.h b/kernel/fcntl.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 44861b9..e5e38e3 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/fcntl.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/fcntl.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -3,3 +3,4 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define O_RDWR    0x002
</span></span><span style="display:flex;"><span> #define O_CREATE  0x200
</span></span><span style="display:flex;"><span> #define O_TRUNC   0x400
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define O_NOFOLLOW 0x800
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/file.h b/kernel/file.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index b076d1d..5c4eb3a 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/file.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/file.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -26,7 +26,7 @@ struct inode {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   short minor;
</span></span><span style="display:flex;"><span>   short nlink;
</span></span><span style="display:flex;"><span>   uint size;
</span></span><span style="display:flex;"><span><span style="color:#f55">-  uint addrs[NDIRECT+1];
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  uint addrs[NDIRECT+2];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // map major device number to device functions.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/fs.c b/kernel/fs.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index c6bab15..5a432f8 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/fs.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/fs.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -417,6 +417,38 @@ bmap(struct inode *ip, uint bn)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     return addr;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  bn -= NINDIRECT;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if(bn &lt; NINDIRECT*NINDIRECT){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if((addr = ip-&gt;addrs[NDIRECT+1]) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      addr = balloc(ip-&gt;dev);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if(addr == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      ip-&gt;addrs[NDIRECT+1] = addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    bp = bread(ip-&gt;dev, addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    a = (uint*)bp-&gt;data;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if((addr = a[bn/NINDIRECT]) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      addr = balloc(ip-&gt;dev);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if(addr){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        a[bn/NINDIRECT] = addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        log_write(bp);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    brelse(bp);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    bn %= NINDIRECT;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    bp = bread(ip-&gt;dev, addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    a = (uint*)bp-&gt;data;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if((addr = a[bn]) == 0){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      addr = balloc(ip-&gt;dev);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if(addr){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        a[bn] = addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        log_write(bp);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    brelse(bp);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return addr;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   panic(&#34;bmap: out of range&#34;);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -447,6 +479,25 @@ itrunc(struct inode *ip)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);
</span></span><span style="display:flex;"><span>     ip-&gt;addrs[NDIRECT] = 0;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (ip-&gt;addrs[NDIRECT + 1]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + 1]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    a = (uint *)bp-&gt;data;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    for (j = 0; j &lt; NINDIRECT; j++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (a[j]) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        struct buf *level2 = bread(ip-&gt;dev, a[j]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        uint *level2_a = (uint *)level2-&gt;data;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        for (int k = 0; k &lt; NINDIRECT; k++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+          if (level2_a[k])
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+            bfree(ip-&gt;dev, level2_a[k]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        brelse(level2);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        bfree(ip-&gt;dev, a[j]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    brelse(bp);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + 1]);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    ip-&gt;addrs[NDIRECT + 1] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span>   ip-&gt;size = 0;
</span></span><span style="display:flex;"><span>   iupdate(ip);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/fs.h b/kernel/fs.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 139dcc9..78c109d 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/fs.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/fs.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -24,9 +24,9 @@ struct superblock {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> #define FSMAGIC 0x10203040
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f55">-#define NDIRECT 12
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define NDIRECT 11
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #define NINDIRECT (BSIZE / sizeof(uint))
</span></span><span style="display:flex;"><span><span style="color:#f55">-#define MAXFILE (NDIRECT + NINDIRECT)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // On-disk inode structure
</span></span><span style="display:flex;"><span> struct dinode {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -35,7 +35,7 @@ struct dinode {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   short minor;          // Minor device number (T_DEVICE only)
</span></span><span style="display:flex;"><span>   short nlink;          // Number of links to inode in file system
</span></span><span style="display:flex;"><span>   uint size;            // Size of file (bytes)
</span></span><span style="display:flex;"><span><span style="color:#f55">-  uint addrs[NDIRECT+1];   // Data block addresses
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  uint addrs[NDIRECT+2];   // Data block addresses
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> // Inodes per block.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/stat.h b/kernel/stat.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 19543af..41a4dc3 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/stat.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/stat.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -1,6 +1,7 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define T_DIR     1   // Directory
</span></span><span style="display:flex;"><span> #define T_FILE    2   // File
</span></span><span style="display:flex;"><span> #define T_DEVICE  3   // Device
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define T_SYMLINK 4   // Symlink
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> struct stat {
</span></span><span style="display:flex;"><span>   int dev;     // File system&#39;s disk device
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.c b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index ed65409..9ab7246 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -101,6 +101,7 @@ extern uint64 sys_unlink(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> extern uint64 sys_link(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_mkdir(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_close(void);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+extern uint64 sys_symlink(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // An array mapping syscall numbers from syscall.h
</span></span><span style="display:flex;"><span> // to the function that handles the system call.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -126,6 +127,8 @@ static uint64 (*syscalls[])(void) = {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> [SYS_link]    sys_link,
</span></span><span style="display:flex;"><span> [SYS_mkdir]   sys_mkdir,
</span></span><span style="display:flex;"><span> [SYS_close]   sys_close,
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+[SYS_symlink]   sys_symlink,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.h b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index bc5f356..13818da 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -20,3 +20,4 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define SYS_link   19
</span></span><span style="display:flex;"><span> #define SYS_mkdir  20
</span></span><span style="display:flex;"><span> #define SYS_close  21
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_symlink 22
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/sysfile.c b/kernel/sysfile.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 16b668c..a1a45ad 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/sysfile.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/sysfile.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -301,6 +301,27 @@ create(char *path, short type, short major, short minor)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+static struct inode *do_follow_symlink(struct inode *ip, int depth) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (depth &gt;= 16) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return  0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char path[MAXPATH];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int ret = readi(ip, 0, (uint64)&amp;path, 0, MAXPATH);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (ret &lt;= 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return (struct inode *)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  path[ret] = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  iunlockput(ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if ((ip = namei(path)) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return (struct inode *)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ilock(ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (ip-&gt;type == T_SYMLINK) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return do_follow_symlink(ip, depth + 1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return ip;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> uint64
</span></span><span style="display:flex;"><span> sys_open(void)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -328,6 +349,12 @@ sys_open(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>       return -1;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     ilock(ip);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if ((ip = do_follow_symlink(ip, 0)) == (struct inode*)0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     if(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY){
</span></span><span style="display:flex;"><span>       iunlockput(ip);
</span></span><span style="display:flex;"><span>       end_op();
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -503,3 +530,36 @@ sys_pipe(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_symlink(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  // link source_file target_file
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char source_path[MAXPATH];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  char target_path[MAXPATH];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct inode *ip;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (argstr(0, source_path, MAXPATH) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (argstr(1, target_path, MAXPATH) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  begin_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ip = create(target_path, T_SYMLINK, 0, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (ip == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (writei(ip, 0, (uint64)&amp;source_path, 0, strlen(source_path)) != strlen(source_path)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  iunlockput(ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/user.h b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f16fe27..4d061da 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -22,6 +22,7 @@ int getpid(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> char* sbrk(int);
</span></span><span style="display:flex;"><span> int sleep(int);
</span></span><span style="display:flex;"><span> int uptime(void);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int symlink(const char*, const char*);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // ulib.c
</span></span><span style="display:flex;"><span> int stat(const char*, struct stat*);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/usys.pl b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 01e426e..bc5c22e 100755
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -36,3 +36,4 @@ entry(&#34;getpid&#34;);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> entry(&#34;sbrk&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;sleep&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;uptime&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+entry(&#34;symlink&#34;);
</span></span></span></code></pre></div>
</details>

<h2 id="lab-mmap">Lab mmap</h2>
<p><img src="/images/os/xv6/simple_mmap.png" alt=""></p>
<p>在这个lab 中要求实现简易版本的 mmap，lab 的提示已经写的很清楚，在实现的过程中还需要注意：</p>
<ul>
<li>Virtual Memory Area 的范围，在本次实验中，这里可以设置虚拟地址最大可为 <code>TRAPFRAME - PGSIZE</code>，即和 <code>TRAPFRAME</code> 之间有个 page guard，最小地址虚拟地址在本次实验中可以无须考虑。</li>
<li>注意文件大小和映射的长度，这个在 mmap 中也有说明：
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>A file is mapped in multiples of the page size.  For a file that
</span></span><span style="display:flex;"><span>is not a multiple of the page size, the remaining bytes in the
</span></span><span style="display:flex;"><span>partial page at the end of the mapping are zeroed when mapped, and
</span></span><span style="display:flex;"><span>modifications to that region are not written out to the file.  The
</span></span><span style="display:flex;"><span>effect of changing the size of the underlying file of a mapping on
</span></span><span style="display:flex;"><span>the pages that correspond to added or removed regions of the file
</span></span><span style="display:flex;"><span>is unspecified.
</span></span></code></pre></div></li>
<li>在 munmap 的时候需要动态更新修改映射区间的起始地址，映射长度，以及 文件的 offset。</li>
</ul>
<p>lab 执行结果如下，本实现 read_only_write 这个 case 没有过去：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ./grade-lab-mmap
</span></span><span style="display:flex;"><span>make: <span style="color:#f1fa8c">`</span>kernel/kernel<span style="color:#f1fa8c">&#39; is up to date.
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test running mmaptest ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">Timeout! (180.9s)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: mmap basic ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: mmap basic: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: mmap private ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: mmap private: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: mmap read-only ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: mmap read-only: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: mmap read/write ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: mmap read/write: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: mmap dirty ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: mmap dirty: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: not-mapped unmap ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: not-mapped unmap: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: lazy access ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: lazy access: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: two files ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: two files: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: fork_test ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: fork_test: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: munmap_noaccess ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: munmap_noaccess: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">== Test   mmaptest: read_only_write ==
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  mmaptest: read_only_write: FAIL
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    ...
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">                     sepc=0xab2 stval=0x3fffff7000
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         test munmap prevents access: OK
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         test writes to read-only mapped memory
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         panic: mappages: remap
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">         qemu-system-riscv64: terminating on signal 15 from pid 54572 (&lt;unknown process&gt;)
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    MISSING &#39;</span>^test writes to read-only mapped memory: OK$&#39;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">usertests</span> <span style="color:#ff79c6">==</span> usertests: OK <span style="color:#ff79c6">(</span>120.5s<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">==</span> Test <span style="color:#8be9fd;font-style:italic">time</span> <span style="color:#ff79c6">==</span>
</span></span><span style="display:flex;"><span>time: FAIL
</span></span><span style="display:flex;"><span>    Cannot <span style="color:#8be9fd;font-style:italic">read</span> time.txt
</span></span><span style="display:flex;"><span>Score: 159/170shel
</span></span></code></pre></div>
</details>

<p>参考代码如下：</p>
<details>
    <summary>CLICK ME</summary>
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/.gitignore b/.gitignore
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 11d0677..1fc9859 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/.gitignore
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/.gitignore
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -25,3 +25,6 @@ barrier
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> .DS_Store
</span></span><span style="display:flex;"><span> *.dSYM
</span></span><span style="display:flex;"><span> *.pcap
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+*.bak
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+*.img.*
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+compile_commands.json
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/Makefile b/Makefile
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index b7fb22d..f074d39 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/Makefile
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -194,6 +194,7 @@ UPROGS=\
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 	$U/_grind\
</span></span><span style="display:flex;"><span> 	$U/_wc\
</span></span><span style="display:flex;"><span> 	$U/_zombie\
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+	$U/_mmaptest\
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/defs.h b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d133cd3..a0dbb35 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/defs.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -12,6 +12,7 @@ struct spinlock;
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> struct sleeplock;
</span></span><span style="display:flex;"><span> struct stat;
</span></span><span style="display:flex;"><span> struct superblock;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+struct vma;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // bio.c
</span></span><span style="display:flex;"><span> void            binit(void);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -237,3 +238,9 @@ void            netinit(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> void            net_rx(char *buf, int len);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> #endif
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int handle_pagefault(uint64 va);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 writeback(uint64 addr, size_t len, struct proc *p, struct vma *v);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 mmap(uint64 addr, uint64 sz, int prot, int flags, struct file *f,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+            uint64 offset);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 munmap(uint64 addr, uint64 sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/memlayout.h b/kernel/memlayout.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 3ab2ace..2488117 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/memlayout.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/memlayout.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -57,3 +57,4 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> //   TRAPFRAME (p-&gt;trapframe, used by the trampoline)
</span></span><span style="display:flex;"><span> //   TRAMPOLINE (the same page as in the kernel)
</span></span><span style="display:flex;"><span> #define TRAPFRAME (TRAMPOLINE - PGSIZE)
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define VMASTOP (TRAPFRAME - PGSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/proc.c b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 130d9ce..2c32379 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -5,6 +5,7 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;spinlock.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;proc.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;fcntl.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> struct cpu cpus[NCPU];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -146,6 +147,17 @@ found:
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   p-&gt;context.ra = (uint64)forkret;
</span></span><span style="display:flex;"><span>   p-&gt;context.sp = p-&gt;kstack + PGSIZE;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (int i = 0; i &lt; NVMA; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].valid = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].sz = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].vastart = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].f = (struct file*)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].prot = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].flags = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].offset = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    p-&gt;vmas[i].file_size = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   return p;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -158,6 +170,13 @@ freeproc(struct proc *p)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   if(p-&gt;trapframe)
</span></span><span style="display:flex;"><span>     kfree((void*)p-&gt;trapframe);
</span></span><span style="display:flex;"><span>   p-&gt;trapframe = 0;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //for (int i = 0; i &lt; NVMA; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //  struct vma *v = &amp;p-&gt;vmas[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //  if (!v-&gt;valid) continue;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //  if (munmap(v-&gt;vastart, v-&gt;sz)!= 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //    panic(&#34;exit: munmap failed&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  //}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   if(p-&gt;pagetable)
</span></span><span style="display:flex;"><span>     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);
</span></span><span style="display:flex;"><span>   p-&gt;pagetable = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -308,6 +327,14 @@ fork(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>       np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);
</span></span><span style="display:flex;"><span>   np-&gt;cwd = idup(p-&gt;cwd);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (i = 0; i &lt; NVMA; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    struct vma *v = &amp;p-&gt;vmas[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (v-&gt;valid) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      np-&gt;vmas[i] = *v;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      filedup(v-&gt;f);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   pid = np-&gt;pid;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -360,6 +387,14 @@ exit(int status)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (int i = 0; i &lt; NVMA; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    struct vma *v = &amp;p-&gt;vmas[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (!v-&gt;valid) continue;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (munmap(v-&gt;vastart, v-&gt;sz)!= 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      panic(&#34;exit: munmap failed&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   begin_op();
</span></span><span style="display:flex;"><span>   iput(p-&gt;cwd);
</span></span><span style="display:flex;"><span>   end_op();
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/proc.h b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d021857..2c90d1c 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/proc.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -81,6 +81,19 @@ struct trapframe {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define NVMA 16
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+struct vma {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int valid;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 vastart;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 sz;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct file *f;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int prot;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int flags;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 offset;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 file_size;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+};
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> // Per-process state
</span></span><span style="display:flex;"><span> struct proc {
</span></span><span style="display:flex;"><span>   struct spinlock lock;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -104,4 +117,5 @@ struct proc {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   struct file *ofile[NOFILE];  // Open files
</span></span><span style="display:flex;"><span>   struct inode *cwd;           // Current directory
</span></span><span style="display:flex;"><span>   char name[16];               // Process name (debugging)
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct vma vmas[NVMA];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/riscv.h b/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index f7aaa8a..d4fc9bd 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/riscv.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -362,6 +362,7 @@ typedef uint64 *pagetable_t; // 512 PTEs
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define PTE_W (1L &lt;&lt; 2)
</span></span><span style="display:flex;"><span> #define PTE_X (1L &lt;&lt; 3)
</span></span><span style="display:flex;"><span> #define PTE_U (1L &lt;&lt; 4) // user can access
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define PTE_D (1L &lt;&lt; 7)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // shift a physical address to the right place for a PTE.
</span></span><span style="display:flex;"><span> #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.c b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index ed65409..4fb9baa 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -101,6 +101,8 @@ extern uint64 sys_unlink(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> extern uint64 sys_link(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_mkdir(void);
</span></span><span style="display:flex;"><span> extern uint64 sys_close(void);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+extern uint64 sys_mmap(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+extern uint64 sys_munmap(void);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // An array mapping syscall numbers from syscall.h
</span></span><span style="display:flex;"><span> // to the function that handles the system call.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -126,6 +128,8 @@ static uint64 (*syscalls[])(void) = {
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> [SYS_link]    sys_link,
</span></span><span style="display:flex;"><span> [SYS_mkdir]   sys_mkdir,
</span></span><span style="display:flex;"><span> [SYS_close]   sys_close,
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+[SYS_mmap]    sys_mmap,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+[SYS_munmap]  sys_munmap,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> void
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/syscall.h b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index bc5f356..e7b18d6 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/syscall.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -20,3 +20,5 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #define SYS_link   19
</span></span><span style="display:flex;"><span> #define SYS_mkdir  20
</span></span><span style="display:flex;"><span> #define SYS_close  21
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_mmap   22
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#define SYS_munmap 23
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/sysfile.c b/kernel/sysfile.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 16b668c..83c70e0 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/sysfile.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/sysfile.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -15,6 +15,7 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;sleeplock.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;file.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;fcntl.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;memlayout.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> // Fetch the nth word-sized system call argument as a file descriptor
</span></span><span style="display:flex;"><span> // and return both the descriptor and the corresponding struct file.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -503,3 +504,31 @@ sys_pipe(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>   }
</span></span><span style="display:flex;"><span>   return 0;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_mmap(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 addr, sz, offset;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int prot, flags, fd;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct file *f;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(0, &amp;addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(1, &amp;sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(2, &amp;prot);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argint(3, &amp;flags);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argfd(4, &amp;fd, &amp;f);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(5, &amp;offset);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (sz == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return mmap(addr, sz, prot, flags, f, offset);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 sys_munmap(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 addr, sz;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(0, &amp;addr);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  argaddr(1, &amp;sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (sz == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return munmap(addr, sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/kernel/trap.c b/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index d454a7d..ba52987 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/trap.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -67,6 +67,14 @@ usertrap(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     syscall();
</span></span><span style="display:flex;"><span>   } else if((which_dev = devintr()) != 0){
</span></span><span style="display:flex;"><span>     // ok
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  } else if(r_scause() == 13 || r_scause() == 15){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uint64 va = r_stval();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (!handle_pagefault(va)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;usertrap(): unexpected scause 0x%lx pid=%d\n&#34;, r_scause(),
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+             p-&gt;pid);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      printf(&#34;            sepc=0x%lx stval=0x%lx\n&#34;, r_sepc(), r_stval());
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      setkilled(p);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   } else {
</span></span><span style="display:flex;"><span>     printf(&#34;usertrap(): unexpected scause 0x%lx pid=%d\n&#34;, r_scause(), p-&gt;pid);
</span></span><span style="display:flex;"><span>     printf(&#34;            sepc=0x%lx stval=0x%lx\n&#34;, r_sepc(), r_stval());
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/kernel/vm.c b/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 62421a2..aad9cd6 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/kernel/vm.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -5,6 +5,14 @@
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> #include &#34;riscv.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;defs.h&#34;
</span></span><span style="display:flex;"><span> #include &#34;fs.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;fcntl.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;spinlock.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;proc.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;sleeplock.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;file.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+#include &#34;stat.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> 
</span></span><span style="display:flex;"><span> /*
</span></span><span style="display:flex;"><span>  * the kernel&#39;s page table.
</span></span><span style="display:flex;"><span><span style="font-weight:bold">@@ -449,3 +457,176 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     return -1;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int handle_pagefault(uint64 va) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct vma *v = (struct vma *)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  va = PGROUNDDOWN(va);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (int i = 0; i &lt; NVMA; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    struct vma *vv = &amp;p-&gt;vmas[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (vv-&gt;valid == 1 &amp;&amp; va &gt;= vv-&gt;vastart &amp;&amp; va &lt; vv-&gt;vastart + vv-&gt;sz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      v = vv;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v == (struct vma *)0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  void *pa = kalloc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (pa == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;handle_pagefault: kalloc&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  memset(pa, 0, PGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  begin_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  idup(v-&gt;f-&gt;ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  ilock(v-&gt;f-&gt;ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  readi(v-&gt;f-&gt;ip, 0, (uint64)pa, v-&gt;offset + va - v-&gt;vastart, PGSIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  iunlockput(v-&gt;f-&gt;ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  int perm = PTE_U;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v-&gt;prot &amp; PROT_READ){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    perm |= PTE_R;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v-&gt;prot &amp; PROT_WRITE){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    perm |= PTE_W;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v-&gt;prot &amp; PROT_EXEC){
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    perm |= PTE_X;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, perm) &lt;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    panic(&#34;handle_pagefault: mappages&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 mmap(uint64 addr, uint64 len, int prot, int flags, struct file *f,
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+            uint64 offset) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (f &amp;&amp; ((!f-&gt;readable &amp;&amp; (prot &amp; (PROT_READ))) ||
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+            (!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; !(flags &amp; MAP_PRIVATE))))
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 end =
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      PGROUNDDOWN(VMASTOP); 
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (int i = 0; i &lt; NVMA;) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (p-&gt;vmas[i].valid) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      end = p-&gt;vmas[i].vastart;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      i++;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      continue;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    int j = i + 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    for (; j &lt;NVMA; j++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (p-&gt;vmas[j].valid)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    int next_end = (j == NVMA) ? PGROUNDUP(p-&gt;sz)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+                               : PGROUNDUP(p-&gt;vmas[j].vastart + p-&gt;vmas[j].sz);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (end - next_end &gt;= len) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (f &amp;&amp; (f-&gt;type != FD_INODE || !filedup(f))) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      struct  stat st;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      stati(f-&gt;ip, &amp;st);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].valid = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].vastart = PGROUNDDOWN(end - len);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].sz = len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].prot = prot;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].flags = flags;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].f = f;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].offset = offset;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      p-&gt;vmas[i].file_size = st.size;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return p-&gt;vmas[i].vastart;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    i = j;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 writeback(uint64 addr, size_t len, struct proc *p, struct vma *v)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (addr % PGSIZE) panic(&#34;writeback&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 end = addr + len, off = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for(;addr &lt; end; addr += PGSIZE, off += PGSIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    pte_t *pte = walk(p-&gt;pagetable, addr, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((*pte &amp; PTE_D) &amp;&amp; (*pte &amp; PTE_W)) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      begin_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      ilock(v-&gt;f-&gt;ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      if (writei(v-&gt;f-&gt;ip, 1, addr, v-&gt;offset + off, PGSIZE &gt; end - addr ? (end - addr) : PGSIZE) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        iunlock(v-&gt;f-&gt;ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+        return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      iunlock(v-&gt;f-&gt;ip);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      end_op();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+uint64 munmap(uint64 addr, size_t len)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+{
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (addr % PGSIZE != 0) return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  len = PGROUNDDOWN(len);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (len == 0) return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct proc *p = myproc();
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  struct vma *v = (struct vma *)0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (int i = 0; i &lt; NVMA; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    struct vma *vv = &amp;p-&gt;vmas[i];
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (vv-&gt;valid == 1 &amp;&amp; addr &gt;= vv-&gt;vastart &amp;&amp; addr &lt; vv-&gt;vastart + vv-&gt;sz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      v = vv;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (addr &gt; v-&gt;vastart &amp;&amp; addr + len &lt; v-&gt;vastart + v-&gt;sz) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v-&gt;flags == MAP_SHARED &amp;&amp; v-&gt;f &amp;&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      writeback(addr, (len &gt; v-&gt;file_size ? v-&gt;file_size : len), p, v) &lt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    return -1;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if (v-&gt;sz == len) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    v-&gt;valid = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (v-&gt;f)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      fileclose(v-&gt;f);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  } else {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if (v-&gt;vastart == addr)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      v-&gt;vastart += len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    v-&gt;sz -= len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    v-&gt;offset = (v-&gt;offset +len) &gt; v-&gt;file_size? v-&gt;file_size : (v-&gt;offset +len);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    v-&gt;file_size = v-&gt;file_size &lt; len? 0: v-&gt;file_size - len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  uint64 end = addr + len;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  for (; addr &lt; end; addr += PGSIZE) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    pte_t *pte;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((pte = walk(p-&gt;pagetable, addr, 0)) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      panic(&#34;uvmunmap: walk&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    if ((*pte &amp; PTE_V) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+      return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    uvmunmap(p-&gt;pagetable, addr, 1,1);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+}
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">diff --git a/user/mmaptest.c b/user/mmaptest.c
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 2f995ea..c6533e0 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/mmaptest.c
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/mmaptest.c
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -197,8 +197,11 @@ mmap_test(void)
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span>     if (buf[i] != &#39;B&#39;)
</span></span><span style="display:flex;"><span>       err(&#34;file page 0 does not contain modifications&#34;);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span><span style="color:#f55">-  if(read(fd, buf, PGSIZE) != PGSIZE/2)
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+  int len1 = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  if((len1 = read(fd, buf, PGSIZE)) != PGSIZE/2) {
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+    //printf(&#34;len1: %d, buf: %s\n&#34;, len1, buf);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>     err(&#34;dirty read #2&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span>   for (i = 0; i &lt; PGSIZE/2; i++){
</span></span><span style="display:flex;"><span>     if (buf[i] != &#39;C&#39;)
</span></span><span style="display:flex;"><span>       err(&#34;file page 1 does not contain modifications&#34;);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/user.h b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 0e9bd4a..dc9a30f 100644
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/user.h
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -26,6 +26,8 @@ int getpid(void);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> char* sbrk(int);
</span></span><span style="display:flex;"><span> int sleep(int);
</span></span><span style="display:flex;"><span> int uptime(void);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+int munmap(void *addr, size_t len);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span> #ifdef LAB_NET
</span></span><span style="display:flex;"><span> int bind(uint16);
</span></span><span style="display:flex;"><span> int unbind(uint16);
</span></span><span style="display:flex;"><span><span style="font-weight:bold">diff --git a/user/usys.pl b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold">index 01e426e..d23b9cc 100755
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span><span style="color:#f55">--- a/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#f55"></span><span style="color:#50fa7b;font-weight:bold">+++ b/user/usys.pl
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold"></span><span style="font-weight:bold">@@ -36,3 +36,5 @@ entry(&#34;getpid&#34;);
</span></span></span><span style="display:flex;"><span><span style="font-weight:bold"></span> entry(&#34;sbrk&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;sleep&#34;);
</span></span><span style="display:flex;"><span> entry(&#34;uptime&#34;);
</span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+entry(&#34;mmap&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#50fa7b;font-weight:bold">+entry(&#34;munmap&#34;);
</span></span></span></code></pre></div>
</details>


  </div>


  
<div>
  <ul class="tags">
  <li>
    <a href="https://www.zhangzewen.net/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/" class="tag-link">公开课</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="tag-link">操作系统</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/linux/" class="tag-link">Linux</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/mit/" class="tag-link">Mit</a>
  </li>
  
  <li>
    <a href="https://www.zhangzewen.net/tags/xv6/" class="tag-link">Xv6</a>
  </li>
  </ul>
</div>



  <div class="share-buttons">
    
  
<script src="https://utteranc.es/client.js"
        repo="zhangzewen/zhangzewen.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  
</div>
  </main>

  <footer>
  <div>
    <p>
      &copy; Zhang Zewen 2025

      &middot; <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">CC BY-SA 4.0</a>

      
    </p>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
    integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin="anonymous"></script>


  <script src="/js/jquery.min.js"></script>
  <script src="/js/soho.js"></script>

  

  
  
  
</body>

</html>
